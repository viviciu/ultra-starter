"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-client_node_modules_troika-three-text_dist_troika-three-text_esm_js"],{

/***/ "(app-client)/./node_modules/troika-three-text/dist/troika-three-text.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/troika-three-text/dist/troika-three-text.esm.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GlyphsGeometry: function() { return /* binding */ GlyphsGeometry; },\n/* harmony export */   Text: function() { return /* binding */ Text; },\n/* harmony export */   configureTextBuilder: function() { return /* binding */ configureTextBuilder; },\n/* harmony export */   createTextDerivedMaterial: function() { return /* binding */ createTextDerivedMaterial; },\n/* harmony export */   dumpSDFTextures: function() { return /* binding */ dumpSDFTextures; },\n/* harmony export */   fontResolverWorkerModule: function() { return /* binding */ fontResolverWorkerModule; },\n/* harmony export */   getCaretAtPoint: function() { return /* binding */ getCaretAtPoint; },\n/* harmony export */   getSelectionRects: function() { return /* binding */ getSelectionRects; },\n/* harmony export */   getTextRenderInfo: function() { return /* binding */ getTextRenderInfo; },\n/* harmony export */   preloadFont: function() { return /* binding */ preloadFont; },\n/* harmony export */   typesetterWorkerModule: function() { return /* binding */ typesetterWorkerModule; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(app-client)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! troika-worker-utils */ \"(app-client)/./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js\");\n/* harmony import */ var webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webgl-sdf-generator */ \"(app-client)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs\");\n/* harmony import */ var bidi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bidi-js */ \"(app-client)/./node_modules/bidi-js/dist/bidi.mjs\");\n/* harmony import */ var troika_three_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! troika-three-utils */ \"(app-client)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js\");\n\n\n\n\n\n\n/*!\nCustom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.\nOriginal MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE\n*/\nfunction typrFactory(){return \"undefined\"==typeof window&&(self.window=self),function(r){var e={parse:function(r){var t=e._bin,a=new Uint8Array(r);if(\"ttcf\"==t.readASCII(a,0,4)){var n=4;t.readUshort(a,n),n+=2,t.readUshort(a,n),n+=2;var o=t.readUint(a,n);n+=4;for(var s=[],i=0;i<o;i++){var h=t.readUint(a,n);n+=4,s.push(e._readFont(a,h));}return s}return [e._readFont(a,0)]},_readFont:function(r,t){var a=e._bin,n=t;a.readFixed(r,t),t+=4;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2;for(var s=[\"cmap\",\"head\",\"hhea\",\"maxp\",\"hmtx\",\"name\",\"OS/2\",\"post\",\"loca\",\"glyf\",\"kern\",\"CFF \",\"GDEF\",\"GPOS\",\"GSUB\",\"SVG \"],i={_data:r,_offset:n},h={},d=0;d<o;d++){var f=a.readASCII(r,t,4);t+=4,a.readUint(r,t),t+=4;var u=a.readUint(r,t);t+=4;var l=a.readUint(r,t);t+=4,h[f]={offset:u,length:l};}for(d=0;d<s.length;d++){var v=s[d];h[v]&&(i[v.trim()]=e[v.trim()].parse(r,h[v].offset,h[v].length,i));}return i},_tabOffset:function(r,t,a){for(var n=e._bin,o=n.readUshort(r,a+4),s=a+12,i=0;i<o;i++){var h=n.readASCII(r,s,4);s+=4,n.readUint(r,s),s+=4;var d=n.readUint(r,s);if(s+=4,n.readUint(r,s),s+=4,h==t)return d}return 0}};e._bin={readFixed:function(r,e){return (r[e]<<8|r[e+1])+(r[e+2]<<8|r[e+3])/65540},readF2dot14:function(r,t){return e._bin.readShort(r,t)/16384},readInt:function(r,t){return e._bin._view(r).getInt32(t)},readInt8:function(r,t){return e._bin._view(r).getInt8(t)},readShort:function(r,t){return e._bin._view(r).getInt16(t)},readUshort:function(r,t){return e._bin._view(r).getUint16(t)},readUshorts:function(r,t,a){for(var n=[],o=0;o<a;o++)n.push(e._bin.readUshort(r,t+2*o));return n},readUint:function(r,t){return e._bin._view(r).getUint32(t)},readUint64:function(r,t){return 4294967296*e._bin.readUint(r,t)+e._bin.readUint(r,t+4)},readASCII:function(r,e,t){for(var a=\"\",n=0;n<t;n++)a+=String.fromCharCode(r[e+n]);return a},readUnicode:function(r,e,t){for(var a=\"\",n=0;n<t;n++){var o=r[e++]<<8|r[e++];a+=String.fromCharCode(o);}return a},_tdec:\"undefined\"!=typeof window&&window.TextDecoder?new window.TextDecoder:null,readUTF8:function(r,t,a){var n=e._bin._tdec;return n&&0==t&&a==r.length?n.decode(r):e._bin.readASCII(r,t,a)},readBytes:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(r[e+n]);return a},readASCIIArray:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(String.fromCharCode(r[e+n]));return a},_view:function(r){return r._dataView||(r._dataView=r.buffer?new DataView(r.buffer,r.byteOffset,r.byteLength):new DataView(new Uint8Array(r).buffer))}},e._lctf={},e._lctf.parse=function(r,t,a,n,o){var s=e._bin,i={},h=t;s.readFixed(r,t),t+=4;var d=s.readUshort(r,t);t+=2;var f=s.readUshort(r,t);t+=2;var u=s.readUshort(r,t);return t+=2,i.scriptList=e._lctf.readScriptList(r,h+d),i.featureList=e._lctf.readFeatureList(r,h+f),i.lookupList=e._lctf.readLookupList(r,h+u,o),i},e._lctf.readLookupList=function(r,t,a){var n=e._bin,o=t,s=[],i=n.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var d=n.readUshort(r,t);t+=2;var f=e._lctf.readLookupTable(r,o+d,a);s.push(f);}return s},e._lctf.readLookupTable=function(r,t,a){var n=e._bin,o=t,s={tabs:[]};s.ltype=n.readUshort(r,t),t+=2,s.flag=n.readUshort(r,t),t+=2;var i=n.readUshort(r,t);t+=2;for(var h=s.ltype,d=0;d<i;d++){var f=n.readUshort(r,t);t+=2;var u=a(r,h,o+f,s);s.tabs.push(u);}return s},e._lctf.numOfOnes=function(r){for(var e=0,t=0;t<32;t++)0!=(r>>>t&1)&&e++;return e},e._lctf.readClassDef=function(r,t){var a=e._bin,n=[],o=a.readUshort(r,t);if(t+=2,1==o){var s=a.readUshort(r,t);t+=2;var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++)n.push(s+h),n.push(s+h),n.push(a.readUshort(r,t)),t+=2;}if(2==o){var d=a.readUshort(r,t);t+=2;for(h=0;h<d;h++)n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2;}return n},e._lctf.getInterval=function(r,e){for(var t=0;t<r.length;t+=3){var a=r[t],n=r[t+1];if(r[t+2],a<=e&&e<=n)return t}return -1},e._lctf.readCoverage=function(r,t){var a=e._bin,n={};n.fmt=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,1==n.fmt&&(n.tab=a.readUshorts(r,t,o)),2==n.fmt&&(n.tab=a.readUshorts(r,t,3*o)),n},e._lctf.coverageIndex=function(r,t){var a=r.tab;if(1==r.fmt)return a.indexOf(t);if(2==r.fmt){var n=e._lctf.getInterval(a,t);if(-1!=n)return a[n+2]+(t-a[n])}return -1},e._lctf.readFeatureList=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var d=a.readUshort(r,t);t+=2;var f=e._lctf.readFeatureTable(r,n+d);f.tag=h.trim(),o.push(f);}return o},e._lctf.readFeatureTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,s>0&&(o.featureParams=n+s);var i=a.readUshort(r,t);t+=2,o.tab=[];for(var h=0;h<i;h++)o.tab.push(a.readUshort(r,t+2*h));return o},e._lctf.readScriptList=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var d=a.readUshort(r,t);t+=2,o[h.trim()]=e._lctf.readScriptTable(r,n+d);}return o},e._lctf.readScriptTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,s>0&&(o.default=e._lctf.readLangSysTable(r,n+s));var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var d=a.readASCII(r,t,4);t+=4;var f=a.readUshort(r,t);t+=2,o[d.trim()]=e._lctf.readLangSysTable(r,n+f);}return o},e._lctf.readLangSysTable=function(r,t){var a=e._bin,n={};a.readUshort(r,t),t+=2,n.reqFeature=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,n.features=a.readUshorts(r,t,o),n},e.CFF={},e.CFF.parse=function(r,t,a){var n=e._bin;(r=new Uint8Array(r.buffer,t,a))[t=0],r[++t],r[++t],r[++t],t++;var o=[];t=e.CFF.readIndex(r,t,o);for(var s=[],i=0;i<o.length-1;i++)s.push(n.readASCII(r,t+o[i],o[i+1]-o[i]));t+=o[o.length-1];var h=[];t=e.CFF.readIndex(r,t,h);var d=[];for(i=0;i<h.length-1;i++)d.push(e.CFF.readDict(r,t+h[i],t+h[i+1]));t+=h[h.length-1];var f=d[0],u=[];t=e.CFF.readIndex(r,t,u);var l=[];for(i=0;i<u.length-1;i++)l.push(n.readASCII(r,t+u[i],u[i+1]-u[i]));if(t+=u[u.length-1],e.CFF.readSubrs(r,t,f),f.CharStrings){t=f.CharStrings;u=[];t=e.CFF.readIndex(r,t,u);var v=[];for(i=0;i<u.length-1;i++)v.push(n.readBytes(r,t+u[i],u[i+1]-u[i]));f.CharStrings=v;}if(f.ROS){t=f.FDArray;var c=[];t=e.CFF.readIndex(r,t,c),f.FDArray=[];for(i=0;i<c.length-1;i++){var p=e.CFF.readDict(r,t+c[i],t+c[i+1]);e.CFF._readFDict(r,p,l),f.FDArray.push(p);}t+=c[c.length-1],t=f.FDSelect,f.FDSelect=[];var U=r[t];if(t++,3!=U)throw U;var g=n.readUshort(r,t);t+=2;for(i=0;i<g+1;i++)f.FDSelect.push(n.readUshort(r,t),r[t+2]),t+=3;}return f.Encoding&&(f.Encoding=e.CFF.readEncoding(r,f.Encoding,f.CharStrings.length)),f.charset&&(f.charset=e.CFF.readCharset(r,f.charset,f.CharStrings.length)),e.CFF._readFDict(r,f,l),f},e.CFF._readFDict=function(r,t,a){var n;for(var o in t.Private&&(n=t.Private[1],t.Private=e.CFF.readDict(r,n,n+t.Private[0]),t.Private.Subrs&&e.CFF.readSubrs(r,n+t.Private.Subrs,t.Private)),t)-1!=[\"FamilyName\",\"FontName\",\"FullName\",\"Notice\",\"version\",\"Copyright\"].indexOf(o)&&(t[o]=a[t[o]-426+35]);},e.CFF.readSubrs=function(r,t,a){var n=e._bin,o=[];t=e.CFF.readIndex(r,t,o);var s,i=o.length;s=i<1240?107:i<33900?1131:32768,a.Bias=s,a.Subrs=[];for(var h=0;h<o.length-1;h++)a.Subrs.push(n.readBytes(r,t+o[h],o[h+1]-o[h]));},e.CFF.tableSE=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,0,111,112,113,114,0,115,116,117,118,119,120,121,122,0,123,0,124,125,126,127,128,129,130,131,0,132,133,0,134,135,136,137,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,138,0,139,0,0,0,0,140,141,142,143,0,0,0,0,0,144,0,0,0,145,0,0,146,147,148,149,0,0,0,0],e.CFF.glyphByUnicode=function(r,e){for(var t=0;t<r.charset.length;t++)if(r.charset[t]==e)return t;return -1},e.CFF.glyphBySE=function(r,t){return t<0||t>255?-1:e.CFF.glyphByUnicode(r,e.CFF.tableSE[t])},e.CFF.readEncoding=function(r,t,a){e._bin;var n=[\".notdef\"],o=r[t];if(t++,0!=o)throw \"error: unknown encoding format: \"+o;var s=r[t];t++;for(var i=0;i<s;i++)n.push(r[t+i]);return n},e.CFF.readCharset=function(r,t,a){var n=e._bin,o=[\".notdef\"],s=r[t];if(t++,0==s)for(var i=0;i<a;i++){var h=n.readUshort(r,t);t+=2,o.push(h);}else {if(1!=s&&2!=s)throw \"error: format: \"+s;for(;o.length<a;){h=n.readUshort(r,t);t+=2;var d=0;1==s?(d=r[t],t++):(d=n.readUshort(r,t),t+=2);for(i=0;i<=d;i++)o.push(h),h++;}}return o},e.CFF.readIndex=function(r,t,a){var n=e._bin,o=n.readUshort(r,t)+1,s=r[t+=2];if(t++,1==s)for(var i=0;i<o;i++)a.push(r[t+i]);else if(2==s)for(i=0;i<o;i++)a.push(n.readUshort(r,t+2*i));else if(3==s)for(i=0;i<o;i++)a.push(16777215&n.readUint(r,t+3*i-1));else if(1!=o)throw \"unsupported offset size: \"+s+\", count: \"+o;return (t+=o*s)-1},e.CFF.getCharString=function(r,t,a){var n=e._bin,o=r[t],s=r[t+1];r[t+2],r[t+3],r[t+4];var i=1,h=null,d=null;o<=20&&(h=o,i=1),12==o&&(h=100*o+s,i=2),21<=o&&o<=27&&(h=o,i=1),28==o&&(d=n.readShort(r,t+1),i=3),29<=o&&o<=31&&(h=o,i=1),32<=o&&o<=246&&(d=o-139,i=1),247<=o&&o<=250&&(d=256*(o-247)+s+108,i=2),251<=o&&o<=254&&(d=256*-(o-251)-s-108,i=2),255==o&&(d=n.readInt(r,t+1)/65535,i=5),a.val=null!=d?d:\"o\"+h,a.size=i;},e.CFF.readCharString=function(r,t,a){for(var n=t+a,o=e._bin,s=[];t<n;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var d=1,f=null,u=null;i<=20&&(f=i,d=1),12==i&&(f=100*i+h,d=2),19!=i&&20!=i||(f=i,d=2),21<=i&&i<=27&&(f=i,d=1),28==i&&(u=o.readShort(r,t+1),d=3),29<=i&&i<=31&&(f=i,d=1),32<=i&&i<=246&&(u=i-139,d=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,d=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,d=2),255==i&&(u=o.readInt(r,t+1)/65535,d=5),s.push(null!=u?u:\"o\"+f),t+=d;}return s},e.CFF.readDict=function(r,t,a){for(var n=e._bin,o={},s=[];t<a;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var d=1,f=null,u=null;if(28==i&&(u=n.readShort(r,t+1),d=3),29==i&&(u=n.readInt(r,t+1),d=5),32<=i&&i<=246&&(u=i-139,d=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,d=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,d=2),255==i)throw u=n.readInt(r,t+1)/65535,d=5,\"unknown number\";if(30==i){var l=[];for(d=1;;){var v=r[t+d];d++;var c=v>>4,p=15&v;if(15!=c&&l.push(c),15!=p&&l.push(p),15==p)break}for(var U=\"\",g=[0,1,2,3,4,5,6,7,8,9,\".\",\"e\",\"e-\",\"reserved\",\"-\",\"endOfNumber\"],S=0;S<l.length;S++)U+=g[l[S]];u=parseFloat(U);}if(i<=21)if(f=[\"version\",\"Notice\",\"FullName\",\"FamilyName\",\"Weight\",\"FontBBox\",\"BlueValues\",\"OtherBlues\",\"FamilyBlues\",\"FamilyOtherBlues\",\"StdHW\",\"StdVW\",\"escape\",\"UniqueID\",\"XUID\",\"charset\",\"Encoding\",\"CharStrings\",\"Private\",\"Subrs\",\"defaultWidthX\",\"nominalWidthX\"][i],d=1,12==i)f=[\"Copyright\",\"isFixedPitch\",\"ItalicAngle\",\"UnderlinePosition\",\"UnderlineThickness\",\"PaintType\",\"CharstringType\",\"FontMatrix\",\"StrokeWidth\",\"BlueScale\",\"BlueShift\",\"BlueFuzz\",\"StemSnapH\",\"StemSnapV\",\"ForceBold\",0,0,\"LanguageGroup\",\"ExpansionFactor\",\"initialRandomSeed\",\"SyntheticBase\",\"PostScript\",\"BaseFontName\",\"BaseFontBlend\",0,0,0,0,0,0,\"ROS\",\"CIDFontVersion\",\"CIDFontRevision\",\"CIDFontType\",\"CIDCount\",\"UIDBase\",\"FDArray\",\"FDSelect\",\"FontName\"][h],d=2;null!=f?(o[f]=1==s.length?s[0]:s,s=[]):s.push(u),t+=d;}return o},e.cmap={},e.cmap.parse=function(r,t,a){r=new Uint8Array(r.buffer,t,a),t=0;var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2;var i=[];o.tables=[];for(var h=0;h<s;h++){var d=n.readUshort(r,t);t+=2;var f=n.readUshort(r,t);t+=2;var u=n.readUint(r,t);t+=4;var l=\"p\"+d+\"e\"+f,v=i.indexOf(u);if(-1==v){var c;v=o.tables.length,i.push(u);var p=n.readUshort(r,u);0==p?c=e.cmap.parse0(r,u):4==p?c=e.cmap.parse4(r,u):6==p?c=e.cmap.parse6(r,u):12==p?c=e.cmap.parse12(r,u):console.debug(\"unknown format: \"+p,d,f,u),o.tables.push(c);}if(null!=o[l])throw \"multiple tables for one platform+encoding\";o[l]=v;}return o},e.cmap.parse0=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,n.map=[];for(var s=0;s<o-6;s++)n.map.push(r[t+s]);return n},e.cmap.parse4=function(r,t){var a=e._bin,n=t,o={};o.format=a.readUshort(r,t),t+=2;var s=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2;var i=a.readUshort(r,t);t+=2;var h=i/2;o.searchRange=a.readUshort(r,t),t+=2,o.entrySelector=a.readUshort(r,t),t+=2,o.rangeShift=a.readUshort(r,t),t+=2,o.endCount=a.readUshorts(r,t,h),t+=2*h,t+=2,o.startCount=a.readUshorts(r,t,h),t+=2*h,o.idDelta=[];for(var d=0;d<h;d++)o.idDelta.push(a.readShort(r,t)),t+=2;for(o.idRangeOffset=a.readUshorts(r,t,h),t+=2*h,o.glyphIdArray=[];t<n+s;)o.glyphIdArray.push(a.readUshort(r,t)),t+=2;return o},e.cmap.parse6=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,n.firstCode=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,n.glyphIdArray=[];for(var s=0;s<o;s++)n.glyphIdArray.push(a.readUshort(r,t)),t+=2;return n},e.cmap.parse12=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,t+=2,a.readUint(r,t),t+=4,a.readUint(r,t),t+=4;var o=a.readUint(r,t);t+=4,n.groups=[];for(var s=0;s<o;s++){var i=t+12*s,h=a.readUint(r,i+0),d=a.readUint(r,i+4),f=a.readUint(r,i+8);n.groups.push([h,d,f]);}return n},e.glyf={},e.glyf.parse=function(r,e,t,a){for(var n=[],o=0;o<a.maxp.numGlyphs;o++)n.push(null);return n},e.glyf._parseGlyf=function(r,t){var a=e._bin,n=r._data,o=e._tabOffset(n,\"glyf\",r._offset)+r.loca[t];if(r.loca[t]==r.loca[t+1])return null;var s={};if(s.noc=a.readShort(n,o),o+=2,s.xMin=a.readShort(n,o),o+=2,s.yMin=a.readShort(n,o),o+=2,s.xMax=a.readShort(n,o),o+=2,s.yMax=a.readShort(n,o),o+=2,s.xMin>=s.xMax||s.yMin>=s.yMax)return null;if(s.noc>0){s.endPts=[];for(var i=0;i<s.noc;i++)s.endPts.push(a.readUshort(n,o)),o+=2;var h=a.readUshort(n,o);if(o+=2,n.length-o<h)return null;s.instructions=a.readBytes(n,o,h),o+=h;var d=s.endPts[s.noc-1]+1;s.flags=[];for(i=0;i<d;i++){var f=n[o];if(o++,s.flags.push(f),0!=(8&f)){var u=n[o];o++;for(var l=0;l<u;l++)s.flags.push(f),i++;}}s.xs=[];for(i=0;i<d;i++){var v=0!=(2&s.flags[i]),c=0!=(16&s.flags[i]);v?(s.xs.push(c?n[o]:-n[o]),o++):c?s.xs.push(0):(s.xs.push(a.readShort(n,o)),o+=2);}s.ys=[];for(i=0;i<d;i++){v=0!=(4&s.flags[i]),c=0!=(32&s.flags[i]);v?(s.ys.push(c?n[o]:-n[o]),o++):c?s.ys.push(0):(s.ys.push(a.readShort(n,o)),o+=2);}var p=0,U=0;for(i=0;i<d;i++)p+=s.xs[i],U+=s.ys[i],s.xs[i]=p,s.ys[i]=U;}else {var g;s.parts=[];do{g=a.readUshort(n,o),o+=2;var S={m:{a:1,b:0,c:0,d:1,tx:0,ty:0},p1:-1,p2:-1};if(s.parts.push(S),S.glyphIndex=a.readUshort(n,o),o+=2,1&g){var m=a.readShort(n,o);o+=2;var b=a.readShort(n,o);o+=2;}else {m=a.readInt8(n,o);o++;b=a.readInt8(n,o);o++;}2&g?(S.m.tx=m,S.m.ty=b):(S.p1=m,S.p2=b),8&g?(S.m.a=S.m.d=a.readF2dot14(n,o),o+=2):64&g?(S.m.a=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2):128&g&&(S.m.a=a.readF2dot14(n,o),o+=2,S.m.b=a.readF2dot14(n,o),o+=2,S.m.c=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2);}while(32&g);if(256&g){var y=a.readUshort(n,o);o+=2,s.instr=[];for(i=0;i<y;i++)s.instr.push(n[o]),o++;}}return s},e.GDEF={},e.GDEF.parse=function(r,t,a,n){var o=t;t+=4;var s=e._bin.readUshort(r,t);return {glyphClassDef:0===s?null:e._lctf.readClassDef(r,o+s)}},e.GPOS={},e.GPOS.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GPOS.subt)},e.GPOS.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1==t||2==t||3==t||7==t||8==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,h+s);}if(1==t&&1==i.fmt){var d=o.readUshort(r,a);a+=2,0!=d&&(i.pos=e.GPOS.readValueRecord(r,a,d));}else if(2==t&&i.fmt>=1&&i.fmt<=2){d=o.readUshort(r,a);a+=2;var f=o.readUshort(r,a);a+=2;var u=e._lctf.numOfOnes(d),l=e._lctf.numOfOnes(f);if(1==i.fmt){i.pairsets=[];var v=o.readUshort(r,a);a+=2;for(var c=0;c<v;c++){var p=s+o.readUshort(r,a);a+=2;var U=o.readUshort(r,p);p+=2;for(var g=[],S=0;S<U;S++){var m=o.readUshort(r,p);p+=2,0!=d&&(P=e.GPOS.readValueRecord(r,p,d),p+=2*u),0!=f&&(x=e.GPOS.readValueRecord(r,p,f),p+=2*l),g.push({gid2:m,val1:P,val2:x});}i.pairsets.push(g);}}if(2==i.fmt){var b=o.readUshort(r,a);a+=2;var y=o.readUshort(r,a);a+=2;var F=o.readUshort(r,a);a+=2;var C=o.readUshort(r,a);a+=2,i.classDef1=e._lctf.readClassDef(r,s+b),i.classDef2=e._lctf.readClassDef(r,s+y),i.matrix=[];for(c=0;c<F;c++){var _=[];for(S=0;S<C;S++){var P=null,x=null;0!=d&&(P=e.GPOS.readValueRecord(r,a,d),a+=2*u),0!=f&&(x=e.GPOS.readValueRecord(r,a,f),a+=2*l),_.push({val1:P,val2:x});}i.matrix.push(_);}}}else if(4==t&&1==i.fmt)i.markCoverage=e._lctf.readCoverage(r,o.readUshort(r,a)+s),i.baseCoverage=e._lctf.readCoverage(r,o.readUshort(r,a+2)+s),i.markClassCount=o.readUshort(r,a+4),i.markArray=e.GPOS.readMarkArray(r,o.readUshort(r,a+6)+s),i.baseArray=e.GPOS.readBaseArray(r,o.readUshort(r,a+8)+s,i.markClassCount);else if(6==t&&1==i.fmt)i.mark1Coverage=e._lctf.readCoverage(r,o.readUshort(r,a)+s),i.mark2Coverage=e._lctf.readCoverage(r,o.readUshort(r,a+2)+s),i.markClassCount=o.readUshort(r,a+4),i.mark1Array=e.GPOS.readMarkArray(r,o.readUshort(r,a+6)+s),i.mark2Array=e.GPOS.readBaseArray(r,o.readUshort(r,a+8)+s,i.markClassCount);else {if(9==t&&1==i.fmt){var I=o.readUshort(r,a);a+=2;var w=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=I;else if(n.ltype!=I)throw \"invalid extension substitution\";return e.GPOS.subt(r,n.ltype,s+w)}console.debug(\"unsupported GPOS table LookupType\",t,\"format\",i.fmt);}return i},e.GPOS.readValueRecord=function(r,t,a){var n=e._bin,o=[];return o.push(1&a?n.readShort(r,t):0),t+=1&a?2:0,o.push(2&a?n.readShort(r,t):0),t+=2&a?2:0,o.push(4&a?n.readShort(r,t):0),t+=4&a?2:0,o.push(8&a?n.readShort(r,t):0),t+=8&a?2:0,o},e.GPOS.readBaseArray=function(r,t,a){var n=e._bin,o=[],s=t,i=n.readUshort(r,t);t+=2;for(var h=0;h<i;h++){for(var d=[],f=0;f<a;f++)d.push(e.GPOS.readAnchorRecord(r,s+n.readUshort(r,t))),t+=2;o.push(d);}return o},e.GPOS.readMarkArray=function(r,t){var a=e._bin,n=[],o=t,s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=e.GPOS.readAnchorRecord(r,a.readUshort(r,t+2)+o);h.markClass=a.readUshort(r,t),n.push(h),t+=4;}return n},e.GPOS.readAnchorRecord=function(r,t){var a=e._bin,n={};return n.fmt=a.readUshort(r,t),n.x=a.readShort(r,t+2),n.y=a.readShort(r,t+4),n},e.GSUB={},e.GSUB.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GSUB.subt)},e.GSUB.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1!=t&&2!=t&&4!=t&&5!=t&&6!=t)return null;if(1==t||2==t||4==t||5==t&&i.fmt<=2||6==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,s+h);}if(1==t&&i.fmt>=1&&i.fmt<=2){if(1==i.fmt)i.delta=o.readShort(r,a),a+=2;else if(2==i.fmt){var d=o.readUshort(r,a);a+=2,i.newg=o.readUshorts(r,a,d),a+=2*i.newg.length;}}else if(2==t&&1==i.fmt){d=o.readUshort(r,a);a+=2,i.seqs=[];for(var f=0;f<d;f++){var u=o.readUshort(r,a)+s;a+=2;var l=o.readUshort(r,u);i.seqs.push(o.readUshorts(r,u+2,l));}}else if(4==t){i.vals=[];d=o.readUshort(r,a);a+=2;for(f=0;f<d;f++){var v=o.readUshort(r,a);a+=2,i.vals.push(e.GSUB.readLigatureSet(r,s+v));}}else if(5==t&&2==i.fmt){if(2==i.fmt){var c=o.readUshort(r,a);a+=2,i.cDef=e._lctf.readClassDef(r,s+c),i.scset=[];var p=o.readUshort(r,a);a+=2;for(f=0;f<p;f++){var U=o.readUshort(r,a);a+=2,i.scset.push(0==U?null:e.GSUB.readSubClassSet(r,s+U));}}}else if(6==t&&3==i.fmt){if(3==i.fmt){for(f=0;f<3;f++){d=o.readUshort(r,a);a+=2;for(var g=[],S=0;S<d;S++)g.push(e._lctf.readCoverage(r,s+o.readUshort(r,a+2*S)));a+=2*d,0==f&&(i.backCvg=g),1==f&&(i.inptCvg=g),2==f&&(i.ahedCvg=g);}d=o.readUshort(r,a);a+=2,i.lookupRec=e.GSUB.readSubstLookupRecords(r,a,d);}}else {if(7==t&&1==i.fmt){var m=o.readUshort(r,a);a+=2;var b=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=m;else if(n.ltype!=m)throw \"invalid extension substitution\";return e.GSUB.subt(r,n.ltype,s+b)}console.debug(\"unsupported GSUB table LookupType\",t,\"format\",i.fmt);}return i},e.GSUB.readSubClassSet=function(r,t){var a=e._bin.readUshort,n=t,o=[],s=a(r,t);t+=2;for(var i=0;i<s;i++){var h=a(r,t);t+=2,o.push(e.GSUB.readSubClassRule(r,n+h));}return o},e.GSUB.readSubClassRule=function(r,t){var a=e._bin.readUshort,n={},o=a(r,t),s=a(r,t+=2);t+=2,n.input=[];for(var i=0;i<o-1;i++)n.input.push(a(r,t)),t+=2;return n.substLookupRecords=e.GSUB.readSubstLookupRecords(r,t,s),n},e.GSUB.readSubstLookupRecords=function(r,t,a){for(var n=e._bin.readUshort,o=[],s=0;s<a;s++)o.push(n(r,t),n(r,t+2)),t+=4;return o},e.GSUB.readChainSubClassSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readChainSubClassRule(r,n+h));}return o},e.GSUB.readChainSubClassRule=function(r,t){for(var a=e._bin,n={},o=[\"backtrack\",\"input\",\"lookahead\"],s=0;s<o.length;s++){var i=a.readUshort(r,t);t+=2,1==s&&i--,n[o[s]]=a.readUshorts(r,t,i),t+=2*n[o[s]].length;}i=a.readUshort(r,t);return t+=2,n.subst=a.readUshorts(r,t,2*i),t+=2*n.subst.length,n},e.GSUB.readLigatureSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readLigature(r,n+h));}return o},e.GSUB.readLigature=function(r,t){var a=e._bin,n={chain:[]};n.nglyph=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2;for(var s=0;s<o-1;s++)n.chain.push(a.readUshort(r,t)),t+=2;return n},e.head={},e.head.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.fontRevision=n.readFixed(r,t),t+=4,n.readUint(r,t),t+=4,n.readUint(r,t),t+=4,o.flags=n.readUshort(r,t),t+=2,o.unitsPerEm=n.readUshort(r,t),t+=2,o.created=n.readUint64(r,t),t+=8,o.modified=n.readUint64(r,t),t+=8,o.xMin=n.readShort(r,t),t+=2,o.yMin=n.readShort(r,t),t+=2,o.xMax=n.readShort(r,t),t+=2,o.yMax=n.readShort(r,t),t+=2,o.macStyle=n.readUshort(r,t),t+=2,o.lowestRecPPEM=n.readUshort(r,t),t+=2,o.fontDirectionHint=n.readShort(r,t),t+=2,o.indexToLocFormat=n.readShort(r,t),t+=2,o.glyphDataFormat=n.readShort(r,t),t+=2,o},e.hhea={},e.hhea.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.ascender=n.readShort(r,t),t+=2,o.descender=n.readShort(r,t),t+=2,o.lineGap=n.readShort(r,t),t+=2,o.advanceWidthMax=n.readUshort(r,t),t+=2,o.minLeftSideBearing=n.readShort(r,t),t+=2,o.minRightSideBearing=n.readShort(r,t),t+=2,o.xMaxExtent=n.readShort(r,t),t+=2,o.caretSlopeRise=n.readShort(r,t),t+=2,o.caretSlopeRun=n.readShort(r,t),t+=2,o.caretOffset=n.readShort(r,t),t+=2,t+=8,o.metricDataFormat=n.readShort(r,t),t+=2,o.numberOfHMetrics=n.readUshort(r,t),t+=2,o},e.hmtx={},e.hmtx.parse=function(r,t,a,n){for(var o=e._bin,s={aWidth:[],lsBearing:[]},i=0,h=0,d=0;d<n.maxp.numGlyphs;d++)d<n.hhea.numberOfHMetrics&&(i=o.readUshort(r,t),t+=2,h=o.readShort(r,t),t+=2),s.aWidth.push(i),s.lsBearing.push(h);return s},e.kern={},e.kern.parse=function(r,t,a,n){var o=e._bin,s=o.readUshort(r,t);if(t+=2,1==s)return e.kern.parseV1(r,t-2,a,n);var i=o.readUshort(r,t);t+=2;for(var h={glyph1:[],rval:[]},d=0;d<i;d++){t+=2;a=o.readUshort(r,t);t+=2;var f=o.readUshort(r,t);t+=2;var u=f>>>8;if(0!=(u&=15))throw \"unknown kern table format: \"+u;t=e.kern.readFormat0(r,t,h);}return h},e.kern.parseV1=function(r,t,a,n){var o=e._bin;o.readFixed(r,t),t+=4;var s=o.readUint(r,t);t+=4;for(var i={glyph1:[],rval:[]},h=0;h<s;h++){o.readUint(r,t),t+=4;var d=o.readUshort(r,t);t+=2,o.readUshort(r,t),t+=2;var f=d>>>8;if(0!=(f&=15))throw \"unknown kern table format: \"+f;t=e.kern.readFormat0(r,t,i);}return i},e.kern.readFormat0=function(r,t,a){var n=e._bin,o=-1,s=n.readUshort(r,t);t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2;for(var i=0;i<s;i++){var h=n.readUshort(r,t);t+=2;var d=n.readUshort(r,t);t+=2;var f=n.readShort(r,t);t+=2,h!=o&&(a.glyph1.push(h),a.rval.push({glyph2:[],vals:[]}));var u=a.rval[a.rval.length-1];u.glyph2.push(d),u.vals.push(f),o=h;}return t},e.loca={},e.loca.parse=function(r,t,a,n){var o=e._bin,s=[],i=n.head.indexToLocFormat,h=n.maxp.numGlyphs+1;if(0==i)for(var d=0;d<h;d++)s.push(o.readUshort(r,t+(d<<1))<<1);if(1==i)for(d=0;d<h;d++)s.push(o.readUint(r,t+(d<<2)));return s},e.maxp={},e.maxp.parse=function(r,t,a){var n=e._bin,o={},s=n.readUint(r,t);return t+=4,o.numGlyphs=n.readUshort(r,t),t+=2,65536==s&&(o.maxPoints=n.readUshort(r,t),t+=2,o.maxContours=n.readUshort(r,t),t+=2,o.maxCompositePoints=n.readUshort(r,t),t+=2,o.maxCompositeContours=n.readUshort(r,t),t+=2,o.maxZones=n.readUshort(r,t),t+=2,o.maxTwilightPoints=n.readUshort(r,t),t+=2,o.maxStorage=n.readUshort(r,t),t+=2,o.maxFunctionDefs=n.readUshort(r,t),t+=2,o.maxInstructionDefs=n.readUshort(r,t),t+=2,o.maxStackElements=n.readUshort(r,t),t+=2,o.maxSizeOfInstructions=n.readUshort(r,t),t+=2,o.maxComponentElements=n.readUshort(r,t),t+=2,o.maxComponentDepth=n.readUshort(r,t),t+=2),o},e.name={},e.name.parse=function(r,t,a){var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2,n.readUshort(r,t);for(var i,h=[\"copyright\",\"fontFamily\",\"fontSubfamily\",\"ID\",\"fullName\",\"version\",\"postScriptName\",\"trademark\",\"manufacturer\",\"designer\",\"description\",\"urlVendor\",\"urlDesigner\",\"licence\",\"licenceURL\",\"---\",\"typoFamilyName\",\"typoSubfamilyName\",\"compatibleFull\",\"sampleText\",\"postScriptCID\",\"wwsFamilyName\",\"wwsSubfamilyName\",\"lightPalette\",\"darkPalette\"],d=t+=2,f=0;f<s;f++){var u=n.readUshort(r,t);t+=2;var l=n.readUshort(r,t);t+=2;var v=n.readUshort(r,t);t+=2;var c=n.readUshort(r,t);t+=2;var p=n.readUshort(r,t);t+=2;var U=n.readUshort(r,t);t+=2;var g,S=h[c],m=d+12*s+U;if(0==u)g=n.readUnicode(r,m,p/2);else if(3==u&&0==l)g=n.readUnicode(r,m,p/2);else if(0==l)g=n.readASCII(r,m,p);else if(1==l)g=n.readUnicode(r,m,p/2);else if(3==l)g=n.readUnicode(r,m,p/2);else {if(1!=u)throw \"unknown encoding \"+l+\", platformID: \"+u;g=n.readASCII(r,m,p),console.debug(\"reading unknown MAC encoding \"+l+\" as ASCII\");}var b=\"p\"+u+\",\"+v.toString(16);null==o[b]&&(o[b]={}),o[b][void 0!==S?S:c]=g,o[b]._lang=v;}for(var y in o)if(null!=o[y].postScriptName&&1033==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&0==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&3084==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName)return o[y];for(var y in o){i=y;break}return console.debug(\"returning name table with languageID \"+o[i]._lang),o[i]},e[\"OS/2\"]={},e[\"OS/2\"].parse=function(r,t,a){var n=e._bin.readUshort(r,t);t+=2;var o={};if(0==n)e[\"OS/2\"].version0(r,t,o);else if(1==n)e[\"OS/2\"].version1(r,t,o);else if(2==n||3==n||4==n)e[\"OS/2\"].version2(r,t,o);else {if(5!=n)throw \"unknown OS/2 table version: \"+n;e[\"OS/2\"].version5(r,t,o);}return o},e[\"OS/2\"].version0=function(r,t,a){var n=e._bin;return a.xAvgCharWidth=n.readShort(r,t),t+=2,a.usWeightClass=n.readUshort(r,t),t+=2,a.usWidthClass=n.readUshort(r,t),t+=2,a.fsType=n.readUshort(r,t),t+=2,a.ySubscriptXSize=n.readShort(r,t),t+=2,a.ySubscriptYSize=n.readShort(r,t),t+=2,a.ySubscriptXOffset=n.readShort(r,t),t+=2,a.ySubscriptYOffset=n.readShort(r,t),t+=2,a.ySuperscriptXSize=n.readShort(r,t),t+=2,a.ySuperscriptYSize=n.readShort(r,t),t+=2,a.ySuperscriptXOffset=n.readShort(r,t),t+=2,a.ySuperscriptYOffset=n.readShort(r,t),t+=2,a.yStrikeoutSize=n.readShort(r,t),t+=2,a.yStrikeoutPosition=n.readShort(r,t),t+=2,a.sFamilyClass=n.readShort(r,t),t+=2,a.panose=n.readBytes(r,t,10),t+=10,a.ulUnicodeRange1=n.readUint(r,t),t+=4,a.ulUnicodeRange2=n.readUint(r,t),t+=4,a.ulUnicodeRange3=n.readUint(r,t),t+=4,a.ulUnicodeRange4=n.readUint(r,t),t+=4,a.achVendID=[n.readInt8(r,t),n.readInt8(r,t+1),n.readInt8(r,t+2),n.readInt8(r,t+3)],t+=4,a.fsSelection=n.readUshort(r,t),t+=2,a.usFirstCharIndex=n.readUshort(r,t),t+=2,a.usLastCharIndex=n.readUshort(r,t),t+=2,a.sTypoAscender=n.readShort(r,t),t+=2,a.sTypoDescender=n.readShort(r,t),t+=2,a.sTypoLineGap=n.readShort(r,t),t+=2,a.usWinAscent=n.readUshort(r,t),t+=2,a.usWinDescent=n.readUshort(r,t),t+=2},e[\"OS/2\"].version1=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version0(r,t,a),a.ulCodePageRange1=n.readUint(r,t),t+=4,a.ulCodePageRange2=n.readUint(r,t),t+=4},e[\"OS/2\"].version2=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version1(r,t,a),a.sxHeight=n.readShort(r,t),t+=2,a.sCapHeight=n.readShort(r,t),t+=2,a.usDefault=n.readUshort(r,t),t+=2,a.usBreak=n.readUshort(r,t),t+=2,a.usMaxContext=n.readUshort(r,t),t+=2},e[\"OS/2\"].version5=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version2(r,t,a),a.usLowerOpticalPointSize=n.readUshort(r,t),t+=2,a.usUpperOpticalPointSize=n.readUshort(r,t),t+=2},e.post={},e.post.parse=function(r,t,a){var n=e._bin,o={};return o.version=n.readFixed(r,t),t+=4,o.italicAngle=n.readFixed(r,t),t+=4,o.underlinePosition=n.readShort(r,t),t+=2,o.underlineThickness=n.readShort(r,t),t+=2,o},null==e&&(e={}),null==e.U&&(e.U={}),e.U.codeToGlyph=function(r,e){var t=r.cmap,a=-1;if(null!=t.p0e4?a=t.p0e4:null!=t.p3e1?a=t.p3e1:null!=t.p1e0?a=t.p1e0:null!=t.p0e3&&(a=t.p0e3),-1==a)throw \"no familiar platform and encoding!\";var n=t.tables[a];if(0==n.format)return e>=n.map.length?0:n.map[e];if(4==n.format){for(var o=-1,s=0;s<n.endCount.length;s++)if(e<=n.endCount[s]){o=s;break}if(-1==o)return 0;if(n.startCount[o]>e)return 0;return 65535&(0!=n.idRangeOffset[o]?n.glyphIdArray[e-n.startCount[o]+(n.idRangeOffset[o]>>1)-(n.idRangeOffset.length-o)]:e+n.idDelta[o])}if(12==n.format){if(e>n.groups[n.groups.length-1][1])return 0;for(s=0;s<n.groups.length;s++){var i=n.groups[s];if(i[0]<=e&&e<=i[1])return i[2]+(e-i[0])}return 0}throw \"unknown cmap table format \"+n.format},e.U.glyphToPath=function(r,t){var a={cmds:[],crds:[]};if(r.SVG&&r.SVG.entries[t]){var n=r.SVG.entries[t];return null==n?a:(\"string\"==typeof n&&(n=e.SVG.toPath(n),r.SVG.entries[t]=n),n)}if(r.CFF){var o={x:0,y:0,stack:[],nStems:0,haveWidth:!1,width:r.CFF.Private?r.CFF.Private.defaultWidthX:0,open:!1},s=r.CFF,i=r.CFF.Private;if(s.ROS){for(var h=0;s.FDSelect[h+2]<=t;)h+=2;i=s.FDArray[s.FDSelect[h+1]].Private;}e.U._drawCFF(r.CFF.CharStrings[t],o,s,i,a);}else r.glyf&&e.U._drawGlyf(t,r,a);return a},e.U._drawGlyf=function(r,t,a){var n=t.glyf[r];null==n&&(n=t.glyf[r]=e.glyf._parseGlyf(t,r)),null!=n&&(n.noc>-1?e.U._simpleGlyph(n,a):e.U._compoGlyph(n,t,a));},e.U._simpleGlyph=function(r,t){for(var a=0;a<r.noc;a++){for(var n=0==a?0:r.endPts[a-1]+1,o=r.endPts[a],s=n;s<=o;s++){var i=s==n?o:s-1,h=s==o?n:s+1,d=1&r.flags[s],f=1&r.flags[i],u=1&r.flags[h],l=r.xs[s],v=r.ys[s];if(s==n)if(d){if(!f){e.U.P.moveTo(t,l,v);continue}e.U.P.moveTo(t,r.xs[i],r.ys[i]);}else f?e.U.P.moveTo(t,r.xs[i],r.ys[i]):e.U.P.moveTo(t,(r.xs[i]+l)/2,(r.ys[i]+v)/2);d?f&&e.U.P.lineTo(t,l,v):u?e.U.P.qcurveTo(t,l,v,r.xs[h],r.ys[h]):e.U.P.qcurveTo(t,l,v,(l+r.xs[h])/2,(v+r.ys[h])/2);}e.U.P.closePath(t);}},e.U._compoGlyph=function(r,t,a){for(var n=0;n<r.parts.length;n++){var o={cmds:[],crds:[]},s=r.parts[n];e.U._drawGlyf(s.glyphIndex,t,o);for(var i=s.m,h=0;h<o.crds.length;h+=2){var d=o.crds[h],f=o.crds[h+1];a.crds.push(d*i.a+f*i.b+i.tx),a.crds.push(d*i.c+f*i.d+i.ty);}for(h=0;h<o.cmds.length;h++)a.cmds.push(o.cmds[h]);}},e.U._getGlyphClass=function(r,t){var a=e._lctf.getInterval(t,r);return -1==a?0:t[a+2]},e.U._applySubs=function(r,t,a,n){for(var o=r.length-t-1,s=0;s<a.tabs.length;s++)if(null!=a.tabs[s]){var i,h=a.tabs[s];if(!h.coverage||-1!=(i=e._lctf.coverageIndex(h.coverage,r[t])))if(1==a.ltype)r[t],1==h.fmt?r[t]=r[t]+h.delta:r[t]=h.newg[i];else if(4==a.ltype)for(var d=h.vals[i],f=0;f<d.length;f++){var u=d[f],l=u.chain.length;if(!(l>o)){for(var v=!0,c=0,p=0;p<l;p++){for(;-1==r[t+c+(1+p)];)c++;u.chain[p]!=r[t+c+(1+p)]&&(v=!1);}if(v){r[t]=u.nglyph;for(p=0;p<l+c;p++)r[t+p+1]=-1;break}}}else if(5==a.ltype&&2==h.fmt)for(var U=e._lctf.getInterval(h.cDef,r[t]),g=h.cDef[U+2],S=h.scset[g],m=0;m<S.length;m++){var b=S[m],y=b.input;if(!(y.length>o)){for(v=!0,p=0;p<y.length;p++){var F=e._lctf.getInterval(h.cDef,r[t+1+p]);if(-1==U&&h.cDef[F+2]!=y[p]){v=!1;break}}if(v){var C=b.substLookupRecords;for(f=0;f<C.length;f+=2)C[f],C[f+1];}}}else if(6==a.ltype&&3==h.fmt){if(!e.U._glsCovered(r,h.backCvg,t-h.backCvg.length))continue;if(!e.U._glsCovered(r,h.inptCvg,t))continue;if(!e.U._glsCovered(r,h.ahedCvg,t+h.inptCvg.length))continue;var _=h.lookupRec;for(m=0;m<_.length;m+=2){U=_[m];var P=n[_[m+1]];e.U._applySubs(r,t+U,P,n);}}}},e.U._glsCovered=function(r,t,a){for(var n=0;n<t.length;n++){if(-1==e._lctf.coverageIndex(t[n],r[a+n]))return !1}return !0},e.U.glyphsToPath=function(r,t,a){for(var n={cmds:[],crds:[]},o=0,s=0;s<t.length;s++){var i=t[s];if(-1!=i){for(var h=s<t.length-1&&-1!=t[s+1]?t[s+1]:0,d=e.U.glyphToPath(r,i),f=0;f<d.crds.length;f+=2)n.crds.push(d.crds[f]+o),n.crds.push(d.crds[f+1]);a&&n.cmds.push(a);for(f=0;f<d.cmds.length;f++)n.cmds.push(d.cmds[f]);a&&n.cmds.push(\"X\"),o+=r.hmtx.aWidth[i],s<t.length-1&&(o+=e.U.getPairAdjustment(r,i,h));}}return n},e.U.P={},e.U.P.moveTo=function(r,e,t){r.cmds.push(\"M\"),r.crds.push(e,t);},e.U.P.lineTo=function(r,e,t){r.cmds.push(\"L\"),r.crds.push(e,t);},e.U.P.curveTo=function(r,e,t,a,n,o,s){r.cmds.push(\"C\"),r.crds.push(e,t,a,n,o,s);},e.U.P.qcurveTo=function(r,e,t,a,n){r.cmds.push(\"Q\"),r.crds.push(e,t,a,n);},e.U.P.closePath=function(r){r.cmds.push(\"Z\");},e.U._drawCFF=function(r,t,a,n,o){for(var s=t.stack,i=t.nStems,h=t.haveWidth,d=t.width,f=t.open,u=0,l=t.x,v=t.y,c=0,p=0,U=0,g=0,S=0,m=0,b=0,y=0,F=0,C=0,_={val:0,size:0};u<r.length;){e.CFF.getCharString(r,u,_);var P=_.val;if(u+=_.size,\"o1\"==P||\"o18\"==P)s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;else if(\"o3\"==P||\"o23\"==P){s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;}else if(\"o4\"==P)s.length>1&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),f&&e.U.P.closePath(o),v+=s.pop(),e.U.P.moveTo(o,l,v),f=!0;else if(\"o5\"==P)for(;s.length>0;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);else if(\"o6\"==P||\"o7\"==P)for(var x=s.length,I=\"o6\"==P,w=0;w<x;w++){var k=s.shift();I?l+=k:v+=k,I=!I,e.U.P.lineTo(o,l,v);}else if(\"o8\"==P||\"o24\"==P){x=s.length;for(var G=0;G+6<=x;)c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v),G+=6;\"o24\"==P&&(l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v));}else {if(\"o11\"==P)break;if(\"o1234\"==P||\"o1235\"==P||\"o1236\"==P||\"o1237\"==P)\"o1234\"==P&&(p=v,U=(c=l+s.shift())+s.shift(),C=g=p+s.shift(),m=g,y=v,l=(b=(S=(F=U+s.shift())+s.shift())+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1235\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),C=g+s.shift(),S=F+s.shift(),m=C+s.shift(),b=S+s.shift(),y=m+s.shift(),l=b+s.shift(),v=y+s.shift(),s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1236\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),C=g=p+s.shift(),m=g,b=(S=(F=U+s.shift())+s.shift())+s.shift(),y=m+s.shift(),l=b+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1237\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),C=g+s.shift(),S=F+s.shift(),m=C+s.shift(),b=S+s.shift(),y=m+s.shift(),Math.abs(b-l)>Math.abs(y-v)?l=b+s.shift():v=y+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v));else if(\"o14\"==P){if(s.length>0&&!h&&(d=s.shift()+a.nominalWidthX,h=!0),4==s.length){var O=s.shift(),T=s.shift(),D=s.shift(),B=s.shift(),A=e.CFF.glyphBySE(a,D),R=e.CFF.glyphBySE(a,B);e.U._drawCFF(a.CharStrings[A],t,a,n,o),t.x=O,t.y=T,e.U._drawCFF(a.CharStrings[R],t,a,n,o);}f&&(e.U.P.closePath(o),f=!1);}else if(\"o19\"==P||\"o20\"==P){s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0,u+=i+7>>3;}else if(\"o21\"==P)s.length>2&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),v+=s.pop(),l+=s.pop(),f&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),f=!0;else if(\"o22\"==P)s.length>1&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),l+=s.pop(),f&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),f=!0;else if(\"o25\"==P){for(;s.length>6;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);}else if(\"o26\"==P)for(s.length%2&&(l+=s.shift());s.length>0;)c=l,p=v+s.shift(),l=U=c+s.shift(),v=(g=p+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o27\"==P)for(s.length%2&&(v+=s.shift());s.length>0;)p=v,U=(c=l+s.shift())+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g,e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o10\"==P||\"o29\"==P){var L=\"o10\"==P?n:a;if(0==s.length)console.debug(\"error: empty stack\");else {var W=s.pop(),M=L.Subrs[W+L.Bias];t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=d,t.open=f,e.U._drawCFF(M,t,a,n,o),l=t.x,v=t.y,i=t.nStems,h=t.haveWidth,d=t.width,f=t.open;}}else if(\"o30\"==P||\"o31\"==P){var V=s.length,E=(G=0,\"o31\"==P);for(G+=V-(x=-3&V);G<x;)E?(p=v,U=(c=l+s.shift())+s.shift(),v=(g=p+s.shift())+s.shift(),x-G==5?(l=U+s.shift(),G++):l=U,E=!1):(c=l,p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),x-G==5?(v=g+s.shift(),G++):v=g,E=!0),e.U.P.curveTo(o,c,p,U,g,l,v),G+=4;}else {if(\"o\"==(P+\"\").charAt(0))throw console.debug(\"Unknown operation: \"+P,r),P;s.push(P);}}}t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=d,t.open=f;};var t=e,a={Typr:t};return r.Typr=t,r.default=a,Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).Typr}\n\n/*!\nCustom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate\n(https://github.com/101arrowz/fflate) for use in Troika text rendering. \nOriginal licenses apply: \n- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)\n- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)\n*/\nfunction woff2otfFactory(){return function(r){var e=Uint8Array,n=Uint16Array,t=Uint32Array,a=new e([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new e([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),o=new e([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),f=function(r,e){for(var a=new n(31),i=0;i<31;++i)a[i]=e+=1<<r[i-1];var o=new t(a[30]);for(i=1;i<30;++i)for(var f=a[i];f<a[i+1];++f)o[f]=f-a[i]<<5|i;return [a,o]},u=f(a,2),v=u[0],s=u[1];v[28]=258,s[258]=28;for(var l=f(i,0)[0],c=new n(32768),g=0;g<32768;++g){var h=(43690&g)>>>1|(21845&g)<<1;h=(61680&(h=(52428&h)>>>2|(13107&h)<<2))>>>4|(3855&h)<<4,c[g]=((65280&h)>>>8|(255&h)<<8)>>>1;}var w=function(r,e,t){for(var a=r.length,i=0,o=new n(e);i<a;++i)++o[r[i]-1];var f,u=new n(e);for(i=0;i<e;++i)u[i]=u[i-1]+o[i-1]<<1;if(t){f=new n(1<<e);var v=15-e;for(i=0;i<a;++i)if(r[i])for(var s=i<<4|r[i],l=e-r[i],g=u[r[i]-1]++<<l,h=g|(1<<l)-1;g<=h;++g)f[c[g]>>>v]=s;}else for(f=new n(a),i=0;i<a;++i)r[i]&&(f[i]=c[u[r[i]-1]++]>>>15-r[i]);return f},d=new e(288);for(g=0;g<144;++g)d[g]=8;for(g=144;g<256;++g)d[g]=9;for(g=256;g<280;++g)d[g]=7;for(g=280;g<288;++g)d[g]=8;var m=new e(32);for(g=0;g<32;++g)m[g]=5;var b=w(d,9,1),p=w(m,5,1),y=function(r){for(var e=r[0],n=1;n<r.length;++n)r[n]>e&&(e=r[n]);return e},L=function(r,e,n){var t=e/8|0;return (r[t]|r[t+1]<<8)>>(7&e)&n},U=function(r,e){var n=e/8|0;return (r[n]|r[n+1]<<8|r[n+2]<<16)>>(7&e)},k=[\"unexpected EOF\",\"invalid block type\",\"invalid length/literal\",\"invalid distance\",\"stream finished\",\"no stream handler\",,\"no callback\",\"invalid UTF-8 data\",\"extra field too long\",\"date not in range 1980-2099\",\"filename too long\",\"stream finishing\",\"invalid zip data\"],T=function(r,e,n){var t=new Error(e||k[r]);if(t.code=r,Error.captureStackTrace&&Error.captureStackTrace(t,T),!n)throw t;return t},O=function(r,f,u){var s=r.length;if(!s||u&&!u.l&&s<5)return f||new e(0);var c=!f||u,g=!u||u.i;u||(u={}),f||(f=new e(3*s));var h,d=function(r){var n=f.length;if(r>n){var t=new e(Math.max(2*n,r));t.set(f),f=t;}},m=u.f||0,k=u.p||0,O=u.b||0,A=u.l,x=u.d,E=u.m,D=u.n,M=8*s;do{if(!A){u.f=m=L(r,k,1);var S=L(r,k+1,3);if(k+=3,!S){var V=r[(I=((h=k)/8|0)+(7&h&&1)+4)-4]|r[I-3]<<8,_=I+V;if(_>s){g&&T(0);break}c&&d(O+V),f.set(r.subarray(I,_),O),u.b=O+=V,u.p=k=8*_;continue}if(1==S)A=b,x=p,E=9,D=5;else if(2==S){var j=L(r,k,31)+257,z=L(r,k+10,15)+4,C=j+L(r,k+5,31)+1;k+=14;for(var F=new e(C),P=new e(19),q=0;q<z;++q)P[o[q]]=L(r,k+3*q,7);k+=3*z;var B=y(P),G=(1<<B)-1,H=w(P,B,1);for(q=0;q<C;){var I,J=H[L(r,k,G)];if(k+=15&J,(I=J>>>4)<16)F[q++]=I;else {var K=0,N=0;for(16==I?(N=3+L(r,k,3),k+=2,K=F[q-1]):17==I?(N=3+L(r,k,7),k+=3):18==I&&(N=11+L(r,k,127),k+=7);N--;)F[q++]=K;}}var Q=F.subarray(0,j),R=F.subarray(j);E=y(Q),D=y(R),A=w(Q,E,1),x=w(R,D,1);}else T(1);if(k>M){g&&T(0);break}}c&&d(O+131072);for(var W=(1<<E)-1,X=(1<<D)-1,Y=k;;Y=k){var Z=(K=A[U(r,k)&W])>>>4;if((k+=15&K)>M){g&&T(0);break}if(K||T(2),Z<256)f[O++]=Z;else {if(256==Z){Y=k,A=null;break}var $=Z-254;if(Z>264){var rr=a[q=Z-257];$=L(r,k,(1<<rr)-1)+v[q],k+=rr;}var er=x[U(r,k)&X],nr=er>>>4;er||T(3),k+=15&er;R=l[nr];if(nr>3){rr=i[nr];R+=U(r,k)&(1<<rr)-1,k+=rr;}if(k>M){g&&T(0);break}c&&d(O+131072);for(var tr=O+$;O<tr;O+=4)f[O]=f[O-R],f[O+1]=f[O+1-R],f[O+2]=f[O+2-R],f[O+3]=f[O+3-R];O=tr;}}u.l=A,u.p=Y,u.b=O,A&&(m=1,u.m=E,u.d=x,u.n=D);}while(!m);return O==f.length?f:function(r,a,i){(null==a||a<0)&&(a=0),(null==i||i>r.length)&&(i=r.length);var o=new(r instanceof n?n:r instanceof t?t:e)(i-a);return o.set(r.subarray(a,i)),o}(f,0,O)},A=new e(0);var x=\"undefined\"!=typeof TextDecoder&&new TextDecoder;try{x.decode(A,{stream:!0}),1;}catch(r){}return r.convert_streams=function(r){var e=new DataView(r),n=0;function t(){var r=e.getUint16(n);return n+=2,r}function a(){var r=e.getUint32(n);return n+=4,r}function i(r){m.setUint16(b,r),b+=2;}function o(r){m.setUint32(b,r),b+=4;}for(var f={signature:a(),flavor:a(),length:a(),numTables:t(),reserved:t(),totalSfntSize:a(),majorVersion:t(),minorVersion:t(),metaOffset:a(),metaLength:a(),metaOrigLength:a(),privOffset:a(),privLength:a()},u=0;Math.pow(2,u)<=f.numTables;)u++;u--;for(var v=16*Math.pow(2,u),s=16*f.numTables-v,l=12,c=[],g=0;g<f.numTables;g++)c.push({tag:a(),offset:a(),compLength:a(),origLength:a(),origChecksum:a()}),l+=16;var h,w=new Uint8Array(12+16*c.length+c.reduce((function(r,e){return r+e.origLength+4}),0)),d=w.buffer,m=new DataView(d),b=0;return o(f.flavor),i(f.numTables),i(v),i(u),i(s),c.forEach((function(r){o(r.tag),o(r.origChecksum),o(l),o(r.origLength),r.outOffset=l,(l+=r.origLength)%4!=0&&(l+=4-l%4);})),c.forEach((function(e){var n,t=r.slice(e.offset,e.offset+e.compLength);if(e.compLength!=e.origLength){var a=new Uint8Array(e.origLength);n=new Uint8Array(t,2),O(n,a);}else a=new Uint8Array(t);w.set(a,e.outOffset);var i=0;(l=e.outOffset+e.origLength)%4!=0&&(i=4-l%4),w.set(new Uint8Array(i).buffer,e.outOffset+e.origLength),h=l+i;})),d.slice(0,h)},Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).convert_streams}\n\n/**\n * A factory wrapper parsing a font file using Typr.\n * Also adds support for WOFF files (not WOFF2).\n */\n\n/**\n * @typedef ParsedFont\n * @property {number} ascender\n * @property {number} descender\n * @property {number} xHeight\n * @property {(number) => boolean} supportsCodePoint\n * @property {(text:string, fontSize:number, letterSpacing:number, callback) => number} forEachGlyph\n * @property {number} lineGap\n * @property {number} capHeight\n * @property {number} unitsPerEm\n */\n\n/**\n * @typedef {(buffer: ArrayBuffer) => ParsedFont} FontParser\n */\n\n/**\n * @returns {FontParser}\n */\nfunction parserFactory(Typr, woff2otf) {\n  const cmdArgLengths = {\n    M: 2,\n    L: 2,\n    Q: 4,\n    C: 6,\n    Z: 0\n  };\n\n  // {joinType: \"skip+step,...\"}\n  const joiningTypeRawData = {\"C\":\"18g,ca,368,1kz\",\"D\":\"17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v\",\"R\":\"17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6\",\"L\":\"x9u,jff,a,fd,jv\",\"T\":\"4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n\"};\n\n  const JT_LEFT = 1, //indicates that a character joins with the subsequent character, but does not join with the preceding character.\n    JT_RIGHT = 2, //indicates that a character joins with the preceding character, but does not join with the subsequent character.\n    JT_DUAL = 4, //indicates that a character joins with the preceding character and joins with the subsequent character.\n    JT_TRANSPARENT = 8, //indicates that the character does not join with adjacent characters and that the character must be skipped over when the shaping engine is evaluating the joining positions in a sequence of characters. When a JT_TRANSPARENT character is encountered in a sequence, the JOINING_TYPE of the preceding character passes through. Diacritical marks are frequently assigned this value.\n    JT_JOIN_CAUSING = 16, //indicates that the character forces the use of joining forms with the preceding and subsequent characters. Kashidas and the Zero Width Joiner (U+200D) are both JOIN_CAUSING characters.\n    JT_NON_JOINING = 32; //indicates that a character does not join with the preceding or with the subsequent character.,\n\n  let joiningTypeMap;\n  function getCharJoiningType(ch) {\n    if (!joiningTypeMap) {\n      const m = {\n        R: JT_RIGHT,\n        L: JT_LEFT,\n        D: JT_DUAL,\n        C: JT_JOIN_CAUSING,\n        U: JT_NON_JOINING,\n        T: JT_TRANSPARENT\n      };\n      joiningTypeMap = new Map();\n      for (let type in joiningTypeRawData) {\n        let lastCode = 0;\n        joiningTypeRawData[type].split(',').forEach(range => {\n          let [skip, step] = range.split('+');\n          skip = parseInt(skip,36);\n          step = step ? parseInt(step, 36) : 0;\n          joiningTypeMap.set(lastCode += skip, m[type]);\n          for (let i = step; i--;) {\n            joiningTypeMap.set(++lastCode, m[type]);\n          }\n        });\n      }\n    }\n    return joiningTypeMap.get(ch) || JT_NON_JOINING\n  }\n\n  const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;\n  const formsToFeatures = [null, 'isol', 'init', 'fina', 'medi'];\n\n  function detectJoiningForms(str) {\n    // This implements the algorithm described here:\n    // https://github.com/n8willis/opentype-shaping-documents/blob/master/opentype-shaping-arabic-general.md\n    const joiningForms = new Uint8Array(str.length);\n    let prevJoiningType = JT_NON_JOINING;\n    let prevForm = ISOL;\n    let prevIndex = -1;\n    for (let i = 0; i < str.length; i++) {\n      const code = str.codePointAt(i);\n      let joiningType = getCharJoiningType(code) | 0;\n      let form = ISOL;\n      if (joiningType & JT_TRANSPARENT) {\n        continue\n      }\n      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {\n        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {\n          form = FINA;\n          // isol->init, fina->medi\n          if (prevForm === ISOL || prevForm === FINA) {\n            joiningForms[prevIndex]++;\n          }\n        }\n        else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {\n          // medi->fina, init->isol\n          if (prevForm === INIT || prevForm === MEDI) {\n            joiningForms[prevIndex]--;\n          }\n        }\n      }\n      else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {\n        // medi->fina, init->isol\n        if (prevForm === INIT || prevForm === MEDI) {\n          joiningForms[prevIndex]--;\n        }\n      }\n      prevForm = joiningForms[i] = form;\n      prevJoiningType = joiningType;\n      prevIndex = i;\n      if (code > 0xffff) i++;\n    }\n    // console.log(str.split('').map(ch => ch.codePointAt(0).toString(16)))\n    // console.log(str.split('').map(ch => getCharJoiningType(ch.codePointAt(0))))\n    // console.log(Array.from(joiningForms).map(f => formsToFeatures[f] || 'none'))\n    return joiningForms\n  }\n\n  function stringToGlyphs (font, str) {\n    const glyphIds = [];\n    for (let i = 0; i < str.length; i++) {\n      const cc = str.codePointAt(i);\n      if (cc > 0xffff) i++;\n      glyphIds.push(Typr.U.codeToGlyph(font, cc));\n    }\n\n    const gsub = font['GSUB'];\n    if (gsub) {\n      const {lookupList, featureList} = gsub;\n      let joiningForms;\n      const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/;\n      const usedLookups = [];\n      featureList.forEach(feature => {\n        if (supportedFeatures.test(feature.tag)) {\n          for (let ti = 0; ti < feature.tab.length; ti++) {\n            if (usedLookups[feature.tab[ti]]) continue\n            usedLookups[feature.tab[ti]] = true;\n            const tab = lookupList[feature.tab[ti]];\n            const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);\n            if (isJoiningFeature && !joiningForms) { //lazy\n              joiningForms = detectJoiningForms(str);\n            }\n            for (let ci = 0; ci < glyphIds.length; ci++) {\n              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {\n                Typr.U._applySubs(glyphIds, ci, tab, lookupList);\n              }\n            }\n          }\n        }\n      });\n    }\n\n    return glyphIds\n  }\n\n  // Calculate advances and x/y offsets for each glyph, e.g. kerning and mark\n  // attachments. This is a more complete version of Typr.U.getPairAdjustment\n  // and should become an upstream replacement eventually.\n  function calcGlyphPositions(font, glyphIds) {\n    const positions = new Int16Array(glyphIds.length * 3); // [offsetX, offsetY, advanceX, ...]\n    let glyphIndex = 0;\n    for (; glyphIndex < glyphIds.length; glyphIndex++) {\n      const glyphId = glyphIds[glyphIndex];\n      if (glyphId === -1) continue;\n\n      positions[glyphIndex * 3 + 2] = font.hmtx.aWidth[glyphId]; // populate advanceX in...advance.\n\n      const gpos = font.GPOS;\n      if (gpos) {\n        const llist = gpos.lookupList;\n        for (let i = 0; i < llist.length; i++) {\n          const lookup = llist[i];\n          for (let j = 0; j < lookup.tabs.length; j++) {\n            const tab = lookup.tabs[j];\n            // Single char placement\n            if (lookup.ltype === 1) {\n              const ind = Typr._lctf.coverageIndex(tab.coverage, glyphId);\n              if (ind !== -1 && tab.pos) {\n                applyValueRecord(tab.pos, glyphIndex);\n                break\n              }\n            }\n            // Pairs (kerning)\n            else if (lookup.ltype === 2) {\n              let adj = null;\n              let prevGlyphIndex = getPrevGlyphIndex();\n              if (prevGlyphIndex !== -1) {\n                const coverageIndex = Typr._lctf.coverageIndex(tab.coverage, glyphIds[prevGlyphIndex]);\n                if (coverageIndex !== -1) {\n                  if (tab.fmt === 1) {\n                    const right = tab.pairsets[coverageIndex];\n                    for (let k = 0; k < right.length; k++) {\n                      if (right[k].gid2 === glyphId) adj = right[k];\n                    }\n                  } else if (tab.fmt === 2) {\n                    const c1 = Typr.U._getGlyphClass(glyphIds[prevGlyphIndex], tab.classDef1);\n                    const c2 = Typr.U._getGlyphClass(glyphId, tab.classDef2);\n                    adj = tab.matrix[c1][c2];\n                  }\n                  if (adj) {\n                    if (adj.val1) applyValueRecord(adj.val1, prevGlyphIndex);\n                    if (adj.val2) applyValueRecord(adj.val2, glyphIndex);\n                    break\n                  }\n                }\n              }\n            }\n            // Mark to base\n            else if (lookup.ltype === 4) {\n              const markArrIndex = Typr._lctf.coverageIndex(tab.markCoverage, glyphId);\n              if (markArrIndex !== -1) {\n                const baseGlyphIndex = getPrevGlyphIndex(isBaseGlyph);\n                const baseArrIndex = baseGlyphIndex === -1 ? -1 : Typr._lctf.coverageIndex(tab.baseCoverage, glyphIds[baseGlyphIndex]);\n                if (baseArrIndex !== -1) {\n                  const markRecord = tab.markArray[markArrIndex];\n                  const baseAnchor = tab.baseArray[baseArrIndex][markRecord.markClass];\n                  positions[glyphIndex * 3] = baseAnchor.x - markRecord.x + positions[baseGlyphIndex * 3] - positions[baseGlyphIndex * 3 + 2];\n                  positions[glyphIndex * 3 + 1] = baseAnchor.y - markRecord.y + positions[baseGlyphIndex * 3 + 1];\n                  break;\n                }\n              }\n            }\n            // Mark to mark\n            else if (lookup.ltype === 6) {\n              const mark1ArrIndex = Typr._lctf.coverageIndex(tab.mark1Coverage, glyphId);\n              if (mark1ArrIndex !== -1) {\n                const prevGlyphIndex = getPrevGlyphIndex();\n                if (prevGlyphIndex !== -1) {\n                  const prevGlyphId = glyphIds[prevGlyphIndex];\n                  if (getGlyphClass(font, prevGlyphId) === 3) { // only check mark glyphs\n                    const mark2ArrIndex = Typr._lctf.coverageIndex(tab.mark2Coverage, prevGlyphId);\n                    if (mark2ArrIndex !== -1) {\n                      const mark1Record = tab.mark1Array[mark1ArrIndex];\n                      const mark2Anchor = tab.mark2Array[mark2ArrIndex][mark1Record.markClass];\n                      positions[glyphIndex * 3] = mark2Anchor.x - mark1Record.x + positions[prevGlyphIndex * 3] - positions[prevGlyphIndex * 3 + 2];\n                      positions[glyphIndex * 3 + 1] = mark2Anchor.y - mark1Record.y + positions[prevGlyphIndex * 3 + 1];\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      // Check kern table if no GPOS\n      else if (font.kern && !font.cff) {\n        const prevGlyphIndex = getPrevGlyphIndex();\n        if (prevGlyphIndex !== -1) {\n          const ind1 = font.kern.glyph1.indexOf(glyphIds[prevGlyphIndex]);\n          if (ind1 !== -1) {\n            const ind2 = font.kern.rval[ind1].glyph2.indexOf(glyphId);\n            if (ind2 !== -1) {\n              positions[prevGlyphIndex * 3 + 2] += font.kern.rval[ind1].vals[ind2];\n            }\n          }\n        }\n      }\n    }\n\n    return positions;\n\n    function getPrevGlyphIndex(filter) {\n      for (let i = glyphIndex - 1; i >=0; i--) {\n        if (glyphIds[i] !== -1 && (!filter || filter(glyphIds[i]))) {\n          return i\n        }\n      }\n      return -1;\n    }\n\n    function isBaseGlyph(glyphId) {\n      return getGlyphClass(font, glyphId) === 1;\n    }\n\n    function applyValueRecord(source, gi) {\n      for (let i = 0; i < 3; i++) {\n        positions[gi * 3 + i] += source[i] || 0;\n      }\n    }\n  }\n\n  function getGlyphClass(font, glyphId) {\n    const classDef = font.GDEF && font.GDEF.glyphClassDef;\n    return classDef ? Typr.U._getGlyphClass(glyphId, classDef) : 0;\n  }\n\n  function firstNum(...args) {\n    for (let i = 0; i < args.length; i++) {\n      if (typeof args[i] === 'number') {\n        return args[i]\n      }\n    }\n  }\n\n  /**\n   * @returns ParsedFont\n   */\n  function wrapFontObj(typrFont) {\n    const glyphMap = Object.create(null);\n\n    const os2 = typrFont['OS/2'];\n    const hhea = typrFont.hhea;\n    const unitsPerEm = typrFont.head.unitsPerEm;\n    const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);\n\n    /** @type ParsedFont */\n    const fontObj = {\n      unitsPerEm,\n      ascender,\n      descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),\n      capHeight: firstNum(os2 && os2.sCapHeight, ascender),\n      xHeight: firstNum(os2 && os2.sxHeight, ascender),\n      lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),\n      supportsCodePoint(code) {\n        return Typr.U.codeToGlyph(typrFont, code) > 0\n      },\n      forEachGlyph(text, fontSize, letterSpacing, callback) {\n        let penX = 0;\n        const fontScale = 1 / fontObj.unitsPerEm * fontSize;\n\n        const glyphIds = stringToGlyphs(typrFont, text);\n        let charIndex = 0;\n        const positions = calcGlyphPositions(typrFont, glyphIds);\n\n        glyphIds.forEach((glyphId, i) => {\n          // Typr returns a glyph index per string codepoint, with -1s in place of those that\n          // were omitted due to ligature substitution. So we can track original index in the\n          // string via simple increment, and skip everything else when seeing a -1.\n          if (glyphId !== -1) {\n            let glyphObj = glyphMap[glyphId];\n            if (!glyphObj) {\n              const {cmds, crds} = Typr.U.glyphToPath(typrFont, glyphId);\n\n              // Build path string\n              let path = '';\n              let crdsIdx = 0;\n              for (let i = 0, len = cmds.length; i < len; i++) {\n                const numArgs = cmdArgLengths[cmds[i]];\n                path += cmds[i];\n                for (let j = 1; j <= numArgs; j++) {\n                  path += (j > 1 ? ',' : '') + crds[crdsIdx++];\n                }\n              }\n\n              // Find extents - Glyf gives this in metadata but not CFF, and Typr doesn't\n              // normalize the two, so it's simplest just to iterate ourselves.\n              let xMin, yMin, xMax, yMax;\n              if (crds.length) {\n                xMin = yMin = Infinity;\n                xMax = yMax = -Infinity;\n                for (let i = 0, len = crds.length; i < len; i += 2) {\n                  let x = crds[i];\n                  let y = crds[i + 1];\n                  if (x < xMin) xMin = x;\n                  if (y < yMin) yMin = y;\n                  if (x > xMax) xMax = x;\n                  if (y > yMax) yMax = y;\n                }\n              } else {\n                xMin = xMax = yMin = yMax = 0;\n              }\n\n              glyphObj = glyphMap[glyphId] = {\n                index: glyphId,\n                advanceWidth: typrFont.hmtx.aWidth[glyphId],\n                xMin,\n                yMin,\n                xMax,\n                yMax,\n                path,\n              };\n            }\n\n            callback.call(\n              null,\n              glyphObj,\n              penX + positions[i * 3] * fontScale,\n              positions[i * 3 + 1] * fontScale,\n              charIndex\n            );\n\n            penX += positions[i * 3 + 2] * fontScale;\n            if (letterSpacing) {\n              penX += letterSpacing * fontSize;\n            }\n          }\n          charIndex += (text.codePointAt(charIndex) > 0xffff ? 2 : 1);\n        });\n\n        return penX\n      }\n    };\n\n    return fontObj\n  }\n\n  /**\n   * @type FontParser\n   */\n  return function parse(buffer) {\n    // Look to see if we have a WOFF file and convert it if so:\n    const peek = new Uint8Array(buffer, 0, 4);\n    const tag = Typr._bin.readASCII(peek, 0, 4);\n    if (tag === 'wOFF') {\n      buffer = woff2otf(buffer);\n    } else if (tag === 'wOF2') {\n      throw new Error('woff2 fonts not supported')\n    }\n    return wrapFontObj(Typr.parse(buffer)[0])\n  }\n}\n\n\nconst workerModule = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'Typr Font Parser',\n  dependencies: [typrFactory, woff2otfFactory, parserFactory],\n  init(typrFactory, woff2otfFactory, parserFactory) {\n    const Typr = typrFactory();\n    const woff2otf = woff2otfFactory();\n    return parserFactory(Typr, woff2otf)\n  }\n});\n\n/*!\nCustom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)\nfor use in Troika text rendering. \nOriginal MIT license applies\n*/\nfunction unicodeFontResolverClientFactory(){return function(t){var n=function(){this.buckets=new Map;};n.prototype.add=function(t){var n=t>>5;this.buckets.set(n,(this.buckets.get(n)||0)|1<<(31&t));},n.prototype.has=function(t){var n=this.buckets.get(t>>5);return void 0!==n&&0!=(n&1<<(31&t))},n.prototype.serialize=function(){var t=[];return this.buckets.forEach((function(n,r){t.push((+r).toString(36)+\":\"+n.toString(36));})),t.join(\",\")},n.prototype.deserialize=function(t){var n=this;this.buckets.clear(),t.split(\",\").forEach((function(t){var r=t.split(\":\");n.buckets.set(parseInt(r[0],36),parseInt(r[1],36));}));};var r=Math.pow(2,8),e=r-1,o=~e;function a(t){var n=function(t){return t&o}(t).toString(16),e=function(t){return (t&o)+r-1}(t).toString(16);return \"codepoint-index/plane\"+(t>>16)+\"/\"+n+\"-\"+e+\".json\"}function i(t,n){var r=t&e,o=n.codePointAt(r/6|0);return 0!=((o=(o||48)-48)&1<<r%6)}function u(t,n){var r;(r=t,r.replace(/U\\+/gi,\"\").replace(/^,+|,+$/g,\"\").split(/,+/).map((function(t){return t.split(\"-\").map((function(t){return parseInt(t.trim(),16)}))}))).forEach((function(t){var r=t[0],e=t[1];void 0===e&&(e=r),n(r,e);}));}function c(t,n){u(t,(function(t,r){for(var e=t;e<=r;e++)n(e);}));}var s={},f={},l=new WeakMap,v=\"https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data\";function d(t){var r=l.get(t);return r||(r=new n,c(t.ranges,(function(t){return r.add(t)})),l.set(t,r)),r}var h,p=new Map;function g(t,n,r){return t[n]?n:t[r]?r:function(t){for(var n in t)return n}(t)}function w(t,n){var r=n;if(!t.includes(r)){r=1/0;for(var e=0;e<t.length;e++)Math.abs(t[e]-n)<Math.abs(r-n)&&(r=t[e]);}return r}function k(t){return h||(h=new Set,c(\"9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000\",(function(t){h.add(t);}))),h.has(t)}return t.CodePointSet=n,t.clearCache=function(){s={},f={};},t.getFontsForString=function(t,n){void 0===n&&(n={});var r,e=n.lang;void 0===e&&(e=/\\p{Script=Hangul}/u.test(r=t)?\"ko\":/\\p{Script=Hiragana}|\\p{Script=Katakana}/u.test(r)?\"ja\":\"en\");var o=n.category;void 0===o&&(o=\"sans-serif\");var u=n.style;void 0===u&&(u=\"normal\");var c=n.weight;void 0===c&&(c=400);var l=(n.dataUrl||v).replace(/\\/$/g,\"\"),h=new Map,y=new Uint8Array(t.length),b={},m={},A=new Array(t.length),S=new Map,j=!1;function M(t){var n=p.get(t);return n||(n=fetch(l+\"/\"+t).then((function(t){if(!t.ok)throw new Error(t.statusText);return t.json().then((function(t){if(!Array.isArray(t)||1!==t[0])throw new Error(\"Incorrect schema version; need 1, got \"+t[0]);return t[1]}))})).catch((function(n){if(l!==v)return j||(console.error('unicode-font-resolver: Failed loading from dataUrl \"'+l+'\", trying default CDN. '+n.message),j=!0),l=v,p.delete(t),M(t);throw n})),p.set(t,n)),n}for(var P=function(n){var r=t.codePointAt(n),e=a(r);A[n]=e,s[e]||S.has(e)||S.set(e,M(e).then((function(t){s[e]=t;}))),r>65535&&(n++,E=n);},E=0;E<t.length;E++)P(E);return Promise.all(S.values()).then((function(){S.clear();for(var n=function(n){var o=t.codePointAt(n),a=null,u=s[A[n]],c=void 0;for(var l in u){var v=m[l];if(void 0===v&&(v=m[l]=new RegExp(l).test(e||\"en\")),v){for(var d in c=l,u[l])if(i(o,u[l][d])){a=d;break}break}}if(!a)t:for(var h in u)if(h!==c)for(var p in u[h])if(i(o,u[h][p])){a=p;break t}a||(console.debug(\"No font coverage for U+\"+o.toString(16)),a=\"latin\"),A[n]=a,f[a]||S.has(a)||S.set(a,M(\"font-meta/\"+a+\".json\").then((function(t){f[a]=t;}))),o>65535&&(n++,r=n);},r=0;r<t.length;r++)n(r);return Promise.all(S.values())})).then((function(){for(var n,r=null,e=0;e<t.length;e++){var a=t.codePointAt(e);if(r&&(k(a)||d(r).has(a)))y[e]=y[e-1];else {r=f[A[e]];var i=b[r.id];if(!i){var s=r.typeforms,v=g(s,o,\"sans-serif\"),p=g(s[v],u,\"normal\"),m=w(null===(n=s[v])||void 0===n?void 0:n[p],c);i=b[r.id]=l+\"/font-files/\"+r.id+\"/\"+v+\".\"+p+\".\"+m+\".woff\";}var S=h.get(i);null==S&&(S=h.size,h.set(i,S)),y[e]=S;}a>65535&&(e++,y[e]=y[e-1]);}return {fontUrls:Array.from(h.keys()),chars:y}}))},Object.defineProperty(t,\"__esModule\",{value:!0}),t}({})}\n\n/**\n * @typedef {string | {src:string, label?:string, unicodeRange?:string, lang?:string}} UserFont\n */\n\n/**\n * @typedef {ClientOptions} FontResolverOptions\n * @property {Array<UserFont>|UserFont} [fonts]\n * @property {'normal'|'italic'} [style]\n * @property {'normal'|'bold'|number} [style]\n * @property {string} [unicodeFontsURL]\n */\n\n/**\n * @typedef {Object} FontResolverResult\n * @property {Uint8Array} chars\n * @property {Array<ParsedFont & {src:string}>} fonts\n */\n\n/**\n * @typedef {function} FontResolver\n * @param {string} text\n * @param {(FontResolverResult) => void} callback\n * @param {FontResolverOptions} [options]\n */\n\n/**\n * Factory for the FontResolver function.\n * @param {FontParser} fontParser\n * @param {{getFontsForString: function, CodePointSet: function}} unicodeFontResolverClient\n * @return {FontResolver}\n */\nfunction createFontResolver(fontParser, unicodeFontResolverClient) {\n  /**\n   * @type {Record<string, ParsedFont>}\n   */\n  const parsedFonts = Object.create(null);\n\n  /**\n   * @type {Record<string, Array<(ParsedFont) => void>>}\n   */\n  const loadingFonts = Object.create(null);\n\n  /**\n   * Load a given font url\n   */\n  function doLoadFont(url, callback) {\n    const onError = err => {\n      console.error(`Failure loading font ${url}`, err);\n    };\n    try {\n      const request = new XMLHttpRequest();\n      request.open('get', url, true);\n      request.responseType = 'arraybuffer';\n      request.onload = function () {\n        if (request.status >= 400) {\n          onError(new Error(request.statusText));\n        }\n        else if (request.status > 0) {\n          try {\n            const fontObj = fontParser(request.response);\n            fontObj.src = url;\n            callback(fontObj);\n          } catch (e) {\n            onError(e);\n          }\n        }\n      };\n      request.onerror = onError;\n      request.send();\n    } catch(err) {\n      onError(err);\n    }\n  }\n\n\n  /**\n   * Load a given font url if needed, invoking a callback when it's loaded. If already\n   * loaded, the callback will be called synchronously.\n   * @param {string} fontUrl\n   * @param {(font: ParsedFont) => void} callback\n   */\n  function loadFont(fontUrl, callback) {\n    let font = parsedFonts[fontUrl];\n    if (font) {\n      callback(font);\n    } else if (loadingFonts[fontUrl]) {\n      loadingFonts[fontUrl].push(callback);\n    } else {\n      loadingFonts[fontUrl] = [callback];\n      doLoadFont(fontUrl, fontObj => {\n        fontObj.src = fontUrl;\n        parsedFonts[fontUrl] = fontObj;\n        loadingFonts[fontUrl].forEach(cb => cb(fontObj));\n        delete loadingFonts[fontUrl];\n      });\n    }\n  }\n\n  /**\n   * For a given string of text, determine which fonts are required to fully render it and\n   * ensure those fonts are loaded.\n   */\n  return function (text, callback, {\n    lang,\n    fonts: userFonts = [],\n    style = 'normal',\n    weight = 'normal',\n    unicodeFontsURL\n  } = {}) {\n    const charResolutions = new Uint8Array(text.length);\n    const fontResolutions = [];\n    if (!text.length) {\n      allDone();\n    }\n\n    const fontIndices = new Map();\n    const fallbackRanges = []; // [[start, end], ...]\n\n    if (style !== 'italic') style = 'normal';\n    if (typeof weight !== 'number') {\n      weight = weight === 'bold' ? 700 : 400;\n    }\n\n    if (userFonts && !Array.isArray(userFonts)) {\n      userFonts = [userFonts];\n    }\n    userFonts = userFonts.slice()\n      // filter by language\n      .filter(def => !def.lang || def.lang.test(lang))\n      // switch order for easier iteration\n      .reverse();\n    if (userFonts.length) {\n      const UNKNOWN = 0;\n      const RESOLVED = 1;\n      const NEEDS_FALLBACK = 2;\n      let prevCharResult = UNKNOWN\n\n      ;(function resolveUserFonts (startIndex = 0) {\n        for (let i = startIndex, iLen = text.length; i < iLen; i++) {\n          const codePoint = text.codePointAt(i);\n          // Carry previous character's result forward if:\n          // - it resolved to a font that also covers this character\n          // - this character is whitespace\n          if (\n            (prevCharResult === RESOLVED && fontResolutions[charResolutions[i - 1]].supportsCodePoint(codePoint)) ||\n            /\\s/.test(text[i])\n          ) {\n            charResolutions[i] = charResolutions[i - 1];\n            if (prevCharResult === NEEDS_FALLBACK) {\n              fallbackRanges[fallbackRanges.length - 1][1] = i;\n            }\n          }  else {\n            for (let j = charResolutions[i], jLen = userFonts.length; j <= jLen; j++) {\n              if (j === jLen) {\n                // none of the user fonts matched; needs fallback\n                const range = prevCharResult === NEEDS_FALLBACK ?\n                  fallbackRanges[fallbackRanges.length - 1] :\n                  (fallbackRanges[fallbackRanges.length] = [i, i]);\n                range[1] = i;\n                prevCharResult = NEEDS_FALLBACK;\n              } else {\n                charResolutions[i] = j;\n                const { src, unicodeRange } = userFonts[j];\n                // filter by optional explicit unicode ranges\n                if (!unicodeRange || isCodeInRanges(codePoint, unicodeRange)) {\n                  const fontObj = parsedFonts[src];\n                  // font not yet loaded, load it and resume\n                  if (!fontObj) {\n                    loadFont(src, () => {\n                      resolveUserFonts(i);\n                    });\n                    return;\n                  }\n                  // if the font actually contains a glyph for this char, lock it in\n                  if (fontObj.supportsCodePoint(codePoint)) {\n                    let fontIndex = fontIndices.get(fontObj);\n                    if (typeof fontIndex !== 'number') {\n                      fontIndex = fontResolutions.length;\n                      fontResolutions.push(fontObj);\n                      fontIndices.set(fontObj, fontIndex);\n                    }\n                    charResolutions[i] = fontIndex;\n                    prevCharResult = RESOLVED;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n\n          if (codePoint > 0xffff && i + 1 < iLen) {\n            charResolutions[i + 1] = charResolutions[i];\n            i++;\n            if (prevCharResult === NEEDS_FALLBACK) {\n              fallbackRanges[fallbackRanges.length - 1][1] = i;\n            }\n          }\n        }\n        resolveFallbacks();\n      })();\n    } else {\n      fallbackRanges.push([0, text.length - 1]);\n      resolveFallbacks();\n    }\n\n    function resolveFallbacks() {\n      if (fallbackRanges.length) {\n        // Combine all fallback substrings into a single string for querying\n        const fallbackString = fallbackRanges.map(range => text.substring(range[0], range[1] + 1)).join('\\n');\n        unicodeFontResolverClient.getFontsForString(fallbackString, {\n          lang: lang || undefined,\n          style,\n          weight,\n          dataUrl: unicodeFontsURL\n        }).then(({fontUrls, chars}) => {\n          // Extract results and put them back in the main array\n          const fontIndexOffset = fontResolutions.length;\n          let charIdx = 0;\n          fallbackRanges.forEach(range => {\n            for (let i = 0, endIdx = range[1] - range[0]; i <= endIdx; i++) {\n              charResolutions[range[0] + i] = chars[charIdx++] + fontIndexOffset;\n            }\n            charIdx++; //skip segment separator\n          });\n\n          // Load and parse the fallback fonts - avoiding Promise here to prevent polyfills in the worker\n          let loadedCount = 0;\n          fontUrls.forEach((url, i) => {\n            loadFont(url, fontObj => {\n              fontResolutions[i + fontIndexOffset] = fontObj;\n              if (++loadedCount === fontUrls.length) {\n                allDone();\n              }\n            });\n          });\n        });\n      } else {\n        allDone();\n      }\n    }\n\n    function allDone() {\n      callback({\n        chars: charResolutions,\n        fonts: fontResolutions\n      });\n    }\n\n    function isCodeInRanges(code, ranges) {\n      // todo optimize search - CodePointSet from unicode-font-resolver?\n      for (let k = 0; k < ranges.length; k++) {\n        const [start, end = start] = ranges[k];\n        if (start <= code && code <= end) {\n          return true\n        }\n      }\n      return false\n    }\n  }\n}\n\nconst fontResolverWorkerModule = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'FontResolver',\n  dependencies: [\n    createFontResolver,\n    workerModule,\n    unicodeFontResolverClientFactory,\n  ],\n  init(createFontResolver, fontParser, unicodeFontResolverClientFactory) {\n    return createFontResolver(fontParser, unicodeFontResolverClientFactory());\n  }\n});\n\n/**\n * @typedef {number|'left'|'center'|'right'} AnchorXValue\n */\n/**\n * @typedef {number|'top'|'top-baseline'|'top-cap'|'top-ex'|'middle'|'bottom-baseline'|'bottom'} AnchorYValue\n */\n\n/**\n * @typedef {object} TypesetParams\n * @property {string} text\n * @property {UserFont|UserFont[]} [font]\n * @property {string} [lang]\n * @property {number} [sdfGlyphSize=64]\n * @property {number} [fontSize=1]\n * @property {number|'normal'|'bold'} [fontWeight='normal']\n * @property {'normal'|'italic'} [fontStyle='normal']\n * @property {number} [letterSpacing=0]\n * @property {'normal'|number} [lineHeight='normal']\n * @property {number} [maxWidth]\n * @property {'ltr'|'rtl'} [direction='ltr']\n * @property {string} [textAlign='left']\n * @property {number} [textIndent=0]\n * @property {'normal'|'nowrap'} [whiteSpace='normal']\n * @property {'normal'|'break-word'} [overflowWrap='normal']\n * @property {AnchorXValue} [anchorX=0]\n * @property {AnchorYValue} [anchorY=0]\n * @property {boolean} [metricsOnly=false]\n * @property {string} [unicodeFontsURL]\n * @property {FontResolverResult} [preResolvedFonts]\n * @property {boolean} [includeCaretPositions=false]\n * @property {number} [chunkedBoundsSize=8192]\n * @property {{[rangeStartIndex]: number}} [colorRanges]\n */\n\n/**\n * @typedef {object} TypesetResult\n * @property {Uint16Array} glyphIds id for each glyph, specific to that glyph's font\n * @property {Uint8Array} glyphFontIndices index into fontData for each glyph\n * @property {Float32Array} glyphPositions x,y of each glyph's origin in layout\n * @property {{[font]: {[glyphId]: {path: string, pathBounds: number[]}}}} glyphData data about each glyph appearing in the text\n * @property {TypesetFontData[]} fontData data about each font used in the text\n * @property {Float32Array} [caretPositions] startX,endX,bottomY caret positions for each char\n * @property {Uint8Array} [glyphColors] color for each glyph, if color ranges supplied\n *         chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs\n *         fontSize, //calculated em height\n *         topBaseline: anchorYOffset + lines[0].baseline, //y coordinate of the top line's baseline\n *         blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight\n *           anchorXOffset,\n *           anchorYOffset - totalHeight,\n *           anchorXOffset + maxLineWidth,\n *           anchorYOffset\n *         ],\n *         visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds\n *         timings\n */\n\n/**\n * @typedef {object} TypesetFontData\n * @property src\n * @property unitsPerEm\n * @property ascender\n * @property descender\n * @property lineHeight\n * @property capHeight\n * @property xHeight\n */\n\n/**\n * @typedef {function} TypesetterTypesetFunction - compute fonts and layout for some text.\n * @param {TypesetParams} params\n * @param {(TypesetResult) => void} callback - function called when typesetting is complete.\n *    If the params included `preResolvedFonts`, this will be called synchronously.\n */\n\n/**\n * @typedef {function} TypesetterMeasureFunction - compute width/height for some text.\n * @param {TypesetParams} params\n * @param {(width:number, height:number) => void} callback - function called when measurement is complete.\n *    If the params included `preResolvedFonts`, this will be called synchronously.\n */\n\n\n/**\n * Factory function that creates a self-contained environment for processing text typesetting requests.\n *\n * It is important that this function has no closure dependencies, so that it can be easily injected\n * into the source for a Worker without requiring a build step or complex dependency loading. All its\n * dependencies must be passed in at initialization.\n *\n * @param {FontResolver} resolveFonts - function to resolve a string to parsed fonts\n * @param {object} bidi - the bidi.js implementation object\n * @return {{typeset: TypesetterTypesetFunction, measure: TypesetterMeasureFunction}}\n */\nfunction createTypesetter(resolveFonts, bidi) {\n  const INF = Infinity;\n\n  // Set of Unicode Default_Ignorable_Code_Point characters, these will not produce visible glyphs\n  // eslint-disable-next-line no-misleading-character-class\n  const DEFAULT_IGNORABLE_CHARS = /[\\u00AD\\u034F\\u061C\\u115F-\\u1160\\u17B4-\\u17B5\\u180B-\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u3164\\uFE00-\\uFE0F\\uFEFF\\uFFA0\\uFFF0-\\uFFF8]/;\n\n  // This regex (instead of /\\s/) allows us to select all whitespace EXCEPT for non-breaking white spaces\n  const lineBreakingWhiteSpace = `[^\\\\S\\\\u00A0]`;\n\n  // Incomplete set of characters that allow line breaking after them\n  // In the future we may consider a full Unicode line breaking algorithm impl: https://www.unicode.org/reports/tr14\n  const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\\\-\\\\u007C\\\\u00AD\\\\u2010\\\\u2012-\\\\u2014\\\\u2027\\\\u2056\\\\u2E17\\\\u2E40]`);\n\n  /**\n   * Load and parse all the necessary fonts to render a given string of text, then group\n   * them into consecutive runs of characters sharing a font.\n   */\n  function calculateFontRuns({text, lang, fonts, style, weight, preResolvedFonts, unicodeFontsURL}, onDone) {\n    const onResolved = ({chars, fonts: parsedFonts}) => {\n      let curRun, prevVal;\n      const runs = [];\n      for (let i = 0; i < chars.length; i++) {\n        if (chars[i] !== prevVal) {\n          prevVal = chars[i];\n          runs.push(curRun = { start: i, end: i, fontObj: parsedFonts[chars[i]]});\n        } else {\n          curRun.end = i;\n        }\n      }\n      onDone(runs);\n    };\n    if (preResolvedFonts) {\n      onResolved(preResolvedFonts);\n    } else {\n      resolveFonts(\n        text,\n        onResolved,\n        { lang, fonts, style, weight, unicodeFontsURL }\n      );\n    }\n  }\n\n  /**\n   * Main entry point.\n   * Process a text string with given font and formatting parameters, and return all info\n   * necessary to render all its glyphs.\n   * @type TypesetterTypesetFunction\n   */\n  function typeset(\n    {\n      text='',\n      font,\n      lang,\n      sdfGlyphSize=64,\n      fontSize=400,\n      fontWeight=1,\n      fontStyle='normal',\n      letterSpacing=0,\n      lineHeight='normal',\n      maxWidth=INF,\n      direction,\n      textAlign='left',\n      textIndent=0,\n      whiteSpace='normal',\n      overflowWrap='normal',\n      anchorX = 0,\n      anchorY = 0,\n      metricsOnly=false,\n      unicodeFontsURL,\n      preResolvedFonts=null,\n      includeCaretPositions=false,\n      chunkedBoundsSize=8192,\n      colorRanges=null\n    },\n    callback\n  ) {\n    const mainStart = now();\n    const timings = {fontLoad: 0, typesetting: 0};\n\n    // Ensure newlines are normalized\n    if (text.indexOf('\\r') > -1) {\n      console.info('Typesetter: got text with \\\\r chars; normalizing to \\\\n');\n      text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n    }\n\n    // Ensure we've got numbers not strings\n    fontSize = +fontSize;\n    letterSpacing = +letterSpacing;\n    maxWidth = +maxWidth;\n    lineHeight = lineHeight || 'normal';\n    textIndent = +textIndent;\n\n    calculateFontRuns({\n      text,\n      lang,\n      style: fontStyle,\n      weight: fontWeight,\n      fonts: typeof font === 'string' ? [{src: font}] : font,\n      unicodeFontsURL,\n      preResolvedFonts\n    }, runs => {\n      timings.fontLoad = now() - mainStart;\n      const hasMaxWidth = isFinite(maxWidth);\n      let glyphIds = null;\n      let glyphFontIndices = null;\n      let glyphPositions = null;\n      let glyphData = null;\n      let glyphColors = null;\n      let caretPositions = null;\n      let visibleBounds = null;\n      let chunkedBounds = null;\n      let maxLineWidth = 0;\n      let renderableGlyphCount = 0;\n      let canWrap = whiteSpace !== 'nowrap';\n      const metricsByFont = new Map(); // fontObj -> metrics\n      const typesetStart = now();\n\n      // Distribute glyphs into lines based on wrapping\n      let lineXOffset = textIndent;\n      let prevRunEndX = 0;\n      let currentLine = new TextLine();\n      const lines = [currentLine];\n      runs.forEach(run => {\n        const { fontObj } = run;\n        const { ascender, descender, unitsPerEm, lineGap, capHeight, xHeight } = fontObj;\n\n        // Calculate metrics for each font used\n        let fontData = metricsByFont.get(fontObj);\n        if (!fontData) {\n          // Find conversion between native font units and fontSize units\n          const fontSizeMult = fontSize / unitsPerEm;\n\n          // Determine appropriate value for 'normal' line height based on the font's actual metrics\n          // This does not guarantee individual glyphs won't exceed the line height, e.g. Roboto; should we use yMin/Max instead?\n          const calcLineHeight = lineHeight === 'normal' ?\n            (ascender - descender + lineGap) * fontSizeMult : lineHeight * fontSize;\n\n          // Determine line height and leading adjustments\n          const halfLeading = (calcLineHeight - (ascender - descender) * fontSizeMult) / 2;\n          const caretHeight = Math.min(calcLineHeight, (ascender - descender) * fontSizeMult);\n          const caretTop = (ascender + descender) / 2 * fontSizeMult + caretHeight / 2;\n          fontData = {\n            index: metricsByFont.size,\n            src: fontObj.src,\n            fontObj,\n            fontSizeMult,\n            unitsPerEm,\n            ascender: ascender * fontSizeMult,\n            descender: descender * fontSizeMult,\n            capHeight: capHeight * fontSizeMult,\n            xHeight: xHeight * fontSizeMult,\n            lineHeight: calcLineHeight,\n            baseline: -halfLeading - ascender * fontSizeMult, // baseline offset from top of line height\n            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height\n            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height\n            caretTop: (ascender + descender) / 2 * fontSizeMult + caretHeight / 2,\n            caretBottom: caretTop - caretHeight\n          };\n          metricsByFont.set(fontObj, fontData);\n        }\n        const { fontSizeMult } = fontData;\n\n        const runText = text.slice(run.start, run.end + 1);\n        let prevGlyphX, prevGlyphObj;\n        fontObj.forEachGlyph(runText, fontSize, letterSpacing, (glyphObj, glyphX, glyphY, charIndex) => {\n          glyphX += prevRunEndX;\n          charIndex += run.start;\n          prevGlyphX = glyphX;\n          prevGlyphObj = glyphObj;\n          const char = text.charAt(charIndex);\n          const glyphWidth = glyphObj.advanceWidth * fontSizeMult;\n          const curLineCount = currentLine.count;\n          let nextLine;\n\n          // Calc isWhitespace and isEmpty once per glyphObj\n          if (!('isEmpty' in glyphObj)) {\n            glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);\n            glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);\n            glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);\n          }\n          if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n            renderableGlyphCount++;\n          }\n\n          // If a non-whitespace character overflows the max width, we need to soft-wrap\n          if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {\n            // If it's the first char after a whitespace, start a new line\n            if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {\n              nextLine = new TextLine();\n              lineXOffset = -glyphX;\n            } else {\n              // Back up looking for a whitespace character to wrap at\n              for (let i = curLineCount; i--;) {\n                // If we got the start of the line there's no soft break point; make hard break if overflowWrap='break-word'\n                if (i === 0 && overflowWrap === 'break-word') {\n                  nextLine = new TextLine();\n                  lineXOffset = -glyphX;\n                  break\n                }\n                // Found a soft break point; move all chars since it to a new line\n                else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {\n                  nextLine = currentLine.splitAt(i + 1);\n                  const adjustX = nextLine.glyphAt(0).x;\n                  lineXOffset -= adjustX;\n                  for (let j = nextLine.count; j--;) {\n                    nextLine.glyphAt(j).x -= adjustX;\n                  }\n                  break\n                }\n              }\n            }\n            if (nextLine) {\n              currentLine.isSoftWrapped = true;\n              currentLine = nextLine;\n              lines.push(currentLine);\n              maxLineWidth = maxWidth; //after soft wrapping use maxWidth as calculated width\n            }\n          }\n\n          let fly = currentLine.glyphAt(currentLine.count);\n          fly.glyphObj = glyphObj;\n          fly.x = glyphX + lineXOffset;\n          fly.y = glyphY;\n          fly.width = glyphWidth;\n          fly.charIndex = charIndex;\n          fly.fontData = fontData;\n\n          // Handle hard line breaks\n          if (char === '\\n') {\n            currentLine = new TextLine();\n            lines.push(currentLine);\n            lineXOffset = -(glyphX + glyphWidth + (letterSpacing * fontSize)) + textIndent;\n          }\n        });\n        // At the end of a run we must capture the x position as the starting point for the next run\n        prevRunEndX = prevGlyphX + prevGlyphObj.advanceWidth * fontSizeMult + letterSpacing * fontSize;\n      });\n\n      // Calculate width/height/baseline of each line (excluding trailing whitespace) and maximum block width\n      let totalHeight = 0;\n      lines.forEach(line => {\n        let isTrailingWhitespace = true;\n        for (let i = line.count; i--;) {\n          const glyphInfo = line.glyphAt(i);\n          // omit trailing whitespace from width calculation\n          if (isTrailingWhitespace && !glyphInfo.glyphObj.isWhitespace) {\n            line.width = glyphInfo.x + glyphInfo.width;\n            if (line.width > maxLineWidth) {\n              maxLineWidth = line.width;\n            }\n            isTrailingWhitespace = false;\n          }\n          // use the tallest line height, lowest baseline, and highest cap/ex\n          let {lineHeight, capHeight, xHeight, baseline} = glyphInfo.fontData;\n          if (lineHeight > line.lineHeight) line.lineHeight = lineHeight;\n          const baselineDiff = baseline - line.baseline;\n          if (baselineDiff < 0) { //shift all metrics down\n            line.baseline += baselineDiff;\n            line.cap += baselineDiff;\n            line.ex += baselineDiff;\n          }\n          // compare cap/ex based on new lowest baseline\n          line.cap = Math.max(line.cap, line.baseline + capHeight);\n          line.ex = Math.max(line.ex, line.baseline + xHeight);\n        }\n        line.baseline -= totalHeight;\n        line.cap -= totalHeight;\n        line.ex -= totalHeight;\n        totalHeight += line.lineHeight;\n      });\n\n      // Find overall position adjustments for anchoring\n      let anchorXOffset = 0;\n      let anchorYOffset = 0;\n      if (anchorX) {\n        if (typeof anchorX === 'number') {\n          anchorXOffset = -anchorX;\n        }\n        else if (typeof anchorX === 'string') {\n          anchorXOffset = -maxLineWidth * (\n            anchorX === 'left' ? 0 :\n            anchorX === 'center' ? 0.5 :\n            anchorX === 'right' ? 1 :\n            parsePercent(anchorX)\n          );\n        }\n      }\n      if (anchorY) {\n        if (typeof anchorY === 'number') {\n          anchorYOffset = -anchorY;\n        }\n        else if (typeof anchorY === 'string') {\n          anchorYOffset = anchorY === 'top' ? 0 :\n            anchorY === 'top-baseline' ? -lines[0].baseline :\n            anchorY === 'top-cap' ? -lines[0].cap :\n            anchorY === 'top-ex' ? -lines[0].ex :\n            anchorY === 'middle' ? totalHeight / 2 :\n            anchorY === 'bottom' ? totalHeight :\n            anchorY === 'bottom-baseline' ? lines[lines.length - 1].baseline :\n            parsePercent(anchorY) * totalHeight;\n        }\n      }\n\n      if (!metricsOnly) {\n        // Resolve bidi levels\n        const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);\n\n        // Process each line, applying alignment offsets, adding each glyph to the atlas, and\n        // collecting all renderable glyphs into a single collection.\n        glyphIds = new Uint16Array(renderableGlyphCount);\n        glyphFontIndices = new Uint8Array(renderableGlyphCount);\n        glyphPositions = new Float32Array(renderableGlyphCount * 2);\n        glyphData = {};\n        visibleBounds = [INF, INF, -INF, -INF];\n        chunkedBounds = [];\n        if (includeCaretPositions) {\n          caretPositions = new Float32Array(text.length * 4);\n        }\n        if (colorRanges) {\n          glyphColors = new Uint8Array(renderableGlyphCount * 3);\n        }\n        let renderableGlyphIndex = 0;\n        let prevCharIndex = -1;\n        let colorCharIndex = -1;\n        let chunk;\n        let currentColor;\n        lines.forEach((line, lineIndex) => {\n          let {count:lineGlyphCount, width:lineWidth} = line;\n\n          // Ignore empty lines\n          if (lineGlyphCount > 0) {\n            // Count trailing whitespaces, we want to ignore these for certain things\n            let trailingWhitespaceCount = 0;\n            for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace;) {\n              trailingWhitespaceCount++;\n            }\n\n            // Apply horizontal alignment adjustments\n            let lineXOffset = 0;\n            let justifyAdjust = 0;\n            if (textAlign === 'center') {\n              lineXOffset = (maxLineWidth - lineWidth) / 2;\n            } else if (textAlign === 'right') {\n              lineXOffset = maxLineWidth - lineWidth;\n            } else if (textAlign === 'justify' && line.isSoftWrapped) {\n              // count non-trailing whitespace characters, and we'll adjust the offsets per character in the next loop\n              let whitespaceCount = 0;\n              for (let i = lineGlyphCount - trailingWhitespaceCount; i--;) {\n                if (line.glyphAt(i).glyphObj.isWhitespace) {\n                  whitespaceCount++;\n                }\n              }\n              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;\n            }\n            if (justifyAdjust || lineXOffset) {\n              let justifyOffset = 0;\n              for (let i = 0; i < lineGlyphCount; i++) {\n                let glyphInfo = line.glyphAt(i);\n                const glyphObj = glyphInfo.glyphObj;\n                glyphInfo.x += lineXOffset + justifyOffset;\n                // Expand non-trailing whitespaces for justify alignment\n                if (justifyAdjust !== 0 && glyphObj.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {\n                  justifyOffset += justifyAdjust;\n                  glyphInfo.width += justifyAdjust;\n                }\n              }\n            }\n\n            // Perform bidi range flipping\n            const flips = bidi.getReorderSegments(\n              text, bidiLevelsResult, line.glyphAt(0).charIndex, line.glyphAt(line.count - 1).charIndex\n            );\n            for (let fi = 0; fi < flips.length; fi++) {\n              const [start, end] = flips[fi];\n              // Map start/end string indices to indices in the line\n              let left = Infinity, right = -Infinity;\n              for (let i = 0; i < lineGlyphCount; i++) {\n                if (line.glyphAt(i).charIndex >= start) { // gte to handle removed characters\n                  let startInLine = i, endInLine = i;\n                  for (; endInLine < lineGlyphCount; endInLine++) {\n                    let info = line.glyphAt(endInLine);\n                    if (info.charIndex > end) {\n                      break\n                    }\n                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) { //don't include trailing ws in flip width\n                      left = Math.min(left, info.x);\n                      right = Math.max(right, info.x + info.width);\n                    }\n                  }\n                  for (let j = startInLine; j < endInLine; j++) {\n                    const glyphInfo = line.glyphAt(j);\n                    glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);\n                  }\n                  break\n                }\n              }\n            }\n\n            // Assemble final data arrays\n            let glyphObj;\n            const setGlyphObj = g => glyphObj = g;\n            for (let i = 0; i < lineGlyphCount; i++) {\n              const glyphInfo = line.glyphAt(i);\n              glyphObj = glyphInfo.glyphObj;\n              const glyphId = glyphObj.index;\n\n              // Replace mirrored characters in rtl\n              const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1; //odd level means rtl\n              if (rtl) {\n                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);\n                if (mirrored) {\n                  glyphInfo.fontData.fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);\n                }\n              }\n\n              // Add caret positions\n              if (includeCaretPositions) {\n                const {charIndex, fontData} = glyphInfo;\n                const caretLeft = glyphInfo.x + anchorXOffset;\n                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;\n                caretPositions[charIndex * 4] = rtl ? caretRight : caretLeft; //start edge x\n                caretPositions[charIndex * 4 + 1] = rtl ? caretLeft : caretRight; //end edge x\n                caretPositions[charIndex * 4 + 2] = line.baseline + fontData.caretBottom + anchorYOffset; //common bottom y\n                caretPositions[charIndex * 4 + 3] = line.baseline + fontData.caretTop + anchorYOffset; //common top y\n\n                // If we skipped any chars from the previous glyph (due to ligature subs), fill in caret\n                // positions for those missing char indices; currently this uses a best-guess by dividing\n                // the ligature's width evenly. In the future we may try to use the font's LigatureCaretList\n                // table to get better interior caret positions.\n                const ligCount = charIndex - prevCharIndex;\n                if (ligCount > 1) {\n                  fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n                }\n                prevCharIndex = charIndex;\n              }\n\n              // Track current color range\n              if (colorRanges) {\n                const {charIndex} = glyphInfo;\n                while(charIndex > colorCharIndex) {\n                  colorCharIndex++;\n                  if (colorRanges.hasOwnProperty(colorCharIndex)) {\n                    currentColor = colorRanges[colorCharIndex];\n                  }\n                }\n              }\n\n              // Get atlas data for renderable glyphs\n              if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n                const idx = renderableGlyphIndex++;\n                const {fontSizeMult, src: fontSrc, index: fontIndex} = glyphInfo.fontData;\n\n                // Add this glyph's path data\n                const fontGlyphData = glyphData[fontSrc] || (glyphData[fontSrc] = {});\n                if (!fontGlyphData[glyphId]) {\n                  fontGlyphData[glyphId] = {\n                    path: glyphObj.path,\n                    pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]\n                  };\n                }\n\n                // Determine final glyph position and add to glyphPositions array\n                const glyphX = glyphInfo.x + anchorXOffset;\n                const glyphY = glyphInfo.y + line.baseline + anchorYOffset;\n                glyphPositions[idx * 2] = glyphX;\n                glyphPositions[idx * 2 + 1] = glyphY;\n\n                // Track total visible bounds\n                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;\n                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;\n                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;\n                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;\n                if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;\n                if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;\n                if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;\n                if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;\n\n                // Track bounding rects for each chunk of N glyphs\n                if (idx % chunkedBoundsSize === 0) {\n                  chunk = {start: idx, end: idx, rect: [INF, INF, -INF, -INF]};\n                  chunkedBounds.push(chunk);\n                }\n                chunk.end++;\n                const chunkRect = chunk.rect;\n                if (visX0 < chunkRect[0]) chunkRect[0] = visX0;\n                if (visY0 < chunkRect[1]) chunkRect[1] = visY0;\n                if (visX1 > chunkRect[2]) chunkRect[2] = visX1;\n                if (visY1 > chunkRect[3]) chunkRect[3] = visY1;\n\n                // Add to glyph ids and font indices arrays\n                glyphIds[idx] = glyphId;\n                glyphFontIndices[idx] = fontIndex;\n\n                // Add colors\n                if (colorRanges) {\n                  const start = idx * 3;\n                  glyphColors[start] = currentColor >> 16 & 255;\n                  glyphColors[start + 1] = currentColor >> 8 & 255;\n                  glyphColors[start + 2] = currentColor & 255;\n                }\n              }\n            }\n          }\n        });\n\n        // Fill in remaining caret positions in case the final character was a ligature\n        if (caretPositions) {\n          const ligCount = text.length - prevCharIndex;\n          if (ligCount > 1) {\n            fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n          }\n        }\n      }\n\n      // Assemble final data about each font used\n      const fontData = [];\n      metricsByFont.forEach(({index, src, unitsPerEm, ascender, descender, lineHeight, capHeight, xHeight}) => {\n        fontData[index] = {src, unitsPerEm, ascender, descender, lineHeight, capHeight, xHeight};\n      });\n\n      // Timing stats\n      timings.typesetting = now() - typesetStart;\n\n      callback({\n        glyphIds, //id for each glyph, specific to that glyph's font\n        glyphFontIndices, //index into fontData for each glyph\n        glyphPositions, //x,y of each glyph's origin in layout\n        glyphData, //dict holding data about each glyph appearing in the text\n        fontData, //data about each font used in the text\n        caretPositions, //startX,endX,bottomY caret positions for each char\n        // caretHeight, //height of cursor from bottom to top - todo per glyph?\n        glyphColors, //color for each glyph, if color ranges supplied\n        chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs\n        fontSize, //calculated em height\n        topBaseline: anchorYOffset + lines[0].baseline, //y coordinate of the top line's baseline\n        blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight\n          anchorXOffset,\n          anchorYOffset - totalHeight,\n          anchorXOffset + maxLineWidth,\n          anchorYOffset\n        ],\n        visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds\n        timings\n      });\n    });\n  }\n\n\n  /**\n   * For a given text string and font parameters, determine the resulting block dimensions\n   * after wrapping for the given maxWidth.\n   * @param args\n   * @param callback\n   */\n  function measure(args, callback) {\n    typeset({...args, metricsOnly: true}, (result) => {\n      const [x0, y0, x1, y1] = result.blockBounds;\n      callback({\n        width: x1 - x0,\n        height: y1 - y0\n      });\n    });\n  }\n\n  function parsePercent(str) {\n    let match = str.match(/^([\\d.]+)%$/);\n    let pct = match ? parseFloat(match[1]) : NaN;\n    return isNaN(pct) ? 0 : pct / 100\n  }\n\n  function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {\n    const ligStartX = caretPositions[ligStartIndex * 4];\n    const ligEndX = caretPositions[ligStartIndex * 4 + 1];\n    const ligBottom = caretPositions[ligStartIndex * 4 + 2];\n    const ligTop = caretPositions[ligStartIndex * 4 + 3];\n    const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;\n    for (let i = 0; i < ligCount; i++) {\n      const startIndex = (ligStartIndex + i) * 4;\n      caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;\n      caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);\n      caretPositions[startIndex + 2] = ligBottom;\n      caretPositions[startIndex + 3] = ligTop;\n    }\n  }\n\n  function now() {\n    return (self.performance || Date).now()\n  }\n\n  // Array-backed structure for a single line's glyphs data\n  function TextLine() {\n    this.data = [];\n  }\n  const textLineProps = ['glyphObj', 'x', 'y', 'width', 'charIndex', 'fontData'];\n  TextLine.prototype = {\n    width: 0,\n    lineHeight: 0,\n    baseline: 0,\n    cap: 0,\n    ex: 0,\n    isSoftWrapped: false,\n    get count() {\n      return Math.ceil(this.data.length / textLineProps.length)\n    },\n    glyphAt(i) {\n      let fly = TextLine.flyweight;\n      fly.data = this.data;\n      fly.index = i;\n      return fly\n    },\n    splitAt(i) {\n      let newLine = new TextLine();\n      newLine.data = this.data.splice(i * textLineProps.length);\n      return newLine\n    }\n  };\n  TextLine.flyweight = textLineProps.reduce((obj, prop, i, all) => {\n    Object.defineProperty(obj, prop, {\n      get() {\n        return this.data[this.index * textLineProps.length + i]\n      },\n      set(val) {\n        this.data[this.index * textLineProps.length + i] = val;\n      }\n    });\n    return obj\n  }, {data: null, index: 0});\n\n\n  return {\n    typeset,\n    measure,\n  }\n}\n\nconst now = () => (self.performance || Date).now();\n\nconst mainThreadGenerator = /*#__PURE__*/ (0,webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\nlet warned;\n\n/**\n * Generate an SDF texture image for a single glyph path, placing the result into a webgl canvas at a\n * given location and channel. Utilizes the webgl-sdf-generator external package for GPU-accelerated SDF\n * generation when supported.\n */\nfunction generateSDF(width, height, path, viewBox, distance, exponent, canvas, x, y, channel, useWebGL = true) {\n  // Allow opt-out\n  if (!useWebGL) {\n    return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)\n  }\n\n  // Attempt GPU-accelerated generation first\n  return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x, y, channel).then(\n    null,\n    err => {\n      // WebGL failed either due to a hard error or unexpected results; fall back to JS in workers\n      if (!warned) {\n        console.warn(`WebGL SDF generation failed, falling back to JS`, err);\n        warned = true;\n      }\n      return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)\n    }\n  )\n}\n\nconst queue = [];\nconst chunkTimeBudget = 5; // ms\nlet timer = 0;\n\nfunction nextChunk() {\n  const start = now();\n  while (queue.length && now() - start < chunkTimeBudget) {\n    queue.shift()();\n  }\n  timer = queue.length ? setTimeout(nextChunk, 0) : 0;\n}\n\n/**\n * WebGL-based implementation executed on the main thread. Requests are executed in time-bounded\n * macrotask chunks to allow render frames to execute in between.\n */\nconst generateSDF_GL = (...args) => {\n  return new Promise((resolve, reject) => {\n    queue.push(() => {\n      const start = now();\n      try {\n        mainThreadGenerator.webgl.generateIntoCanvas(...args);\n        resolve({ timing: now() - start });\n      } catch (err) {\n        reject(err);\n      }\n    });\n    if (!timer) {\n      timer = setTimeout(nextChunk, 0);\n    }\n  })\n};\n\nconst threadCount = 4; // how many workers to spawn\nconst idleTimeout = 2000; // workers will be terminated after being idle this many milliseconds\nconst threads = {};\nlet callNum = 0;\n\n/**\n * Fallback JS-based implementation, fanned out to a number of worker threads for parallelism\n */\nfunction generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel) {\n  const workerId = 'TroikaTextSDFGenerator_JS_' + ((callNum++) % threadCount);\n  let thread = threads[workerId];\n  if (!thread) {\n    thread = threads[workerId] = {\n      workerModule: (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n        name: workerId,\n        workerId,\n        dependencies: [\n          webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n          now\n        ],\n        init(_createSDFGenerator, now) {\n          const generate = _createSDFGenerator().javascript.generate;\n          return function (...args) {\n            const start = now();\n            const textureData = generate(...args);\n            return {\n              textureData,\n              timing: now() - start\n            }\n          }\n        },\n        getTransferables(result) {\n          return [result.textureData.buffer]\n        }\n      }),\n      requests: 0,\n      idleTimer: null\n    };\n  }\n\n  thread.requests++;\n  clearTimeout(thread.idleTimer);\n  return thread.workerModule(width, height, path, viewBox, distance, exponent)\n    .then(({ textureData, timing }) => {\n      // copy result data into the canvas\n      const start = now();\n      // expand single-channel data into rgba\n      const imageData = new Uint8Array(textureData.length * 4);\n      for (let i = 0; i < textureData.length; i++) {\n        imageData[i * 4 + channel] = textureData[i];\n      }\n      mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y, width, height, 1 << (3 - channel));\n      timing += now() - start;\n\n      // clean up workers after a while\n      if (--thread.requests === 0) {\n        thread.idleTimer = setTimeout(() => { (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.terminateWorker)(workerId); }, idleTimeout);\n      }\n      return { timing }\n    })\n}\n\nfunction warmUpSDFCanvas(canvas) {\n  if (!canvas._warm) {\n    mainThreadGenerator.webgl.isSupported(canvas);\n    canvas._warm = true;\n  }\n}\n\nconst resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;\n\nconst CONFIG = {\n  defaultFontURL: null,\n  unicodeFontsURL: null,\n  sdfGlyphSize: 64,\n  sdfMargin: 1 / 16,\n  sdfExponent: 9,\n  textureWidth: 2048,\n};\nconst tempColor = /*#__PURE__*/new three__WEBPACK_IMPORTED_MODULE_3__.Color();\nlet hasRequested = false;\n\nfunction now$1() {\n  return (self.performance || Date).now()\n}\n\n/**\n * Customizes the text builder configuration. This must be called prior to the first font processing\n * request, and applies to all fonts.\n *\n * @param {String} config.defaultFontURL - The URL of the default font to use for text processing\n *                 requests, in case none is specified or the specifiede font fails to load or parse.\n *                 Defaults to \"Roboto Regular\" from Google Fonts.\n * @param {String} config.unicodeFontsURL - A custom location for the fallback unicode-font-resolver\n *                 data and font files, if you don't want to use the default CDN. See\n *                 https://github.com/lojjic/unicode-font-resolver for details. It can also be\n *                 configured per text instance, but this lets you do it once globally.\n * @param {Number} config.sdfGlyphSize - The default size of each glyph's SDF (signed distance field)\n *                 texture used for rendering. Must be a power-of-two number, and applies to all fonts,\n *                 but note that this can also be overridden per call to `getTextRenderInfo()`.\n *                 Larger sizes can improve the quality of glyph rendering by increasing the sharpness\n *                 of corners and preventing loss of very thin lines, at the expense of memory. Defaults\n *                 to 64 which is generally a good balance of size and quality.\n * @param {Number} config.sdfExponent - The exponent used when encoding the SDF values. A higher exponent\n *                 shifts the encoded 8-bit values to achieve higher precision/accuracy at texels nearer\n *                 the glyph's path, with lower precision further away. Defaults to 9.\n * @param {Number} config.sdfMargin - How much space to reserve in the SDF as margin outside the glyph's\n *                 path, as a percentage of the SDF width. A larger margin increases the quality of\n *                 extruded glyph outlines, but decreases the precision available for the glyph itself.\n *                 Defaults to 1/16th of the glyph size.\n * @param {Number} config.textureWidth - The width of the SDF texture; must be a power of 2. Defaults to\n *                 2048 which is a safe maximum texture dimension according to the stats at\n *                 https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE and should allow for a\n *                 reasonably large number of glyphs (default glyph size of 64^2 and safe texture size of\n *                 2048^2, times 4 channels, allows for 4096 glyphs.) This can be increased if you need to\n *                 increase the glyph size and/or have an extraordinary number of glyphs.\n */\nfunction configureTextBuilder(config) {\n  if (hasRequested) {\n    console.warn('configureTextBuilder called after first font request; will be ignored.');\n  } else {\n    assign(CONFIG, config);\n  }\n}\n\n/**\n * Repository for all font SDF atlas textures and their glyph mappings. There is a separate atlas for\n * each sdfGlyphSize. Each atlas has a single Texture that holds all glyphs for all fonts.\n *\n *   {\n *     [sdfGlyphSize]: {\n *       glyphCount: number,\n *       sdfGlyphSize: number,\n *       sdfTexture: Texture,\n *       sdfCanvas: HTMLCanvasElement,\n *       contextLost: boolean,\n *       glyphsByFont: Map<fontURL, Map<glyphID, {path, atlasIndex, sdfViewBox}>>\n *     }\n *   }\n */\nconst atlases = Object.create(null);\n\n/**\n * @typedef {object} TroikaTextRenderInfo - Format of the result from `getTextRenderInfo`.\n * @property {TypesetParams} parameters - The normalized input arguments to the render call.\n * @property {Texture} sdfTexture - The SDF atlas texture.\n * @property {number} sdfGlyphSize - The size of each glyph's SDF; see `configureTextBuilder`.\n * @property {number} sdfExponent - The exponent used in encoding the SDF's values; see `configureTextBuilder`.\n * @property {Float32Array} glyphBounds - List of [minX, minY, maxX, maxY] quad bounds for each glyph.\n * @property {Float32Array} glyphAtlasIndices - List holding each glyph's index in the SDF atlas.\n * @property {Uint8Array} [glyphColors] - List holding each glyph's [r, g, b] color, if `colorRanges` was supplied.\n * @property {Float32Array} [caretPositions] - A list of caret positions for all characters in the string; each is\n *           four elements: the starting X, the ending X, the bottom Y, and the top Y for the caret.\n * @property {number} [caretHeight] - An appropriate height for all selection carets.\n * @property {number} ascender - The font's ascender metric.\n * @property {number} descender - The font's descender metric.\n * @property {number} capHeight - The font's cap height metric, based on the height of Latin capital letters.\n * @property {number} xHeight - The font's x height metric, based on the height of Latin lowercase letters.\n * @property {number} lineHeight - The final computed lineHeight measurement.\n * @property {number} topBaseline - The y position of the top line's baseline.\n * @property {Array<number>} blockBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n *           this can include extra vertical space beyond the visible glyphs due to lineHeight, and is\n *           equivalent to the dimensions of a block-level text element in CSS.\n * @property {Array<number>} visibleBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n *           unlike `blockBounds` this is tightly wrapped to the visible glyph paths.\n * @property {Array<object>} chunkedBounds - List of bounding rects for each consecutive set of N glyphs,\n *           in the format `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`.\n * @property {object} timings - Timing info for various parts of the rendering logic including SDF\n *           generation, typesetting, etc.\n * @frozen\n */\n\n/**\n * @callback getTextRenderInfo~callback\n * @param {TroikaTextRenderInfo} textRenderInfo\n */\n\n/**\n * Main entry point for requesting the data needed to render a text string with given font parameters.\n * This is an asynchronous call, performing most of the logic in a web worker thread.\n * @param {TypesetParams} args\n * @param {getTextRenderInfo~callback} callback\n */\nfunction getTextRenderInfo(args, callback) {\n  hasRequested = true;\n  args = assign({}, args);\n  const totalStart = now$1();\n\n  // Convert relative URL to absolute so it can be resolved in the worker, and add fallbacks.\n  // In the future we'll allow args.font to be a list with unicode ranges too.\n  const { defaultFontURL } = CONFIG;\n  const fonts = [];\n  if (defaultFontURL) {\n    fonts.push({label: 'default', src: toAbsoluteURL(defaultFontURL)});\n  }\n  if (args.font) {\n    fonts.push({label: 'user', src: toAbsoluteURL(args.font)});\n  }\n  args.font = fonts;\n\n  // Normalize text to a string\n  args.text = '' + args.text;\n\n  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;\n  args.unicodeFontsURL = args.unicodeFontsURL || CONFIG.unicodeFontsURL;\n\n  // Normalize colors\n  if (args.colorRanges != null) {\n    let colors = {};\n    for (let key in args.colorRanges) {\n      if (args.colorRanges.hasOwnProperty(key)) {\n        let val = args.colorRanges[key];\n        if (typeof val !== 'number') {\n          val = tempColor.set(val).getHex();\n        }\n        colors[key] = val;\n      }\n    }\n    args.colorRanges = colors;\n  }\n\n  Object.freeze(args);\n\n  // Init the atlas if needed\n  const {textureWidth, sdfExponent} = CONFIG;\n  const {sdfGlyphSize} = args;\n  const glyphsPerRow = (textureWidth / sdfGlyphSize * 4);\n  let atlas = atlases[sdfGlyphSize];\n  if (!atlas) {\n    const canvas = document.createElement('canvas');\n    canvas.width = textureWidth;\n    canvas.height = sdfGlyphSize * 256 / glyphsPerRow; // start tall enough to fit 256 glyphs\n    atlas = atlases[sdfGlyphSize] = {\n      glyphCount: 0,\n      sdfGlyphSize,\n      sdfCanvas: canvas,\n      sdfTexture: new three__WEBPACK_IMPORTED_MODULE_3__.Texture(\n        canvas,\n        undefined,\n        undefined,\n        undefined,\n        three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter,\n        three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter\n      ),\n      contextLost: false,\n      glyphsByFont: new Map()\n    };\n    atlas.sdfTexture.generateMipmaps = false;\n    initContextLossHandling(atlas);\n  }\n\n  const {sdfTexture, sdfCanvas} = atlas;\n\n  // Issue request to the typesetting engine in the worker\n  typesetInWorker(args).then(result => {\n    const {glyphIds, glyphFontIndices, fontData, glyphPositions, fontSize, timings} = result;\n    const neededSDFs = [];\n    const glyphBounds = new Float32Array(glyphIds.length * 4);\n    let boundsIdx = 0;\n    let positionsIdx = 0;\n    const quadsStart = now$1();\n\n    const fontGlyphMaps = fontData.map(font => {\n      let map = atlas.glyphsByFont.get(font.src);\n      if (!map) {\n        atlas.glyphsByFont.set(font.src, map = new Map());\n      }\n      return map\n    });\n\n    glyphIds.forEach((glyphId, i) => {\n      const fontIndex = glyphFontIndices[i];\n      const {src: fontSrc, unitsPerEm} = fontData[fontIndex];\n      let glyphInfo = fontGlyphMaps[fontIndex].get(glyphId);\n\n      // If this is a glyphId not seen before, add it to the atlas\n      if (!glyphInfo) {\n        const {path, pathBounds} = result.glyphData[fontSrc][glyphId];\n\n        // Margin around path edges in SDF, based on a percentage of the glyph's max dimension.\n        // Note we add an extra 0.5 px over the configured value because the outer 0.5 doesn't contain\n        // useful interpolated values and will be ignored anyway.\n        const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1])\n          / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);\n\n        const atlasIndex = atlas.glyphCount++;\n        const sdfViewBox = [\n          pathBounds[0] - fontUnitsMargin,\n          pathBounds[1] - fontUnitsMargin,\n          pathBounds[2] + fontUnitsMargin,\n          pathBounds[3] + fontUnitsMargin,\n        ];\n        fontGlyphMaps[fontIndex].set(glyphId, (glyphInfo = { path, atlasIndex, sdfViewBox }));\n\n        // Collect those that need SDF generation\n        neededSDFs.push(glyphInfo);\n      }\n\n      // Calculate bounds for renderable quads\n      // TODO can we get this back off the main thread?\n      const {sdfViewBox} = glyphInfo;\n      const posX = glyphPositions[positionsIdx++];\n      const posY = glyphPositions[positionsIdx++];\n      const fontSizeMult = fontSize / unitsPerEm;\n      glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;\n      glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;\n      glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;\n      glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;\n\n      // Convert glyphId to SDF index for the shader\n      glyphIds[i] = glyphInfo.atlasIndex;\n    });\n    timings.quads = (timings.quads || 0) + (now$1() - quadsStart);\n\n    const sdfStart = now$1();\n    timings.sdf = {};\n\n    // Grow the texture height by power of 2 if needed\n    const currentHeight = sdfCanvas.height;\n    const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);\n    const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));\n    if (neededHeight > currentHeight) {\n      // Since resizing the canvas clears its render buffer, it needs special handling to copy the old contents over\n      console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);\n      resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);\n      // As of Three r136 textures cannot be resized once they're allocated on the GPU, we must dispose to reallocate it\n      sdfTexture.dispose();\n    }\n\n    Promise.all(neededSDFs.map(glyphInfo =>\n      generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({timing}) => {\n        timings.sdf[glyphInfo.atlasIndex] = timing;\n      })\n    )).then(() => {\n      if (neededSDFs.length && !atlas.contextLost) {\n        safariPre15Workaround(atlas);\n        sdfTexture.needsUpdate = true;\n      }\n      timings.sdfTotal = now$1() - sdfStart;\n      timings.total = now$1() - totalStart;\n      // console.log(`SDF - ${timings.sdfTotal}, Total - ${timings.total - timings.fontLoad}`)\n\n      // Invoke callback with the text layout arrays and updated texture\n      callback(Object.freeze({\n        parameters: args,\n        sdfTexture,\n        sdfGlyphSize,\n        sdfExponent,\n        glyphBounds,\n        glyphAtlasIndices: glyphIds,\n        glyphColors: result.glyphColors,\n        caretPositions: result.caretPositions,\n        chunkedBounds: result.chunkedBounds,\n        ascender: result.ascender,\n        descender: result.descender,\n        lineHeight: result.lineHeight,\n        capHeight: result.capHeight,\n        xHeight: result.xHeight,\n        topBaseline: result.topBaseline,\n        blockBounds: result.blockBounds,\n        visibleBounds: result.visibleBounds,\n        timings: result.timings,\n      }));\n    });\n  });\n\n  // While the typesetting request is being handled, go ahead and make sure the atlas canvas context is\n  // \"warmed up\"; the first request will be the longest due to shader program compilation so this gets\n  // a head start on that process before SDFs actually start getting processed.\n  Promise.resolve().then(() => {\n    if (!atlas.contextLost) {\n      warmUpSDFCanvas(sdfCanvas);\n    }\n  });\n}\n\nfunction generateGlyphSDF({path, atlasIndex, sdfViewBox}, {sdfGlyphSize, sdfCanvas, contextLost}, useGPU) {\n  if (contextLost) {\n    // If the context is lost there's nothing we can do, just quit silently and let it\n    // get regenerated when the context is restored\n    return Promise.resolve({timing: -1})\n  }\n  const {textureWidth, sdfExponent} = CONFIG;\n  const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);\n  const squareIndex = Math.floor(atlasIndex / 4);\n  const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;\n  const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;\n  const channel = atlasIndex % 4;\n  return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y, channel, useGPU)\n}\n\nfunction initContextLossHandling(atlas) {\n  const canvas = atlas.sdfCanvas;\n\n  /*\n  // Begin context loss simulation\n  if (!window.WebGLDebugUtils) {\n    let script = document.getElementById('WebGLDebugUtilsScript')\n    if (!script) {\n      script = document.createElement('script')\n      script.id = 'WebGLDebugUtils'\n      document.head.appendChild(script)\n      script.src = 'https://cdn.jsdelivr.net/gh/KhronosGroup/WebGLDeveloperTools@b42e702/src/debug/webgl-debug.js'\n    }\n    script.addEventListener('load', () => {\n      initContextLossHandling(atlas)\n    })\n    return\n  }\n  window.WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas)\n  canvas.loseContextInNCalls(500)\n  canvas.addEventListener('webglcontextrestored', (event) => {\n    canvas.loseContextInNCalls(5000)\n  })\n  // End context loss simulation\n  */\n\n  canvas.addEventListener('webglcontextlost', (event) => {\n    console.log('Context Lost', event);\n    event.preventDefault();\n    atlas.contextLost = true;\n  });\n  canvas.addEventListener('webglcontextrestored', (event) => {\n    console.log('Context Restored', event);\n    atlas.contextLost = false;\n    // Regenerate all glyphs into the restored canvas:\n    const promises = [];\n    atlas.glyphsByFont.forEach(glyphMap => {\n      glyphMap.forEach(glyph => {\n        promises.push(generateGlyphSDF(glyph, atlas, true));\n      });\n    });\n    Promise.all(promises).then(() => {\n      safariPre15Workaround(atlas);\n      atlas.sdfTexture.needsUpdate = true;\n    });\n  });\n}\n\n/**\n * Preload a given font and optionally pre-generate glyph SDFs for one or more character sequences.\n * This can be useful to avoid long pauses when first showing text in a scene, by preloading the\n * needed fonts and glyphs up front along with other assets.\n *\n * @param {object} options\n * @param {string} options.font - URL of the font file to preload. If not given, the default font will\n *        be loaded.\n * @param {string|string[]} options.characters - One or more character sequences for which to pre-\n *        generate glyph SDFs. Note that this will honor ligature substitution, so you may need\n *        to specify ligature sequences in addition to their individual characters to get all\n *        possible glyphs, e.g. `[\"t\", \"h\", \"th\"]` to get the \"t\" and \"h\" glyphs plus the \"th\" ligature.\n * @param {number} options.sdfGlyphSize - The size at which to prerender the SDF textures for the\n *        specified `characters`.\n * @param {function} callback - A function that will be called when the preloading is complete.\n */\nfunction preloadFont({font, characters, sdfGlyphSize}, callback) {\n  let text = Array.isArray(characters) ? characters.join('\\n') : '' + characters;\n  getTextRenderInfo({ font, sdfGlyphSize, text }, callback);\n}\n\n\n// Local assign impl so we don't have to import troika-core\nfunction assign(toObj, fromObj) {\n  for (let key in fromObj) {\n    if (fromObj.hasOwnProperty(key)) {\n      toObj[key] = fromObj[key];\n    }\n  }\n  return toObj\n}\n\n// Utility for making URLs absolute\nlet linkEl;\nfunction toAbsoluteURL(path) {\n  if (!linkEl) {\n    linkEl = typeof document === 'undefined' ? {} : document.createElement('a');\n  }\n  linkEl.href = path;\n  return linkEl.href\n}\n\n/**\n * Safari < v15 seems unable to use the SDF webgl canvas as a texture. This applies a workaround\n * where it reads the pixels out of that canvas and uploads them as a data texture instead, at\n * a slight performance cost.\n */\nfunction safariPre15Workaround(atlas) {\n  // Use createImageBitmap support as a proxy for Safari<15, all other mainstream browsers\n  // have supported it for a long while so any false positives should be minimal.\n  if (typeof createImageBitmap !== 'function') {\n    console.info('Safari<15: applying SDF canvas workaround');\n    const {sdfCanvas, sdfTexture} = atlas;\n    const {width, height} = sdfCanvas;\n    const gl = atlas.sdfCanvas.getContext('webgl');\n    let pixels = sdfTexture.image.data;\n    if (!pixels || pixels.length !== width * height * 4) {\n      pixels = new Uint8Array(width * height * 4);\n      sdfTexture.image = {width, height, data: pixels};\n      sdfTexture.flipY = false;\n      sdfTexture.isDataTexture = true;\n    }\n    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n  }\n}\n\nconst typesetterWorkerModule = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'Typesetter',\n  dependencies: [\n    createTypesetter,\n    fontResolverWorkerModule,\n    bidi_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  ],\n  init(createTypesetter, fontResolver, bidiFactory) {\n    return createTypesetter(fontResolver, bidiFactory())\n  }\n});\n\nconst typesetInWorker = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'Typesetter',\n  dependencies: [\n    typesetterWorkerModule,\n  ],\n  init(typesetter) {\n    return function(args) {\n      return new Promise(resolve => {\n        typesetter.typeset(args, resolve);\n      })\n    }\n  },\n  getTransferables(result) {\n    // Mark array buffers as transferable to avoid cloning during postMessage\n    const transferables = [];\n    for (let p in result) {\n      if (result[p] && result[p].buffer) {\n        transferables.push(result[p].buffer);\n      }\n    }\n    return transferables\n  }\n});\n\nfunction dumpSDFTextures() {\n  Object.keys(atlases).forEach(size => {\n    const canvas = atlases[size].sdfCanvas;\n    const {width, height} = canvas;\n    console.log(\"%c.\", `\n      background: url(${canvas.toDataURL()});\n      background-size: ${width}px ${height}px;\n      color: transparent;\n      font-size: 0;\n      line-height: ${height}px;\n      padding-left: ${width}px;\n    `);\n  });\n}\n\nconst templateGeometries = {};\n\nfunction getTemplateGeometry(detail) {\n  let geom = templateGeometries[detail];\n  if (!geom) {\n    // Geometry is two planes back-to-back, which will always be rendered FrontSide only but\n    // appear as DoubleSide by default. FrontSide/BackSide are emulated using drawRange.\n    // We do it this way to avoid the performance hit of two draw calls for DoubleSide materials\n    // introduced by Three.js in r130 - see https://github.com/mrdoob/three.js/pull/21967\n    const front = new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1, detail, detail);\n    const back = front.clone();\n    const frontAttrs = front.attributes;\n    const backAttrs = back.attributes;\n    const combined = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n    const vertCount = frontAttrs.uv.count;\n    for (let i = 0; i < vertCount; i++) {\n      backAttrs.position.array[i * 3] *= -1; // flip position x\n      backAttrs.normal.array[i * 3 + 2] *= -1; // flip normal z\n    }\n    ['position', 'normal', 'uv'].forEach(name => {\n      combined.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(\n        [...frontAttrs[name].array, ...backAttrs[name].array],\n        frontAttrs[name].itemSize)\n      );\n    });\n    combined.setIndex([...front.index.array, ...back.index.array.map(n => n + vertCount)]);\n    combined.translate(0.5, 0.5, 0);\n    geom = templateGeometries[detail] = combined;\n  }\n  return geom\n}\n\nconst glyphBoundsAttrName = 'aTroikaGlyphBounds';\nconst glyphIndexAttrName = 'aTroikaGlyphIndex';\nconst glyphColorAttrName = 'aTroikaGlyphColor';\n\n/**\n@class GlyphsGeometry\n\nA specialized Geometry for rendering a set of text glyphs. Uses InstancedBufferGeometry to\nrender the glyphs using GPU instancing of a single quad, rather than constructing a whole\ngeometry with vertices, for much smaller attribute arraybuffers according to this math:\n\n  Where N = number of glyphs...\n\n  Instanced:\n  - position: 4 * 3\n  - index: 2 * 3\n  - normal: 4 * 3\n  - uv: 4 * 2\n  - glyph x/y bounds: N * 4\n  - glyph indices: N * 1\n  = 5N + 38\n\n  Non-instanced:\n  - position: N * 4 * 3\n  - index: N * 2 * 3\n  - normal: N * 4 * 3\n  - uv: N * 4 * 2\n  - glyph indices: N * 1\n  = 39N\n\nA downside of this is the rare-but-possible lack of the instanced arrays extension,\nwhich we could potentially work around with a fallback non-instanced implementation.\n\n*/\nclass GlyphsGeometry extends three__WEBPACK_IMPORTED_MODULE_3__.InstancedBufferGeometry {\n  constructor() {\n    super();\n\n    this.detail = 1;\n    this.curveRadius = 0;\n\n    // Define groups for rendering text outline as a separate pass; these will only\n    // be used when the `material` getter returns an array, i.e. outlineWidth > 0.\n    this.groups = [\n      {start: 0, count: Infinity, materialIndex: 0},\n      {start: 0, count: Infinity, materialIndex: 1}\n    ];\n\n    // Preallocate empty bounding objects\n    this.boundingSphere = new three__WEBPACK_IMPORTED_MODULE_3__.Sphere();\n    this.boundingBox = new three__WEBPACK_IMPORTED_MODULE_3__.Box3();\n  }\n\n  computeBoundingSphere () {\n    // No-op; we'll sync the boundingSphere proactively when needed.\n  }\n\n  computeBoundingBox() {\n    // No-op; we'll sync the boundingBox proactively when needed.\n  }\n\n  // Since our base geometry contains triangles for both front and back sides, we can emulate\n  // the \"side\" by restricting the draw range.\n  setSide(side) {\n    const verts = this.getIndex().count;\n    this.setDrawRange(side === three__WEBPACK_IMPORTED_MODULE_3__.BackSide ? verts / 2 : 0, side === three__WEBPACK_IMPORTED_MODULE_3__.DoubleSide ? verts : verts / 2);\n  }\n\n  set detail(detail) {\n    if (detail !== this._detail) {\n      this._detail = detail;\n      if (typeof detail !== 'number' || detail < 1) {\n        detail = 1;\n      }\n      let tpl = getTemplateGeometry(detail)\n      ;['position', 'normal', 'uv'].forEach(attr => {\n        this.attributes[attr] = tpl.attributes[attr].clone();\n      });\n      this.setIndex(tpl.getIndex().clone());\n    }\n  }\n  get detail() {\n    return this._detail\n  }\n\n  set curveRadius(r) {\n    if (r !== this._curveRadius) {\n      this._curveRadius = r;\n      this._updateBounds();\n    }\n  }\n  get curveRadius() {\n    return this._curveRadius\n  }\n\n  /**\n   * Update the geometry for a new set of glyphs.\n   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs\n   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1\n   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within\n   *        the SDF atlas texture.\n   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs\n   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N\n   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be\n   *        used with `applyClipRect` to choose an optimized `instanceCount`.\n   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.\n   */\n  updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {\n    // Update the instance attributes\n    updateBufferAttr(this, glyphBoundsAttrName, glyphBounds, 4);\n    updateBufferAttr(this, glyphIndexAttrName, glyphAtlasIndices, 1);\n    updateBufferAttr(this, glyphColorAttrName, glyphColors, 3);\n    this._blockBounds = blockBounds;\n    this._chunkedBounds = chunkedBounds;\n    this.instanceCount = glyphAtlasIndices.length;\n    this._updateBounds();\n  }\n\n  _updateBounds() {\n    const bounds = this._blockBounds;\n    if (bounds) {\n      const { curveRadius, boundingBox: bbox } = this;\n      if (curveRadius) {\n        const { PI, floor, min, max, sin, cos } = Math;\n        const halfPi = PI / 2;\n        const twoPi = PI * 2;\n        const absR = Math.abs(curveRadius);\n        const leftAngle = bounds[0] / absR;\n        const rightAngle = bounds[2] / absR;\n        const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi)\n          ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);\n        const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi)\n          ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);\n        const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi)\n          ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);\n        bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);\n        bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);\n      } else {\n        bbox.min.set(bounds[0], bounds[1], 0);\n        bbox.max.set(bounds[2], bounds[3], 0);\n      }\n      bbox.getBoundingSphere(this.boundingSphere);\n    }\n  }\n\n  /**\n   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest\n   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization\n   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would\n   * be clipped anyway.\n   *\n   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting\n   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the\n   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,\n   * but at the expense of much larger attribute buffers (see classdoc above.)\n   *\n   * @param {Vector4} clipRect\n   */\n  applyClipRect(clipRect) {\n    let count = this.getAttribute(glyphIndexAttrName).count;\n    let chunks = this._chunkedBounds;\n    if (chunks) {\n      for (let i = chunks.length; i--;) {\n        count = chunks[i].end;\n        let rect = chunks[i].rect;\n        // note: both rects are l-b-r-t\n        if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {\n          break\n        }\n      }\n    }\n    this.instanceCount = count;\n  }\n}\n\n\nfunction updateBufferAttr(geom, attrName, newArray, itemSize) {\n  const attr = geom.getAttribute(attrName);\n  if (newArray) {\n    // If length isn't changing, just update the attribute's array data\n    if (attr && attr.array.length === newArray.length) {\n      attr.array.set(newArray);\n      attr.needsUpdate = true;\n    } else {\n      geom.setAttribute(attrName, new three__WEBPACK_IMPORTED_MODULE_3__.InstancedBufferAttribute(newArray, itemSize));\n      // If the new attribute has a different size, we also have to (as of r117) manually clear the\n      // internal cached max instance count. See https://github.com/mrdoob/three.js/issues/19706\n      // It's unclear if this is a threejs bug or a truly unsupported scenario; discussion in\n      // that ticket is ambiguous as to whether replacing a BufferAttribute with one of a\n      // different size is supported, but https://github.com/mrdoob/three.js/pull/17418 strongly\n      // implies it should be supported. It's possible we need to\n      delete geom._maxInstanceCount; //for r117+, could be fragile\n      geom.dispose(); //for r118+, more robust feeling, but more heavy-handed than I'd like\n    }\n  } else if (attr) {\n    geom.deleteAttribute(attrName);\n  }\n}\n\n// language=GLSL\nconst VERTEX_DEFS = `\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform vec4 uTroikaTotalBounds;\nuniform vec4 uTroikaClipRect;\nuniform mat3 uTroikaOrient;\nuniform bool uTroikaUseGlyphColors;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaBlurRadius;\nuniform vec2 uTroikaPositionOffset;\nuniform float uTroikaCurveRadius;\nattribute vec4 aTroikaGlyphBounds;\nattribute float aTroikaGlyphIndex;\nattribute vec3 aTroikaGlyphColor;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec3 vTroikaGlyphColor;\nvarying vec2 vTroikaGlyphDimensions;\n`;\n\n// language=GLSL prefix=\"void main() {\" suffix=\"}\"\nconst VERTEX_TRANSFORM = `\nvec4 bounds = aTroikaGlyphBounds;\nbounds.xz += uTroikaPositionOffset.x;\nbounds.yw -= uTroikaPositionOffset.y;\n\nvec4 outlineBounds = vec4(\n  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,\n  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius\n);\nvec4 clippedBounds = vec4(\n  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),\n  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)\n);\n\nvec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);\n\nposition.xy = mix(bounds.xy, bounds.zw, clippedXY);\n\nuv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);\n\nfloat rad = uTroikaCurveRadius;\nif (rad != 0.0) {\n  float angle = position.x / rad;\n  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);\n  normal.xz = vec2(sin(angle), cos(angle));\n}\n  \nposition = uTroikaOrient * position;\nnormal = uTroikaOrient * normal;\n\nvTroikaGlyphUV = clippedXY.xy;\nvTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);\n\n${''/* NOTE: it seems important to calculate the glyph's bounding texture UVs here in the\n  vertex shader, rather than in the fragment shader, as the latter gives strange artifacts\n  on some glyphs (those in the leftmost texture column) on some systems. The exact reason\n  isn't understood but doing this here, then mix()-ing in the fragment shader, seems to work. */}\nfloat txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;\nvec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;\nvec2 txStartUV = txUvPerSquare * vec2(\n  mod(floor(aTroikaGlyphIndex / 4.0), txCols),\n  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)\n);\nvTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);\nvTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);\n`;\n\n// language=GLSL\nconst FRAGMENT_DEFS = `\nuniform sampler2D uTroikaSDFTexture;\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform float uTroikaSDFExponent;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaFillOpacity;\nuniform float uTroikaOutlineOpacity;\nuniform float uTroikaBlurRadius;\nuniform vec3 uTroikaStrokeColor;\nuniform float uTroikaStrokeWidth;\nuniform float uTroikaStrokeOpacity;\nuniform bool uTroikaSDFDebug;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec2 vTroikaGlyphDimensions;\n\nfloat troikaSdfValueToSignedDistance(float alpha) {\n  // Inverse of exponential encoding in webgl-sdf-generator\n  ${''/* TODO - there's some slight inaccuracy here when dealing with interpolated alpha values; those\n    are linearly interpolated where the encoding is exponential. Look into improving this by rounding\n    to nearest 2 whole texels, decoding those exponential values, and linearly interpolating the result.\n  */}\n  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);\n  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;\n  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);\n  return signedDist;\n}\n\nfloat troikaGlyphUvToSdfValue(vec2 glyphUV) {\n  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);\n  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);\n  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1\n  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;\n}\n\nfloat troikaGlyphUvToDistance(vec2 uv) {\n  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));\n}\n\nfloat troikaGetAADist() {\n  ${''/*\n    When the standard derivatives extension is available, we choose an antialiasing alpha threshold based\n    on the potential change in the SDF's alpha from this fragment to its neighbor. This strategy maximizes \n    readability and edge crispness at all sizes and screen resolutions.\n  */}\n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\n  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;\n  #else\n  return vTroikaGlyphDimensions.x / 64.0;\n  #endif\n}\n\nfloat troikaGetFragDistValue() {\n  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);\n  float distance = troikaGlyphUvToDistance(clampedGlyphUV);\n \n  // Extrapolate distance when outside bounds:\n  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : \n    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n\n  ${''/* \n  // TODO more refined extrapolated distance by adjusting for angle of gradient at edge...\n  // This has potential but currently gives very jagged extensions, maybe due to precision issues?\n  float uvStep = 1.0 / uTroikaSDFGlyphSize;\n  vec2 neighbor1UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  vec2 neighbor2UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * -sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * -sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  float neighbor1Distance = troikaGlyphUvToDistance(neighbor1UV);\n  float neighbor2Distance = troikaGlyphUvToDistance(neighbor2UV);\n  float distToUnclamped = length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n  float distToNeighbor = length((clampedGlyphUV - neighbor1UV) * vTroikaGlyphDimensions);\n  float gradientAngle1 = min(asin(abs(neighbor1Distance - distance) / distToNeighbor), PI / 2.0);\n  float gradientAngle2 = min(asin(abs(neighbor2Distance - distance) / distToNeighbor), PI / 2.0);\n  distance += (cos(gradientAngle1) + cos(gradientAngle2)) / 2.0 * distToUnclamped;\n  */}\n\n  return distance;\n}\n\nfloat troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {\n  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)\n  float alpha = step(-distanceOffset, -distance);\n  #else\n\n  float alpha = smoothstep(\n    distanceOffset + aaDist,\n    distanceOffset - aaDist,\n    distance\n  );\n  #endif\n\n  return alpha;\n}\n`;\n\n// language=GLSL prefix=\"void main() {\" suffix=\"}\"\nconst FRAGMENT_TRANSFORM = `\nfloat aaDist = troikaGetAADist();\nfloat fragDistance = troikaGetFragDistValue();\nfloat edgeAlpha = uTroikaSDFDebug ?\n  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :\n  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));\n\n#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)\nvec4 fillRGBA = gl_FragColor;\nfillRGBA.a *= uTroikaFillOpacity;\nvec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);\nif (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;\ngl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(\n  -uTroikaStrokeWidth - aaDist,\n  -uTroikaStrokeWidth + aaDist,\n  fragDistance\n));\ngl_FragColor.a *= edgeAlpha;\n#endif\n\nif (edgeAlpha == 0.0) {\n  discard;\n}\n`;\n\n\n/**\n * Create a material for rendering text, derived from a baseMaterial\n */\nfunction createTextDerivedMaterial(baseMaterial) {\n  const textMaterial = (0,troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.createDerivedMaterial)(baseMaterial, {\n    chained: true,\n    extensions: {\n      derivatives: true\n    },\n    uniforms: {\n      uTroikaSDFTexture: {value: null},\n      uTroikaSDFTextureSize: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()},\n      uTroikaSDFGlyphSize: {value: 0},\n      uTroikaSDFExponent: {value: 0},\n      uTroikaTotalBounds: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector4(0,0,0,0)},\n      uTroikaClipRect: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector4(0,0,0,0)},\n      uTroikaDistanceOffset: {value: 0},\n      uTroikaOutlineOpacity: {value: 0},\n      uTroikaFillOpacity: {value: 1},\n      uTroikaPositionOffset: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()},\n      uTroikaCurveRadius: {value: 0},\n      uTroikaBlurRadius: {value: 0},\n      uTroikaStrokeWidth: {value: 0},\n      uTroikaStrokeColor: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Color()},\n      uTroikaStrokeOpacity: {value: 1},\n      uTroikaOrient: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Matrix3()},\n      uTroikaUseGlyphColors: {value: true},\n      uTroikaSDFDebug: {value: false}\n    },\n    vertexDefs: VERTEX_DEFS,\n    vertexTransform: VERTEX_TRANSFORM,\n    fragmentDefs: FRAGMENT_DEFS,\n    fragmentColorTransform: FRAGMENT_TRANSFORM,\n    customRewriter({vertexShader, fragmentShader}) {\n      let uDiffuseRE = /\\buniform\\s+vec3\\s+diffuse\\b/;\n      if (uDiffuseRE.test(fragmentShader)) {\n        // Replace all instances of `diffuse` with our varying\n        fragmentShader = fragmentShader\n          .replace(uDiffuseRE, 'varying vec3 vTroikaGlyphColor')\n          .replace(/\\bdiffuse\\b/g, 'vTroikaGlyphColor');\n        // Make sure the vertex shader declares the uniform so we can grab it as a fallback\n        if (!uDiffuseRE.test(vertexShader)) {\n          vertexShader = vertexShader.replace(\n            troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.voidMainRegExp,\n            'uniform vec3 diffuse;\\n$&\\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\\n'\n          );\n        }\n      }\n      return { vertexShader, fragmentShader }\n    }\n  });\n\n  // Force transparency - TODO is this reasonable?\n  textMaterial.transparent = true;\n\n  Object.defineProperties(textMaterial, {\n    isTroikaTextMaterial: {value: true},\n\n    // WebGLShadowMap reverses the side of the shadow material by default, which fails\n    // for planes, so here we force the `shadowSide` to always match the main side.\n    shadowSide: {\n      get() {\n        return this.side\n      },\n      set() {\n        //no-op\n      }\n    }\n  });\n\n  return textMaterial\n}\n\nconst defaultMaterial = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n  color: 0xffffff,\n  side: three__WEBPACK_IMPORTED_MODULE_3__.DoubleSide,\n  transparent: true\n});\nconst defaultStrokeColor = 0x808080;\n\nconst tempMat4 = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Matrix4();\nconst tempVec3a = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst tempVec3b = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst tempArray = [];\nconst origin = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst defaultOrient = '+x+y';\n\nfunction first(o) {\n  return Array.isArray(o) ? o[0] : o\n}\n\nlet getFlatRaycastMesh = () => {\n  const mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(\n    new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1),\n    defaultMaterial\n  );\n  getFlatRaycastMesh = () => mesh;\n  return mesh\n};\nlet getCurvedRaycastMesh = () => {\n  const mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(\n    new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1, 32, 1),\n    defaultMaterial\n  );\n  getCurvedRaycastMesh = () => mesh;\n  return mesh\n};\n\nconst syncStartEvent = { type: 'syncstart' };\nconst syncCompleteEvent = { type: 'synccomplete' };\n\nconst SYNCABLE_PROPS = [\n  'font',\n  'fontSize',\n  'fontStyle',\n  'fontWeight',\n  'lang',\n  'letterSpacing',\n  'lineHeight',\n  'maxWidth',\n  'overflowWrap',\n  'text',\n  'direction',\n  'textAlign',\n  'textIndent',\n  'whiteSpace',\n  'anchorX',\n  'anchorY',\n  'colorRanges',\n  'sdfGlyphSize'\n];\n\nconst COPYABLE_PROPS = SYNCABLE_PROPS.concat(\n  'material',\n  'color',\n  'depthOffset',\n  'clipRect',\n  'curveRadius',\n  'orientation',\n  'glyphGeometryDetail'\n);\n\n/**\n * @class Text\n *\n * A ThreeJS Mesh that renders a string of text on a plane in 3D space using signed distance\n * fields (SDF).\n */\nclass Text extends three__WEBPACK_IMPORTED_MODULE_3__.Mesh {\n  constructor() {\n    const geometry = new GlyphsGeometry();\n    super(geometry, null);\n\n    // === Text layout properties: === //\n\n    /**\n     * @member {string} text\n     * The string of text to be rendered.\n     */\n    this.text = '';\n\n    /**\n     * @member {number|string} anchorX\n     * Defines the horizontal position in the text block that should line up with the local origin.\n     * Can be specified as a numeric x position in local units, a string percentage of the total\n     * text block width e.g. `'25%'`, or one of the following keyword strings: 'left', 'center',\n     * or 'right'.\n     */\n    this.anchorX = 0;\n\n    /**\n     * @member {number|string} anchorY\n     * Defines the vertical position in the text block that should line up with the local origin.\n     * Can be specified as a numeric y position in local units (note: down is negative y), a string\n     * percentage of the total text block height e.g. `'25%'`, or one of the following keyword strings:\n     * 'top', 'top-baseline', 'top-cap', 'top-ex', 'middle', 'bottom-baseline', or 'bottom'.\n     */\n    this.anchorY = 0;\n\n    /**\n     * @member {number} curveRadius\n     * Defines a cylindrical radius along which the text's plane will be curved. Positive numbers put\n     * the cylinder's centerline (oriented vertically) that distance in front of the text, for a concave\n     * curvature, while negative numbers put it behind the text for a convex curvature. The centerline\n     * will be aligned with the text's local origin; you can use `anchorX` to offset it.\n     *\n     * Since each glyph is by default rendered with a simple quad, each glyph remains a flat plane\n     * internally. You can use `glyphGeometryDetail` to add more vertices for curvature inside glyphs.\n     */\n    this.curveRadius = 0;\n\n    /**\n     * @member {string} direction\n     * Sets the base direction for the text. The default value of \"auto\" will choose a direction based\n     * on the text's content according to the bidi spec. A value of \"ltr\" or \"rtl\" will force the direction.\n     */\n    this.direction = 'auto';\n\n    /**\n     * @member {string|null} font\n     * URL of a custom font to be used. Font files can be in .ttf, .otf, or .woff (not .woff2) formats.\n     * Defaults to Noto Sans.\n     */\n    this.font = null; //will use default from TextBuilder\n\n    this.unicodeFontsURL = null; //defaults to CDN\n\n    /**\n     * @member {number} fontSize\n     * The size at which to render the font in local units; corresponds to the em-box height\n     * of the chosen `font`.\n     */\n    this.fontSize = 0.1;\n\n    /**\n     * @member {number|'normal'|'bold'}\n     * The weight of the font. Currently only used for fallback Noto fonts.\n     */\n    this.fontWeight = 'normal';\n\n    /**\n     * @member {'normal'|'italic'}\n     * The style of the font. Currently only used for fallback Noto fonts.\n     */\n    this.fontStyle = 'normal';\n\n    /**\n     * @member {string|null} lang\n     * The language code of this text; can be used for explicitly selecting certain CJK fonts.\n     */\n    this.lang = null;\n\n      /**\n     * @member {number} letterSpacing\n     * Sets a uniform adjustment to spacing between letters after kerning is applied. Positive\n     * numbers increase spacing and negative numbers decrease it.\n     */\n    this.letterSpacing = 0;\n\n    /**\n     * @member {number|string} lineHeight\n     * Sets the height of each line of text, as a multiple of the `fontSize`. Defaults to 'normal'\n     * which chooses a reasonable height based on the chosen font's ascender/descender metrics.\n     */\n    this.lineHeight = 'normal';\n\n    /**\n     * @member {number} maxWidth\n     * The maximum width of the text block, above which text may start wrapping according to the\n     * `whiteSpace` and `overflowWrap` properties.\n     */\n    this.maxWidth = Infinity;\n\n    /**\n     * @member {string} overflowWrap\n     * Defines how text wraps if the `whiteSpace` property is `normal`. Can be either `'normal'`\n     * to break at whitespace characters, or `'break-word'` to allow breaking within words.\n     * Defaults to `'normal'`.\n     */\n    this.overflowWrap = 'normal';\n\n    /**\n     * @member {string} textAlign\n     * The horizontal alignment of each line of text within the overall text bounding box.\n     */\n    this.textAlign = 'left';\n\n    /**\n     * @member {number} textIndent\n     * Indentation for the first character of a line; see CSS `text-indent`.\n     */\n    this.textIndent = 0;\n\n    /**\n     * @member {string} whiteSpace\n     * Defines whether text should wrap when a line reaches the `maxWidth`. Can\n     * be either `'normal'` (the default), to allow wrapping according to the `overflowWrap` property,\n     * or `'nowrap'` to prevent wrapping. Note that `'normal'` here honors newline characters to\n     * manually break lines, making it behave more like `'pre-wrap'` does in CSS.\n     */\n    this.whiteSpace = 'normal';\n\n\n    // === Presentation properties: === //\n\n    /**\n     * @member {THREE.Material} material\n     * Defines a _base_ material to be used when rendering the text. This material will be\n     * automatically replaced with a material derived from it, that adds shader code to\n     * decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing.\n     * By default it will derive from a simple white MeshBasicMaterial, but you can use any\n     * of the other mesh materials to gain other features like lighting, texture maps, etc.\n     *\n     * Also see the `color` shortcut property.\n     */\n    this.material = null;\n\n    /**\n     * @member {string|number|THREE.Color} color\n     * This is a shortcut for setting the `color` of the text's material. You can use this\n     * if you don't want to specify a whole custom `material`. Also, if you do use a custom\n     * `material`, this color will only be used for this particuar Text instance, even if\n     * that same material instance is shared across multiple Text objects.\n     */\n    this.color = null;\n\n    /**\n     * @member {object|null} colorRanges\n     * WARNING: This API is experimental and may change.\n     * This allows more fine-grained control of colors for individual or ranges of characters,\n     * taking precedence over the material's `color`. Its format is an Object whose keys each\n     * define a starting character index for a range, and whose values are the color for each\n     * range. The color value can be a numeric hex color value, a `THREE.Color` object, or\n     * any of the strings accepted by `THREE.Color`.\n     */\n    this.colorRanges = null;\n\n    /**\n     * @member {number|string} outlineWidth\n     * WARNING: This API is experimental and may change.\n     * The width of an outline/halo to be drawn around each text glyph using the `outlineColor` and `outlineOpacity`.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n     * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`, which means\n     * no outline will be drawn unless an `outlineOffsetX/Y` or `outlineBlur` is set.\n     */\n    this.outlineWidth = 0;\n\n    /**\n     * @member {string|number|THREE.Color} outlineColor\n     * WARNING: This API is experimental and may change.\n     * The color of the text outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n     * Defaults to black.\n     */\n    this.outlineColor = 0x000000;\n\n    /**\n     * @member {number} outlineOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n     * Defaults to `1`.\n     */\n    this.outlineOpacity = 1;\n\n    /**\n     * @member {number|string} outlineBlur\n     * WARNING: This API is experimental and may change.\n     * A blur radius applied to the outer edge of the text's outline. If the `outlineWidth` is\n     * zero, the blur will be applied at the glyph edge, like CSS's `text-shadow` blur radius.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n     * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.outlineBlur = 0;\n\n    /**\n     * @member {number|string} outlineOffsetX\n     * WARNING: This API is experimental and may change.\n     * A horizontal offset for the text outline.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.outlineOffsetX = 0;\n\n    /**\n     * @member {number|string} outlineOffsetY\n     * WARNING: This API is experimental and may change.\n     * A vertical offset for the text outline.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.outlineOffsetY = 0;\n\n    /**\n     * @member {number|string} strokeWidth\n     * WARNING: This API is experimental and may change.\n     * The width of an inner stroke drawn inside each text glyph using the `strokeColor` and `strokeOpacity`.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.strokeWidth = 0;\n\n    /**\n     * @member {string|number|THREE.Color} strokeColor\n     * WARNING: This API is experimental and may change.\n     * The color of the text stroke, if `strokeWidth` is greater than zero. Defaults to gray.\n     */\n    this.strokeColor = defaultStrokeColor;\n\n    /**\n     * @member {number} strokeOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the stroke, if `strokeWidth` is greater than zero. Defaults to `1`.\n     */\n    this.strokeOpacity = 1;\n\n    /**\n     * @member {number} fillOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the glyph's fill from 0 to 1. This behaves like the material's `opacity` but allows\n     * giving the fill a different opacity than the `strokeOpacity`. A fillOpacity of `0` makes the\n     * interior of the glyph invisible, leaving just the `strokeWidth`. Defaults to `1`.\n     */\n    this.fillOpacity = 1;\n\n    /**\n     * @member {number} depthOffset\n     * This is a shortcut for setting the material's `polygonOffset` and related properties,\n     * which can be useful in preventing z-fighting when this text is laid on top of another\n     * plane in the scene. Positive numbers are further from the camera, negatives closer.\n     */\n    this.depthOffset = 0;\n\n    /**\n     * @member {Array<number>} clipRect\n     * If specified, defines a `[minX, minY, maxX, maxY]` of a rectangle outside of which all\n     * pixels will be discarded. This can be used for example to clip overflowing text when\n     * `whiteSpace='nowrap'`.\n     */\n    this.clipRect = null;\n\n    /**\n     * @member {string} orientation\n     * Defines the axis plane on which the text should be laid out when the mesh has no extra\n     * rotation transform. It is specified as a string with two axes: the horizontal axis with\n     * positive pointing right, and the vertical axis with positive pointing up. By default this\n     * is '+x+y', meaning the text sits on the xy plane with the text's top toward positive y\n     * and facing positive z. A value of '+x-z' would place it on the xz plane with the text's\n     * top toward negative z and facing positive y.\n     */\n    this.orientation = defaultOrient;\n\n    /**\n     * @member {number} glyphGeometryDetail\n     * Controls number of vertical/horizontal segments that make up each glyph's rectangular\n     * plane. Defaults to 1. This can be increased to provide more geometrical detail for custom\n     * vertex shader effects, for example.\n     */\n    this.glyphGeometryDetail = 1;\n\n    /**\n     * @member {number|null} sdfGlyphSize\n     * The size of each glyph's SDF (signed distance field) used for rendering. This must be a\n     * power-of-two number. Defaults to 64 which is generally a good balance of size and quality\n     * for most fonts. Larger sizes can improve the quality of glyph rendering by increasing\n     * the sharpness of corners and preventing loss of very thin lines, at the expense of\n     * increased memory footprint and longer SDF generation time.\n     */\n    this.sdfGlyphSize = null;\n\n    /**\n     * @member {boolean} gpuAccelerateSDF\n     * When `true`, the SDF generation process will be GPU-accelerated with WebGL when possible,\n     * making it much faster especially for complex glyphs, and falling back to a JavaScript version\n     * executed in web workers when support isn't available. It should automatically detect support,\n     * but it's still somewhat experimental, so you can set it to `false` to force it to use the JS\n     * version if you encounter issues with it.\n     */\n    this.gpuAccelerateSDF = true;\n\n    this.debugSDF = false;\n  }\n\n  /**\n   * Updates the text rendering according to the current text-related configuration properties.\n   * This is an async process, so you can pass in a callback function to be executed when it\n   * finishes.\n   * @param {function} [callback]\n   */\n  sync(callback) {\n    if (this._needsSync) {\n      this._needsSync = false;\n\n      // If there's another sync still in progress, queue\n      if (this._isSyncing) {\n        (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);\n      } else {\n        this._isSyncing = true;\n        this.dispatchEvent(syncStartEvent);\n\n        getTextRenderInfo({\n          text: this.text,\n          font: this.font,\n          lang: this.lang,\n          fontSize: this.fontSize || 0.1,\n          fontWeight: this.fontWeight || 'normal',\n          fontStyle: this.fontStyle || 'normal',\n          letterSpacing: this.letterSpacing || 0,\n          lineHeight: this.lineHeight || 'normal',\n          maxWidth: this.maxWidth,\n          direction: this.direction || 'auto',\n          textAlign: this.textAlign,\n          textIndent: this.textIndent,\n          whiteSpace: this.whiteSpace,\n          overflowWrap: this.overflowWrap,\n          anchorX: this.anchorX,\n          anchorY: this.anchorY,\n          colorRanges: this.colorRanges,\n          includeCaretPositions: true, //TODO parameterize\n          sdfGlyphSize: this.sdfGlyphSize,\n          gpuAccelerateSDF: this.gpuAccelerateSDF,\n          unicodeFontsURL: this.unicodeFontsURL,\n        }, textRenderInfo => {\n          this._isSyncing = false;\n\n          // Save result for later use in onBeforeRender\n          this._textRenderInfo = textRenderInfo;\n\n          // Update the geometry attributes\n          this.geometry.updateGlyphs(\n            textRenderInfo.glyphBounds,\n            textRenderInfo.glyphAtlasIndices,\n            textRenderInfo.blockBounds,\n            textRenderInfo.chunkedBounds,\n            textRenderInfo.glyphColors\n          );\n\n          // If we had extra sync requests queued up, kick it off\n          const queued = this._queuedSyncs;\n          if (queued) {\n            this._queuedSyncs = null;\n            this._needsSync = true;\n            this.sync(() => {\n              queued.forEach(fn => fn && fn());\n            });\n          }\n\n          this.dispatchEvent(syncCompleteEvent);\n          if (callback) {\n            callback();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Initiate a sync if needed - note it won't complete until next frame at the\n   * earliest so if possible it's a good idea to call sync() manually as soon as\n   * all the properties have been set.\n   * @override\n   */\n  onBeforeRender(renderer, scene, camera, geometry, material, group) {\n    this.sync();\n\n    // This may not always be a text material, e.g. if there's a scene.overrideMaterial present\n    if (material.isTroikaTextMaterial) {\n      this._prepareForRender(material);\n    }\n\n    // We need to force the material to FrontSide to avoid the double-draw-call performance hit\n    // introduced in Three.js r130: https://github.com/mrdoob/three.js/pull/21967 - The sidedness\n    // is instead applied via drawRange in the GlyphsGeometry.\n    material._hadOwnSide = material.hasOwnProperty('side');\n    this.geometry.setSide(material._actualSide = material.side);\n    material.side = three__WEBPACK_IMPORTED_MODULE_3__.FrontSide;\n  }\n\n  onAfterRender(renderer, scene, camera, geometry, material, group) {\n    // Restore original material side\n    if (material._hadOwnSide) {\n      material.side = material._actualSide;\n    } else {\n      delete material.side; // back to inheriting from base material\n    }\n  }\n\n  /**\n   * Shortcut to dispose the geometry specific to this instance.\n   * Note: we don't also dispose the derived material here because if anything else is\n   * sharing the same base material it will result in a pause next frame as the program\n   * is recompiled. Instead users can dispose the base material manually, like normal,\n   * and we'll also dispose the derived material at that time.\n   */\n  dispose() {\n    this.geometry.dispose();\n  }\n\n  /**\n   * @property {TroikaTextRenderInfo|null} textRenderInfo\n   * @readonly\n   * The current processed rendering data for this TextMesh, returned by the TextBuilder after\n   * a `sync()` call. This will be `null` initially, and may be stale for a short period until\n   * the asynchrous `sync()` process completes.\n   */\n  get textRenderInfo() {\n    return this._textRenderInfo || null\n  }\n\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n  get material() {\n    let derivedMaterial = this._derivedMaterial;\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n      derivedMaterial = this._derivedMaterial = createTextDerivedMaterial(baseMaterial);\n      // dispose the derived material when its base material is disposed:\n      baseMaterial.addEventListener('dispose', function onDispose() {\n        baseMaterial.removeEventListener('dispose', onDispose);\n        derivedMaterial.dispose();\n      });\n    }\n    // If text outline is configured, render it as a preliminary draw using Three's multi-material\n    // feature (see GlyphsGeometry which sets up `groups` for this purpose) Doing it with multi\n    // materials ensures the layers are always rendered consecutively in a consistent order.\n    // Each layer will trigger onBeforeRender with the appropriate material.\n    if (this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {\n      let outlineMaterial = derivedMaterial._outlineMtl;\n      if (!outlineMaterial) {\n        outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {\n          id: {value: derivedMaterial.id + 0.1}\n        });\n        outlineMaterial.isTextOutlineMaterial = true;\n        outlineMaterial.depthWrite = false;\n        outlineMaterial.map = null; //???\n        derivedMaterial.addEventListener('dispose', function onDispose() {\n          derivedMaterial.removeEventListener('dispose', onDispose);\n          outlineMaterial.dispose();\n        });\n      }\n      return [\n        outlineMaterial,\n        derivedMaterial\n      ]\n    } else {\n      return derivedMaterial\n    }\n  }\n  set material(baseMaterial) {\n    if (baseMaterial && baseMaterial.isTroikaTextMaterial) { //prevent double-derivation\n      this._derivedMaterial = baseMaterial;\n      this._baseMaterial = baseMaterial.baseMaterial;\n    } else {\n      this._baseMaterial = baseMaterial;\n    }\n  }\n\n  get glyphGeometryDetail() {\n    return this.geometry.detail\n  }\n  set glyphGeometryDetail(detail) {\n    this.geometry.detail = detail;\n  }\n\n  get curveRadius() {\n    return this.geometry.curveRadius\n  }\n  set curveRadius(r) {\n    this.geometry.curveRadius = r;\n  }\n\n  // Create and update material for shadows upon request:\n  get customDepthMaterial() {\n    return first(this.material).getDepthMaterial()\n  }\n  get customDistanceMaterial() {\n    return first(this.material).getDistanceMaterial()\n  }\n\n  _prepareForRender(material) {\n    const isOutline = material.isTextOutlineMaterial;\n    const uniforms = material.uniforms;\n    const textInfo = this.textRenderInfo;\n    if (textInfo) {\n      const {sdfTexture, blockBounds} = textInfo;\n      uniforms.uTroikaSDFTexture.value = sdfTexture;\n      uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);\n      uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;\n      uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;\n      uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);\n      uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;\n\n      let distanceOffset = 0;\n      let blurRadius = 0;\n      let strokeWidth = 0;\n      let fillOpacity;\n      let strokeOpacity;\n      let strokeColor;\n      let offsetX = 0;\n      let offsetY = 0;\n\n      if (isOutline) {\n        let {outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity} = this;\n        distanceOffset = this._parsePercent(outlineWidth) || 0;\n        blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);\n        fillOpacity = outlineOpacity;\n        offsetX = this._parsePercent(outlineOffsetX) || 0;\n        offsetY = this._parsePercent(outlineOffsetY) || 0;\n      } else {\n        strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);\n        if (strokeWidth) {\n          strokeColor = this.strokeColor;\n          uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);\n          strokeOpacity = this.strokeOpacity;\n          if (strokeOpacity == null) strokeOpacity = 1;\n        }\n        fillOpacity = this.fillOpacity;\n      }\n\n      uniforms.uTroikaDistanceOffset.value = distanceOffset;\n      uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);\n      uniforms.uTroikaBlurRadius.value = blurRadius;\n      uniforms.uTroikaStrokeWidth.value = strokeWidth;\n      uniforms.uTroikaStrokeOpacity.value = strokeOpacity;\n      uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;\n      uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;\n\n      let clipRect = this.clipRect;\n      if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {\n        uniforms.uTroikaClipRect.value.fromArray(clipRect);\n      } else {\n        // no clipping - choose a finite rect that shouldn't ever be reached by overflowing glyphs or outlines\n        const pad = (this.fontSize || 0.1) * 100;\n        uniforms.uTroikaClipRect.value.set(\n          blockBounds[0] - pad,\n          blockBounds[1] - pad,\n          blockBounds[2] + pad,\n          blockBounds[3] + pad\n        );\n      }\n      this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);\n    }\n    uniforms.uTroikaSDFDebug.value = !!this.debugSDF;\n    material.polygonOffset = !!this.depthOffset;\n    material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;\n\n    // Shortcut for setting material color via `color` prop on the mesh; this is\n    // applied only to the derived material to avoid mutating a shared base material.\n    const color = isOutline ? (this.outlineColor || 0) : this.color;\n\n    if (color == null) {\n      delete material.color; //inherit from base\n    } else {\n      const colorObj = material.hasOwnProperty('color') ? material.color : (material.color = new three__WEBPACK_IMPORTED_MODULE_3__.Color());\n      if (color !== colorObj._input || typeof color === 'object') {\n        colorObj.set(colorObj._input = color);\n      }\n    }\n\n    // base orientation\n    let orient = this.orientation || defaultOrient;\n    if (orient !== material._orientation) {\n      let rotMat = uniforms.uTroikaOrient.value;\n      orient = orient.replace(/[^-+xyz]/g, '');\n      let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);\n      if (match) {\n        let [, hSign, hAxis, vSign, vAxis] = match;\n        tempVec3a.set(0, 0, 0)[hAxis] = hSign === '-' ? 1 : -1;\n        tempVec3b.set(0, 0, 0)[vAxis] = vSign === '-' ? -1 : 1;\n        tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);\n        rotMat.setFromMatrix4(tempMat4);\n      } else {\n        rotMat.identity();\n      }\n      material._orientation = orient;\n    }\n  }\n\n  _parsePercent(value) {\n    if (typeof value === 'string') {\n      let match = value.match(/^(-?[\\d.]+)%$/);\n      let pct = match ? parseFloat(match[1]) : NaN;\n      value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;\n    }\n    return value\n  }\n\n  /**\n   * Translate a point in local space to an x/y in the text plane.\n   */\n  localPositionToTextCoords(position, target = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()) {\n    target.copy(position); //simple non-curved case is 1:1\n    const r = this.curveRadius;\n    if (r) { //flatten the curve\n      target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);\n    }\n    return target\n  }\n\n  /**\n   * Translate a point in world space to an x/y in the text plane.\n   */\n  worldPositionToTextCoords(position, target = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()) {\n    tempVec3a.copy(position);\n    return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target)\n  }\n\n  /**\n   * @override Custom raycasting to test against the whole text block's max rectangular bounds\n   * TODO is there any reason to make this more granular, like within individual line or glyph rects?\n   */\n  raycast(raycaster, intersects) {\n    const {textRenderInfo, curveRadius} = this;\n    if (textRenderInfo) {\n      const bounds = textRenderInfo.blockBounds;\n      const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();\n      const geom = raycastMesh.geometry;\n      const {position, uv} = geom.attributes;\n      for (let i = 0; i < uv.count; i++) {\n        let x = bounds[0] + (uv.getX(i) * (bounds[2] - bounds[0]));\n        const y = bounds[1] + (uv.getY(i) * (bounds[3] - bounds[1]));\n        let z = 0;\n        if (curveRadius) {\n          z = curveRadius - Math.cos(x / curveRadius) * curveRadius;\n          x = Math.sin(x / curveRadius) * curveRadius;\n        }\n        position.setXYZ(i, x, y, z);\n      }\n      geom.boundingSphere = this.geometry.boundingSphere;\n      geom.boundingBox = this.geometry.boundingBox;\n      raycastMesh.matrixWorld = this.matrixWorld;\n      raycastMesh.material.side = this.material.side;\n      tempArray.length = 0;\n      raycastMesh.raycast(raycaster, tempArray);\n      for (let i = 0; i < tempArray.length; i++) {\n        tempArray[i].object = this;\n        intersects.push(tempArray[i]);\n      }\n    }\n  }\n\n  copy(source) {\n    // Prevent copying the geometry reference so we don't end up sharing attributes between instances\n    const geom = this.geometry;\n    super.copy(source);\n    this.geometry = geom;\n\n    COPYABLE_PROPS.forEach(prop => {\n      this[prop] = source[prop];\n    });\n    return this\n  }\n\n  clone() {\n    return new this.constructor().copy(this)\n  }\n}\n\n\n// Create setters for properties that affect text layout:\nSYNCABLE_PROPS.forEach(prop => {\n  const privateKey = '_private_' + prop;\n  Object.defineProperty(Text.prototype, prop, {\n    get() {\n      return this[privateKey]\n    },\n    set(value) {\n      if (value !== this[privateKey]) {\n        this[privateKey] = value;\n        this._needsSync = true;\n      }\n    }\n  });\n});\n\n//=== Utility functions for dealing with carets and selection ranges ===//\n\n/**\n * @typedef {object} TextCaret\n * @property {number} x - x position of the caret\n * @property {number} y - y position of the caret's bottom\n * @property {number} height - height of the caret\n * @property {number} charIndex - the index in the original input string of this caret's target\n *   character; the caret will be for the position _before_ that character.\n */\n\n/**\n * Given a local x/y coordinate in the text block plane, find the nearest caret position.\n * @param {TroikaTextRenderInfo} textRenderInfo - a result object from TextBuilder#getTextRenderInfo\n * @param {number} x\n * @param {number} y\n * @return {TextCaret | null}\n */\nfunction getCaretAtPoint(textRenderInfo, x, y) {\n  let closestCaret = null;\n  const rows = groupCaretsByRow(textRenderInfo);\n\n  // Find nearest row by y first\n  let closestRow = null;\n  rows.forEach(row => {\n    if (!closestRow || Math.abs(y - (row.top + row.bottom) / 2) < Math.abs(y - (closestRow.top + closestRow.bottom) / 2)) {\n      closestRow = row;\n    }\n  });\n\n  // Then find closest caret by x within that row\n  closestRow.carets.forEach(caret => {\n    if (!closestCaret || Math.abs(x - caret.x) < Math.abs(x - closestCaret.x)) {\n      closestCaret = caret;\n    }\n  });\n  return closestCaret\n}\n\n\nconst _rectsCache = new WeakMap();\n\n/**\n * Given start and end character indexes, return a list of rectangles covering all the\n * characters within that selection.\n * @param {TroikaTextRenderInfo} textRenderInfo\n * @param {number} start - index of the first char in the selection\n * @param {number} end - index of the first char after the selection\n * @return {Array<{left, top, right, bottom}> | null}\n */\nfunction getSelectionRects(textRenderInfo, start, end) {\n  let rects;\n  if (textRenderInfo) {\n    // Check cache - textRenderInfo is frozen so it's safe to cache based on it\n    let prevResult = _rectsCache.get(textRenderInfo);\n    if (prevResult && prevResult.start === start && prevResult.end === end) {\n      return prevResult.rects\n    }\n\n    const {caretPositions} = textRenderInfo;\n\n    // Normalize\n    if (end < start) {\n      const s = start;\n      start = end;\n      end = s;\n    }\n    start = Math.max(start, 0);\n    end = Math.min(end, caretPositions.length + 1);\n\n    // Build list of rects, expanding the current rect for all characters in a run and starting\n    // a new rect whenever reaching a new line or a new bidi direction\n    rects = [];\n    let currentRect = null;\n    for (let i = start; i < end; i++) {\n      const x1 = caretPositions[i * 4];\n      const x2 = caretPositions[i * 4 + 1];\n      const left = Math.min(x1, x2);\n      const right = Math.max(x1, x2);\n      const bottom = caretPositions[i * 4 + 2];\n      const top = caretPositions[i * 4 + 3];\n      if (!currentRect || bottom !== currentRect.bottom || top !== currentRect.top || left > currentRect.right || right < currentRect.left) {\n        currentRect = {\n          left: Infinity,\n          right: -Infinity,\n          bottom,\n          top,\n        };\n        rects.push(currentRect);\n      }\n      currentRect.left = Math.min(left, currentRect.left);\n      currentRect.right = Math.max(right, currentRect.right);\n    }\n\n    // Merge any overlapping rects, e.g. those formed by adjacent bidi runs\n    rects.sort((a, b) => b.bottom - a.bottom || a.left - b.left);\n    for (let i = rects.length - 1; i-- > 0;) {\n      const rectA = rects[i];\n      const rectB = rects[i + 1];\n      if (rectA.bottom === rectB.bottom && rectA.top === rectB.top && rectA.left <= rectB.right && rectA.right >= rectB.left) {\n        rectB.left = Math.min(rectB.left, rectA.left);\n        rectB.right = Math.max(rectB.right, rectA.right);\n        rects.splice(i, 1);\n      }\n    }\n\n    _rectsCache.set(textRenderInfo, {start, end, rects});\n  }\n  return rects\n}\n\nconst _caretsByRowCache = new WeakMap();\n\n/**\n * Group a set of carets by row of text, caching the result. A single row of text may contain carets of\n * differing positions/heights if it has multiple fonts, and they may overlap slightly across rows, so this\n * uses an assumption of \"at least overlapping by half\" to put them in the same row.\n * @return Array<{bottom: number, top: number, carets: TextCaret[]}>\n */\nfunction groupCaretsByRow(textRenderInfo) {\n  // textRenderInfo is frozen so it's safe to cache based on it\n  let rows = _caretsByRowCache.get(textRenderInfo);\n  if (!rows) {\n    rows = [];\n    const {caretPositions} = textRenderInfo;\n    let curRow;\n\n    const visitCaret = (x, bottom, top, charIndex) => {\n      // new row if not overlapping by at least half\n      if (!curRow || (top < (curRow.top + curRow.bottom) / 2)) {\n        rows.push(curRow = {bottom, top, carets: []});\n      }\n      // expand vertical limits if necessary\n      if (top > curRow.top) curRow.top = top;\n      if (bottom < curRow.bottom) curRow.bottom = bottom;\n      curRow.carets.push({\n        x,\n        y: bottom,\n        height: top - bottom,\n        charIndex,\n      });\n    };\n\n    let i = 0;\n    for (; i < caretPositions.length; i += 4) {\n      visitCaret(caretPositions[i], caretPositions[i + 2], caretPositions[i + 3], i / 4);\n    }\n    // Add one more caret after the final char\n    visitCaret(caretPositions[i - 3], caretPositions[i - 2], caretPositions[i - 1], i / 4);\n  }\n  _caretsByRowCache.set(textRenderInfo, rows);\n  return rows\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL3Ryb2lrYS10aHJlZS10ZXh0L2Rpc3QvdHJvaWthLXRocmVlLXRleHQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb1I7QUFDMU07QUFDckI7QUFDbkI7QUFDeUM7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtFQUFrRSxPQUFPLGtCQUFrQixpQ0FBaUMsK0JBQStCLFFBQVEsOENBQThDLHNCQUFzQixLQUFLLGlCQUFpQixJQUFJLEtBQUssc0JBQXNCLCtCQUErQixTQUFTLDBCQUEwQix5QkFBeUIsaUJBQWlCLHNCQUFzQix3QkFBd0IsMEVBQTBFLCtIQUErSCxrQkFBa0IsS0FBSyxLQUFLLElBQUksS0FBSyx5QkFBeUIsMEJBQTBCLHNCQUFzQixLQUFLLHNCQUFzQixXQUFXLG9CQUFvQixRQUFRLFdBQVcsS0FBSyxXQUFXLG9FQUFvRSxTQUFTLDRCQUE0QixrREFBa0QsSUFBSSxLQUFLLHlCQUF5QiwwQkFBMEIsc0JBQXNCLDJDQUEyQyxXQUFXLFFBQVEsd0JBQXdCLGlEQUFpRCwyQkFBMkIsbUNBQW1DLHVCQUF1QixtQ0FBbUMsd0JBQXdCLGtDQUFrQyx5QkFBeUIsbUNBQW1DLDBCQUEwQixvQ0FBb0MsNkJBQTZCLGlCQUFpQixJQUFJLHVDQUF1QyxTQUFTLHdCQUF3QixvQ0FBb0MsMEJBQTBCLDhEQUE4RCwyQkFBMkIsaUJBQWlCLElBQUksbUNBQW1DLFNBQVMsNkJBQTZCLGlCQUFpQixJQUFJLEtBQUssdUJBQXVCLDJCQUEyQixTQUFTLDJHQUEyRyxtQkFBbUIsZ0VBQWdFLDJCQUEyQixpQkFBaUIsSUFBSSxtQkFBbUIsU0FBUyxnQ0FBZ0MsaUJBQWlCLElBQUksd0NBQXdDLFNBQVMsbUJBQW1CLG9JQUFvSSxXQUFXLG1DQUFtQyxpQkFBaUIsS0FBSyxzQkFBc0Isd0JBQXdCLEtBQUssd0JBQXdCLEtBQUssd0JBQXdCLG1KQUFtSix3Q0FBd0MsMENBQTBDLEtB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Q0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsZ0JBQWdCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxrQkFBa0I7QUFDdkQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFpRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXdOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90cm9pa2EtdGhyZWUtdGV4dC9kaXN0L3Ryb2lrYS10aHJlZS10ZXh0LmVzbS5qcz9iMDNhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRleHR1cmUsIExpbmVhckZpbHRlciwgQ29sb3IsIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LCBTcGhlcmUsIEJveDMsIEJhY2tTaWRlLCBEb3VibGVTaWRlLCBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUsIFBsYW5lR2VvbWV0cnksIEJ1ZmZlckdlb21ldHJ5LCBGbG9hdDMyQnVmZmVyQXR0cmlidXRlLCBWZWN0b3IyLCBWZWN0b3I0LCBNYXRyaXgzLCBNZXNoLCBGcm9udFNpZGUsIE1lc2hCYXNpY01hdGVyaWFsLCBNYXRyaXg0LCBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgZGVmaW5lV29ya2VyTW9kdWxlLCB0ZXJtaW5hdGVXb3JrZXIgfSBmcm9tICd0cm9pa2Etd29ya2VyLXV0aWxzJztcbmltcG9ydCBjcmVhdGVTREZHZW5lcmF0b3IgZnJvbSAnd2ViZ2wtc2RmLWdlbmVyYXRvcic7XG5pbXBvcnQgYmlkaUZhY3RvcnkgZnJvbSAnYmlkaS1qcyc7XG5pbXBvcnQgeyBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwsIHZvaWRNYWluUmVnRXhwIH0gZnJvbSAndHJvaWthLXRocmVlLXV0aWxzJztcblxuLyohXG5DdXN0b20gYnVpbGQgb2YgVHlwci50cyAoaHR0cHM6Ly9naXRodWIuY29tL2ZyZWRsaTc0L1R5cHIudHMpIGZvciB1c2UgaW4gVHJvaWthIHRleHQgcmVuZGVyaW5nLlxuT3JpZ2luYWwgTUlUIGxpY2Vuc2UgYXBwbGllczogaHR0cHM6Ly9naXRodWIuY29tL2ZyZWRsaTc0L1R5cHIudHMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuKi9cbmZ1bmN0aW9uIHR5cHJGYWN0b3J5KCl7cmV0dXJuIFwidW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3cmJihzZWxmLndpbmRvdz1zZWxmKSxmdW5jdGlvbihyKXt2YXIgZT17cGFyc2U6ZnVuY3Rpb24ocil7dmFyIHQ9ZS5fYmluLGE9bmV3IFVpbnQ4QXJyYXkocik7aWYoXCJ0dGNmXCI9PXQucmVhZEFTQ0lJKGEsMCw0KSl7dmFyIG49NDt0LnJlYWRVc2hvcnQoYSxuKSxuKz0yLHQucmVhZFVzaG9ydChhLG4pLG4rPTI7dmFyIG89dC5yZWFkVWludChhLG4pO24rPTQ7Zm9yKHZhciBzPVtdLGk9MDtpPG87aSsrKXt2YXIgaD10LnJlYWRVaW50KGEsbik7bis9NCxzLnB1c2goZS5fcmVhZEZvbnQoYSxoKSk7fXJldHVybiBzfXJldHVybiBbZS5fcmVhZEZvbnQoYSwwKV19LF9yZWFkRm9udDpmdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQ7YS5yZWFkRml4ZWQocix0KSx0Kz00O3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTI7Zm9yKHZhciBzPVtcImNtYXBcIixcImhlYWRcIixcImhoZWFcIixcIm1heHBcIixcImhtdHhcIixcIm5hbWVcIixcIk9TLzJcIixcInBvc3RcIixcImxvY2FcIixcImdseWZcIixcImtlcm5cIixcIkNGRiBcIixcIkdERUZcIixcIkdQT1NcIixcIkdTVUJcIixcIlNWRyBcIl0saT17X2RhdGE6cixfb2Zmc2V0Om59LGg9e30sZD0wO2Q8bztkKyspe3ZhciBmPWEucmVhZEFTQ0lJKHIsdCw0KTt0Kz00LGEucmVhZFVpbnQocix0KSx0Kz00O3ZhciB1PWEucmVhZFVpbnQocix0KTt0Kz00O3ZhciBsPWEucmVhZFVpbnQocix0KTt0Kz00LGhbZl09e29mZnNldDp1LGxlbmd0aDpsfTt9Zm9yKGQ9MDtkPHMubGVuZ3RoO2QrKyl7dmFyIHY9c1tkXTtoW3ZdJiYoaVt2LnRyaW0oKV09ZVt2LnRyaW0oKV0ucGFyc2UocixoW3ZdLm9mZnNldCxoW3ZdLmxlbmd0aCxpKSk7fXJldHVybiBpfSxfdGFiT2Zmc2V0OmZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49ZS5fYmluLG89bi5yZWFkVXNob3J0KHIsYSs0KSxzPWErMTIsaT0wO2k8bztpKyspe3ZhciBoPW4ucmVhZEFTQ0lJKHIscyw0KTtzKz00LG4ucmVhZFVpbnQocixzKSxzKz00O3ZhciBkPW4ucmVhZFVpbnQocixzKTtpZihzKz00LG4ucmVhZFVpbnQocixzKSxzKz00LGg9PXQpcmV0dXJuIGR9cmV0dXJuIDB9fTtlLl9iaW49e3JlYWRGaXhlZDpmdW5jdGlvbihyLGUpe3JldHVybiAocltlXTw8OHxyW2UrMV0pKyhyW2UrMl08PDh8cltlKzNdKS82NTU0MH0scmVhZEYyZG90MTQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLnJlYWRTaG9ydChyLHQpLzE2Mzg0fSxyZWFkSW50OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIGUuX2Jpbi5fdmlldyhyKS5nZXRJbnQzMih0KX0scmVhZEludDg6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLl92aWV3KHIpLmdldEludDgodCl9LHJlYWRTaG9ydDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0SW50MTYodCl9LHJlYWRVc2hvcnQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLl92aWV3KHIpLmdldFVpbnQxNih0KX0scmVhZFVzaG9ydHM6ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj1bXSxvPTA7bzxhO28rKyluLnB1c2goZS5fYmluLnJlYWRVc2hvcnQocix0KzIqbykpO3JldHVybiBufSxyZWFkVWludDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0VWludDMyKHQpfSxyZWFkVWludDY0OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIDQyOTQ5NjcyOTYqZS5fYmluLnJlYWRVaW50KHIsdCkrZS5fYmluLnJlYWRVaW50KHIsdCs0KX0scmVhZEFTQ0lJOmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9XCJcIixuPTA7bjx0O24rKylhKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHJbZStuXSk7cmV0dXJuIGF9LHJlYWRVbmljb2RlOmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9XCJcIixuPTA7bjx0O24rKyl7dmFyIG89cltlKytdPDw4fHJbZSsrXTthKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pO31yZXR1cm4gYX0sX3RkZWM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93LlRleHREZWNvZGVyP25ldyB3aW5kb3cuVGV4dERlY29kZXI6bnVsbCxyZWFkVVRGODpmdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLl90ZGVjO3JldHVybiBuJiYwPT10JiZhPT1yLmxlbmd0aD9uLmRlY29kZShyKTplLl9iaW4ucmVhZEFTQ0lJKHIsdCxhKX0scmVhZEJ5dGVzOmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9W10sbj0wO248dDtuKyspYS5wdXNoKHJbZStuXSk7cmV0dXJuIGF9LHJlYWRBU0NJSUFycmF5OmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9W10sbj0wO248dDtuKyspYS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUocltlK25dKSk7cmV0dXJuIGF9LF92aWV3OmZ1bmN0aW9uKHIpe3JldHVybiByLl9kYXRhVmlld3x8KHIuX2RhdGFWaWV3PXIuYnVmZmVyP25ldyBEYXRhVmlldyhyLmJ1ZmZlcixyLmJ5dGVPZmZzZXQsci5ieXRlTGVuZ3RoKTpuZXcgRGF0YVZpZXcobmV3IFVpbnQ4QXJyYXkocikuYnVmZmVyKSl9fSxlLl9sY3RmPXt9LGUuX2xjdGYucGFyc2U9ZnVuY3Rpb24ocix0LGEsbixvKXt2YXIgcz1lLl9iaW4saT17fSxoPXQ7cy5yZWFkRml4ZWQocix0KSx0Kz00O3ZhciBkPXMucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9cy5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgdT1zLnJlYWRVc2hvcnQocix0KTtyZXR1cm4gdCs9MixpLnNjcmlwdExpc3Q9ZS5fbGN0Zi5yZWFkU2NyaXB0TGlzdChyLGgrZCksaS5mZWF0dXJlTGlzdD1lLl9sY3RmLnJlYWRGZWF0dXJlTGlzdChyLGgrZiksaS5sb29rdXBMaXN0PWUuX2xjdGYucmVhZExvb2t1cExpc3QocixoK3UsbyksaX0sZS5fbGN0Zi5yZWFkTG9va3VwTGlzdD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89dCxzPVtdLGk9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGg9MDtoPGk7aCsrKXt2YXIgZD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBmPWUuX2xjdGYucmVhZExvb2t1cFRhYmxlKHIsbytkLGEpO3MucHVzaChmKTt9cmV0dXJuIHN9LGUuX2xjdGYucmVhZExvb2t1cFRhYmxlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz10LHM9e3RhYnM6W119O3MubHR5cGU9bi5yZWFkVXNob3J0KHIsdCksdCs9MixzLmZsYWc9bi5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgaT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD1zLmx0eXBlLGQ9MDtkPGk7ZCsrKXt2YXIgZj1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB1PWEocixoLG8rZixzKTtzLnRhYnMucHVzaCh1KTt9cmV0dXJuIHN9LGUuX2xjdGYubnVtT2ZPbmVzPWZ1bmN0aW9uKHIpe2Zvcih2YXIgZT0wLHQ9MDt0PDMyO3QrKykwIT0ocj4+PnQmMSkmJmUrKztyZXR1cm4gZX0sZS5fbGN0Zi5yZWFkQ2xhc3NEZWY9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj1bXSxvPWEucmVhZFVzaG9ydChyLHQpO2lmKHQrPTIsMT09byl7dmFyIHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD0wO2g8aTtoKyspbi5wdXNoKHMraCksbi5wdXNoKHMraCksbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO31pZigyPT1vKXt2YXIgZD1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2ZvcihoPTA7aDxkO2grKyluLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTIsbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yLG4ucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9Mjt9cmV0dXJuIG59LGUuX2xjdGYuZ2V0SW50ZXJ2YWw9ZnVuY3Rpb24ocixlKXtmb3IodmFyIHQ9MDt0PHIubGVuZ3RoO3QrPTMpe3ZhciBhPXJbdF0sbj1yW3QrMV07aWYoclt0KzJdLGE8PWUmJmU8PW4pcmV0dXJuIHR9cmV0dXJuIC0xfSxlLl9sY3RmLnJlYWRDb3ZlcmFnZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O24uZm10PWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7cmV0dXJuIHQrPTIsMT09bi5mbXQmJihuLnRhYj1hLnJlYWRVc2hvcnRzKHIsdCxvKSksMj09bi5mbXQmJihuLnRhYj1hLnJlYWRVc2hvcnRzKHIsdCwzKm8pKSxufSxlLl9sY3RmLmNvdmVyYWdlSW5kZXg9ZnVuY3Rpb24ocix0KXt2YXIgYT1yLnRhYjtpZigxPT1yLmZtdClyZXR1cm4gYS5pbmRleE9mKHQpO2lmKDI9PXIuZm10KXt2YXIgbj1lLl9sY3RmLmdldEludGVydmFsKGEsdCk7aWYoLTEhPW4pcmV0dXJuIGFbbisyXSsodC1hW25dKX1yZXR1cm4gLTF9LGUuX2xjdGYucmVhZEZlYXR1cmVMaXN0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPVtdLHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hLnJlYWRBU0NJSShyLHQsNCk7dCs9NDt2YXIgZD1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBmPWUuX2xjdGYucmVhZEZlYXR1cmVUYWJsZShyLG4rZCk7Zi50YWc9aC50cmltKCksby5wdXNoKGYpO31yZXR1cm4gb30sZS5fbGN0Zi5yZWFkRmVhdHVyZVRhYmxlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9LHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixzPjAmJihvLmZlYXR1cmVQYXJhbXM9bitzKTt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8udGFiPVtdO2Zvcih2YXIgaD0wO2g8aTtoKyspby50YWIucHVzaChhLnJlYWRVc2hvcnQocix0KzIqaCkpO3JldHVybiBvfSxlLl9sY3RmLnJlYWRTY3JpcHRMaXN0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9LHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hLnJlYWRBU0NJSShyLHQsNCk7dCs9NDt2YXIgZD1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG9baC50cmltKCldPWUuX2xjdGYucmVhZFNjcmlwdFRhYmxlKHIsbitkKTt9cmV0dXJuIG99LGUuX2xjdGYucmVhZFNjcmlwdFRhYmxlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9LHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixzPjAmJihvLmRlZmF1bHQ9ZS5fbGN0Zi5yZWFkTGFuZ1N5c1RhYmxlKHIsbitzKSk7dmFyIGk9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGg9MDtoPGk7aCsrKXt2YXIgZD1hLnJlYWRBU0NJSShyLHQsNCk7dCs9NDt2YXIgZj1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG9bZC50cmltKCldPWUuX2xjdGYucmVhZExhbmdTeXNUYWJsZShyLG4rZik7fXJldHVybiBvfSxlLl9sY3RmLnJlYWRMYW5nU3lzVGFibGU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17fTthLnJlYWRVc2hvcnQocix0KSx0Kz0yLG4ucmVxRmVhdHVyZT1hLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3JldHVybiB0Kz0yLG4uZmVhdHVyZXM9YS5yZWFkVXNob3J0cyhyLHQsbyksbn0sZS5DRkY9e30sZS5DRkYucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2Jpbjsocj1uZXcgVWludDhBcnJheShyLmJ1ZmZlcix0LGEpKVt0PTBdLHJbKyt0XSxyWysrdF0sclsrK3RdLHQrKzt2YXIgbz1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsbyk7Zm9yKHZhciBzPVtdLGk9MDtpPG8ubGVuZ3RoLTE7aSsrKXMucHVzaChuLnJlYWRBU0NJSShyLHQrb1tpXSxvW2krMV0tb1tpXSkpO3QrPW9bby5sZW5ndGgtMV07dmFyIGg9W107dD1lLkNGRi5yZWFkSW5kZXgocix0LGgpO3ZhciBkPVtdO2ZvcihpPTA7aTxoLmxlbmd0aC0xO2krKylkLnB1c2goZS5DRkYucmVhZERpY3Qocix0K2hbaV0sdCtoW2krMV0pKTt0Kz1oW2gubGVuZ3RoLTFdO3ZhciBmPWRbMF0sdT1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsdSk7dmFyIGw9W107Zm9yKGk9MDtpPHUubGVuZ3RoLTE7aSsrKWwucHVzaChuLnJlYWRBU0NJSShyLHQrdVtpXSx1W2krMV0tdVtpXSkpO2lmKHQrPXVbdS5sZW5ndGgtMV0sZS5DRkYucmVhZFN1YnJzKHIsdCxmKSxmLkNoYXJTdHJpbmdzKXt0PWYuQ2hhclN0cmluZ3M7dT1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsdSk7dmFyIHY9W107Zm9yKGk9MDtpPHUubGVuZ3RoLTE7aSsrKXYucHVzaChuLnJlYWRCeXRlcyhyLHQrdVtpXSx1W2krMV0tdVtpXSkpO2YuQ2hhclN0cmluZ3M9djt9aWYoZi5ST1Mpe3Q9Zi5GREFycmF5O3ZhciBjPVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCxjKSxmLkZEQXJyYXk9W107Zm9yKGk9MDtpPGMubGVuZ3RoLTE7aSsrKXt2YXIgcD1lLkNGRi5yZWFkRGljdChyLHQrY1tpXSx0K2NbaSsxXSk7ZS5DRkYuX3JlYWRGRGljdChyLHAsbCksZi5GREFycmF5LnB1c2gocCk7fXQrPWNbYy5sZW5ndGgtMV0sdD1mLkZEU2VsZWN0LGYuRkRTZWxlY3Q9W107dmFyIFU9clt0XTtpZih0KyssMyE9VSl0aHJvdyBVO3ZhciBnPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKGk9MDtpPGcrMTtpKyspZi5GRFNlbGVjdC5wdXNoKG4ucmVhZFVzaG9ydChyLHQpLHJbdCsyXSksdCs9Mzt9cmV0dXJuIGYuRW5jb2RpbmcmJihmLkVuY29kaW5nPWUuQ0ZGLnJlYWRFbmNvZGluZyhyLGYuRW5jb2RpbmcsZi5DaGFyU3RyaW5ncy5sZW5ndGgpKSxmLmNoYXJzZXQmJihmLmNoYXJzZXQ9ZS5DRkYucmVhZENoYXJzZXQocixmLmNoYXJzZXQsZi5DaGFyU3RyaW5ncy5sZW5ndGgpKSxlLkNGRi5fcmVhZEZEaWN0KHIsZixsKSxmfSxlLkNGRi5fcmVhZEZEaWN0PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbjtmb3IodmFyIG8gaW4gdC5Qcml2YXRlJiYobj10LlByaXZhdGVbMV0sdC5Qcml2YXRlPWUuQ0ZGLnJlYWREaWN0KHIsbixuK3QuUHJpdmF0ZVswXSksdC5Qcml2YXRlLlN1YnJzJiZlLkNGRi5yZWFkU3VicnMocixuK3QuUHJpdmF0ZS5TdWJycyx0LlByaXZhdGUpKSx0KS0xIT1bXCJGYW1pbHlOYW1lXCIsXCJGb250TmFtZVwiLFwiRnVsbE5hbWVcIixcIk5vdGljZVwiLFwidmVyc2lvblwiLFwiQ29weXJpZ2h0XCJdLmluZGV4T2YobykmJih0W29dPWFbdFtvXS00MjYrMzVdKTt9LGUuQ0ZGLnJlYWRTdWJycz1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89W107dD1lLkNGRi5yZWFkSW5kZXgocix0LG8pO3ZhciBzLGk9by5sZW5ndGg7cz1pPDEyNDA/MTA3Omk8MzM5MDA/MTEzMTozMjc2OCxhLkJpYXM9cyxhLlN1YnJzPVtdO2Zvcih2YXIgaD0wO2g8by5sZW5ndGgtMTtoKyspYS5TdWJycy5wdXNoKG4ucmVhZEJ5dGVzKHIsdCtvW2hdLG9baCsxXS1vW2hdKSk7fSxlLkNGRi50YWJsZVNFPVswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDEsNDIsNDMsNDQsNDUsNDYsNDcsNDgsNDksNTAsNTEsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNTksNjAsNjEsNjIsNjMsNjQsNjUsNjYsNjcsNjgsNjksNzAsNzEsNzIsNzMsNzQsNzUsNzYsNzcsNzgsNzksODAsODEsODIsODMsODQsODUsODYsODcsODgsODksOTAsOTEsOTIsOTMsOTQsOTUsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCw5Niw5Nyw5OCw5OSwxMDAsMTAxLDEwMiwxMDMsMTA0LDEwNSwxMDYsMTA3LDEwOCwxMDksMTEwLDAsMTExLDExMiwxMTMsMTE0LDAsMTE1LDExNiwxMTcsMTE4LDExOSwxMjAsMTIxLDEyMiwwLDEyMywwLDEyNCwxMjUsMTI2LDEyNywxMjgsMTI5LDEzMCwxMzEsMCwxMzIsMTMzLDAsMTM0LDEzNSwxMzYsMTM3LDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMTM4LDAsMTM5LDAsMCwwLDAsMTQwLDE0MSwxNDIsMTQzLDAsMCwwLDAsMCwxNDQsMCwwLDAsMTQ1LDAsMCwxNDYsMTQ3LDE0OCwxNDksMCwwLDAsMF0sZS5DRkYuZ2x5cGhCeVVuaWNvZGU9ZnVuY3Rpb24ocixlKXtmb3IodmFyIHQ9MDt0PHIuY2hhcnNldC5sZW5ndGg7dCsrKWlmKHIuY2hhcnNldFt0XT09ZSlyZXR1cm4gdDtyZXR1cm4gLTF9LGUuQ0ZGLmdseXBoQnlTRT1mdW5jdGlvbihyLHQpe3JldHVybiB0PDB8fHQ+MjU1Py0xOmUuQ0ZGLmdseXBoQnlVbmljb2RlKHIsZS5DRkYudGFibGVTRVt0XSl9LGUuQ0ZGLnJlYWRFbmNvZGluZz1mdW5jdGlvbihyLHQsYSl7ZS5fYmluO3ZhciBuPVtcIi5ub3RkZWZcIl0sbz1yW3RdO2lmKHQrKywwIT1vKXRocm93IFwiZXJyb3I6IHVua25vd24gZW5jb2RpbmcgZm9ybWF0OiBcIitvO3ZhciBzPXJbdF07dCsrO2Zvcih2YXIgaT0wO2k8cztpKyspbi5wdXNoKHJbdCtpXSk7cmV0dXJuIG59LGUuQ0ZGLnJlYWRDaGFyc2V0PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz1bXCIubm90ZGVmXCJdLHM9clt0XTtpZih0KyssMD09cylmb3IodmFyIGk9MDtpPGE7aSsrKXt2YXIgaD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8ucHVzaChoKTt9ZWxzZSB7aWYoMSE9cyYmMiE9cyl0aHJvdyBcImVycm9yOiBmb3JtYXQ6IFwiK3M7Zm9yKDtvLmxlbmd0aDxhOyl7aD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBkPTA7MT09cz8oZD1yW3RdLHQrKyk6KGQ9bi5yZWFkVXNob3J0KHIsdCksdCs9Mik7Zm9yKGk9MDtpPD1kO2krKylvLnB1c2goaCksaCsrO319cmV0dXJuIG99LGUuQ0ZGLnJlYWRJbmRleD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89bi5yZWFkVXNob3J0KHIsdCkrMSxzPXJbdCs9Ml07aWYodCsrLDE9PXMpZm9yKHZhciBpPTA7aTxvO2krKylhLnB1c2goclt0K2ldKTtlbHNlIGlmKDI9PXMpZm9yKGk9MDtpPG87aSsrKWEucHVzaChuLnJlYWRVc2hvcnQocix0KzIqaSkpO2Vsc2UgaWYoMz09cylmb3IoaT0wO2k8bztpKyspYS5wdXNoKDE2Nzc3MjE1Jm4ucmVhZFVpbnQocix0KzMqaS0xKSk7ZWxzZSBpZigxIT1vKXRocm93IFwidW5zdXBwb3J0ZWQgb2Zmc2V0IHNpemU6IFwiK3MrXCIsIGNvdW50OiBcIitvO3JldHVybiAodCs9bypzKS0xfSxlLkNGRi5nZXRDaGFyU3RyaW5nPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz1yW3RdLHM9clt0KzFdO3JbdCsyXSxyW3QrM10sclt0KzRdO3ZhciBpPTEsaD1udWxsLGQ9bnVsbDtvPD0yMCYmKGg9byxpPTEpLDEyPT1vJiYoaD0xMDAqbytzLGk9MiksMjE8PW8mJm88PTI3JiYoaD1vLGk9MSksMjg9PW8mJihkPW4ucmVhZFNob3J0KHIsdCsxKSxpPTMpLDI5PD1vJiZvPD0zMSYmKGg9byxpPTEpLDMyPD1vJiZvPD0yNDYmJihkPW8tMTM5LGk9MSksMjQ3PD1vJiZvPD0yNTAmJihkPTI1Niooby0yNDcpK3MrMTA4LGk9MiksMjUxPD1vJiZvPD0yNTQmJihkPTI1NiotKG8tMjUxKS1zLTEwOCxpPTIpLDI1NT09byYmKGQ9bi5yZWFkSW50KHIsdCsxKS82NTUzNSxpPTUpLGEudmFsPW51bGwhPWQ/ZDpcIm9cIitoLGEuc2l6ZT1pO30sZS5DRkYucmVhZENoYXJTdHJpbmc9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj10K2Esbz1lLl9iaW4scz1bXTt0PG47KXt2YXIgaT1yW3RdLGg9clt0KzFdO3JbdCsyXSxyW3QrM10sclt0KzRdO3ZhciBkPTEsZj1udWxsLHU9bnVsbDtpPD0yMCYmKGY9aSxkPTEpLDEyPT1pJiYoZj0xMDAqaStoLGQ9MiksMTkhPWkmJjIwIT1pfHwoZj1pLGQ9MiksMjE8PWkmJmk8PTI3JiYoZj1pLGQ9MSksMjg9PWkmJih1PW8ucmVhZFNob3J0KHIsdCsxKSxkPTMpLDI5PD1pJiZpPD0zMSYmKGY9aSxkPTEpLDMyPD1pJiZpPD0yNDYmJih1PWktMTM5LGQ9MSksMjQ3PD1pJiZpPD0yNTAmJih1PTI1NiooaS0yNDcpK2grMTA4LGQ9MiksMjUxPD1pJiZpPD0yNTQmJih1PTI1NiotKGktMjUxKS1oLTEwOCxkPTIpLDI1NT09aSYmKHU9by5yZWFkSW50KHIsdCsxKS82NTUzNSxkPTUpLHMucHVzaChudWxsIT11P3U6XCJvXCIrZiksdCs9ZDt9cmV0dXJuIHN9LGUuQ0ZGLnJlYWREaWN0PWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49ZS5fYmluLG89e30scz1bXTt0PGE7KXt2YXIgaT1yW3RdLGg9clt0KzFdO3JbdCsyXSxyW3QrM10sclt0KzRdO3ZhciBkPTEsZj1udWxsLHU9bnVsbDtpZigyOD09aSYmKHU9bi5yZWFkU2hvcnQocix0KzEpLGQ9MyksMjk9PWkmJih1PW4ucmVhZEludChyLHQrMSksZD01KSwzMjw9aSYmaTw9MjQ2JiYodT1pLTEzOSxkPTEpLDI0Nzw9aSYmaTw9MjUwJiYodT0yNTYqKGktMjQ3KStoKzEwOCxkPTIpLDI1MTw9aSYmaTw9MjU0JiYodT0yNTYqLShpLTI1MSktaC0xMDgsZD0yKSwyNTU9PWkpdGhyb3cgdT1uLnJlYWRJbnQocix0KzEpLzY1NTM1LGQ9NSxcInVua25vd24gbnVtYmVyXCI7aWYoMzA9PWkpe3ZhciBsPVtdO2ZvcihkPTE7Oyl7dmFyIHY9clt0K2RdO2QrKzt2YXIgYz12Pj40LHA9MTUmdjtpZigxNSE9YyYmbC5wdXNoKGMpLDE1IT1wJiZsLnB1c2gocCksMTU9PXApYnJlYWt9Zm9yKHZhciBVPVwiXCIsZz1bMCwxLDIsMyw0LDUsNiw3LDgsOSxcIi5cIixcImVcIixcImUtXCIsXCJyZXNlcnZlZFwiLFwiLVwiLFwiZW5kT2ZOdW1iZXJcIl0sUz0wO1M8bC5sZW5ndGg7UysrKVUrPWdbbFtTXV07dT1wYXJzZUZsb2F0KFUpO31pZihpPD0yMSlpZihmPVtcInZlcnNpb25cIixcIk5vdGljZVwiLFwiRnVsbE5hbWVcIixcIkZhbWlseU5hbWVcIixcIldlaWdodFwiLFwiRm9udEJCb3hcIixcIkJsdWVWYWx1ZXNcIixcIk90aGVyQmx1ZXNcIixcIkZhbWlseUJsdWVzXCIsXCJGYW1pbHlPdGhlckJsdWVzXCIsXCJTdGRIV1wiLFwiU3RkVldcIixcImVzY2FwZVwiLFwiVW5pcXVlSURcIixcIlhVSURcIixcImNoYXJzZXRcIixcIkVuY29kaW5nXCIsXCJDaGFyU3RyaW5nc1wiLFwiUHJpdmF0ZVwiLFwiU3VicnNcIixcImRlZmF1bHRXaWR0aFhcIixcIm5vbWluYWxXaWR0aFhcIl1baV0sZD0xLDEyPT1pKWY9W1wiQ29weXJpZ2h0XCIsXCJpc0ZpeGVkUGl0Y2hcIixcIkl0YWxpY0FuZ2xlXCIsXCJVbmRlcmxpbmVQb3NpdGlvblwiLFwiVW5kZXJsaW5lVGhpY2tuZXNzXCIsXCJQYWludFR5cGVcIixcIkNoYXJzdHJpbmdUeXBlXCIsXCJGb250TWF0cml4XCIsXCJTdHJva2VXaWR0aFwiLFwiQmx1ZVNjYWxlXCIsXCJCbHVlU2hpZnRcIixcIkJsdWVGdXp6XCIsXCJTdGVtU25hcEhcIixcIlN0ZW1TbmFwVlwiLFwiRm9yY2VCb2xkXCIsMCwwLFwiTGFuZ3VhZ2VHcm91cFwiLFwiRXhwYW5zaW9uRmFjdG9yXCIsXCJpbml0aWFsUmFuZG9tU2VlZFwiLFwiU3ludGhldGljQmFzZVwiLFwiUG9zdFNjcmlwdFwiLFwiQmFzZUZvbnROYW1lXCIsXCJCYXNlRm9udEJsZW5kXCIsMCwwLDAsMCwwLDAsXCJST1NcIixcIkNJREZvbnRWZXJzaW9uXCIsXCJDSURGb250UmV2aXNpb25cIixcIkNJREZvbnRUeXBlXCIsXCJDSURDb3VudFwiLFwiVUlEQmFzZVwiLFwiRkRBcnJheVwiLFwiRkRTZWxlY3RcIixcIkZvbnROYW1lXCJdW2hdLGQ9MjtudWxsIT1mPyhvW2ZdPTE9PXMubGVuZ3RoP3NbMF06cyxzPVtdKTpzLnB1c2godSksdCs9ZDt9cmV0dXJuIG99LGUuY21hcD17fSxlLmNtYXAucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3I9bmV3IFVpbnQ4QXJyYXkoci5idWZmZXIsdCxhKSx0PTA7dmFyIG49ZS5fYmluLG89e307bi5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgcz1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBpPVtdO28udGFibGVzPVtdO2Zvcih2YXIgaD0wO2g8cztoKyspe3ZhciBkPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgdT1uLnJlYWRVaW50KHIsdCk7dCs9NDt2YXIgbD1cInBcIitkK1wiZVwiK2Ysdj1pLmluZGV4T2YodSk7aWYoLTE9PXYpe3ZhciBjO3Y9by50YWJsZXMubGVuZ3RoLGkucHVzaCh1KTt2YXIgcD1uLnJlYWRVc2hvcnQocix1KTswPT1wP2M9ZS5jbWFwLnBhcnNlMChyLHUpOjQ9PXA/Yz1lLmNtYXAucGFyc2U0KHIsdSk6Nj09cD9jPWUuY21hcC5wYXJzZTYocix1KToxMj09cD9jPWUuY21hcC5wYXJzZTEyKHIsdSk6Y29uc29sZS5kZWJ1ZyhcInVua25vd24gZm9ybWF0OiBcIitwLGQsZix1KSxvLnRhYmxlcy5wdXNoKGMpO31pZihudWxsIT1vW2xdKXRocm93IFwibXVsdGlwbGUgdGFibGVzIGZvciBvbmUgcGxhdGZvcm0rZW5jb2RpbmdcIjtvW2xdPXY7fXJldHVybiBvfSxlLmNtYXAucGFyc2UwPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307bi5mb3JtYXQ9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTIsbi5tYXA9W107Zm9yKHZhciBzPTA7czxvLTY7cysrKW4ubWFwLnB1c2goclt0K3NdKTtyZXR1cm4gbn0sZS5jbWFwLnBhcnNlND1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQsbz17fTtvLmZvcm1hdD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBzPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBoPWkvMjtvLnNlYXJjaFJhbmdlPWEucmVhZFVzaG9ydChyLHQpLHQrPTIsby5lbnRyeVNlbGVjdG9yPWEucmVhZFVzaG9ydChyLHQpLHQrPTIsby5yYW5nZVNoaWZ0PWEucmVhZFVzaG9ydChyLHQpLHQrPTIsby5lbmRDb3VudD1hLnJlYWRVc2hvcnRzKHIsdCxoKSx0Kz0yKmgsdCs9MixvLnN0YXJ0Q291bnQ9YS5yZWFkVXNob3J0cyhyLHQsaCksdCs9MipoLG8uaWREZWx0YT1bXTtmb3IodmFyIGQ9MDtkPGg7ZCsrKW8uaWREZWx0YS5wdXNoKGEucmVhZFNob3J0KHIsdCkpLHQrPTI7Zm9yKG8uaWRSYW5nZU9mZnNldD1hLnJlYWRVc2hvcnRzKHIsdCxoKSx0Kz0yKmgsby5nbHlwaElkQXJyYXk9W107dDxuK3M7KW8uZ2x5cGhJZEFycmF5LnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTI7cmV0dXJuIG99LGUuY21hcC5wYXJzZTY9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17fTtuLmZvcm1hdD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9MixuLmZpcnN0Q29kZT1hLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsbi5nbHlwaElkQXJyYXk9W107Zm9yKHZhciBzPTA7czxvO3MrKyluLmdseXBoSWRBcnJheS5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO3JldHVybiBufSxlLmNtYXAucGFyc2UxMj1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O24uZm9ybWF0PWEucmVhZFVzaG9ydChyLHQpLHQrPTIsdCs9MixhLnJlYWRVaW50KHIsdCksdCs9NCxhLnJlYWRVaW50KHIsdCksdCs9NDt2YXIgbz1hLnJlYWRVaW50KHIsdCk7dCs9NCxuLmdyb3Vwcz1bXTtmb3IodmFyIHM9MDtzPG87cysrKXt2YXIgaT10KzEyKnMsaD1hLnJlYWRVaW50KHIsaSswKSxkPWEucmVhZFVpbnQocixpKzQpLGY9YS5yZWFkVWludChyLGkrOCk7bi5ncm91cHMucHVzaChbaCxkLGZdKTt9cmV0dXJuIG59LGUuZ2x5Zj17fSxlLmdseWYucGFyc2U9ZnVuY3Rpb24ocixlLHQsYSl7Zm9yKHZhciBuPVtdLG89MDtvPGEubWF4cC5udW1HbHlwaHM7bysrKW4ucHVzaChudWxsKTtyZXR1cm4gbn0sZS5nbHlmLl9wYXJzZUdseWY9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj1yLl9kYXRhLG89ZS5fdGFiT2Zmc2V0KG4sXCJnbHlmXCIsci5fb2Zmc2V0KStyLmxvY2FbdF07aWYoci5sb2NhW3RdPT1yLmxvY2FbdCsxXSlyZXR1cm4gbnVsbDt2YXIgcz17fTtpZihzLm5vYz1hLnJlYWRTaG9ydChuLG8pLG8rPTIscy54TWluPWEucmVhZFNob3J0KG4sbyksbys9MixzLnlNaW49YS5yZWFkU2hvcnQobixvKSxvKz0yLHMueE1heD1hLnJlYWRTaG9ydChuLG8pLG8rPTIscy55TWF4PWEucmVhZFNob3J0KG4sbyksbys9MixzLnhNaW4+PXMueE1heHx8cy55TWluPj1zLnlNYXgpcmV0dXJuIG51bGw7aWYocy5ub2M+MCl7cy5lbmRQdHM9W107Zm9yKHZhciBpPTA7aTxzLm5vYztpKyspcy5lbmRQdHMucHVzaChhLnJlYWRVc2hvcnQobixvKSksbys9Mjt2YXIgaD1hLnJlYWRVc2hvcnQobixvKTtpZihvKz0yLG4ubGVuZ3RoLW88aClyZXR1cm4gbnVsbDtzLmluc3RydWN0aW9ucz1hLnJlYWRCeXRlcyhuLG8saCksbys9aDt2YXIgZD1zLmVuZFB0c1tzLm5vYy0xXSsxO3MuZmxhZ3M9W107Zm9yKGk9MDtpPGQ7aSsrKXt2YXIgZj1uW29dO2lmKG8rKyxzLmZsYWdzLnB1c2goZiksMCE9KDgmZikpe3ZhciB1PW5bb107bysrO2Zvcih2YXIgbD0wO2w8dTtsKyspcy5mbGFncy5wdXNoKGYpLGkrKzt9fXMueHM9W107Zm9yKGk9MDtpPGQ7aSsrKXt2YXIgdj0wIT0oMiZzLmZsYWdzW2ldKSxjPTAhPSgxNiZzLmZsYWdzW2ldKTt2PyhzLnhzLnB1c2goYz9uW29dOi1uW29dKSxvKyspOmM/cy54cy5wdXNoKDApOihzLnhzLnB1c2goYS5yZWFkU2hvcnQobixvKSksbys9Mik7fXMueXM9W107Zm9yKGk9MDtpPGQ7aSsrKXt2PTAhPSg0JnMuZmxhZ3NbaV0pLGM9MCE9KDMyJnMuZmxhZ3NbaV0pO3Y/KHMueXMucHVzaChjP25bb106LW5bb10pLG8rKyk6Yz9zLnlzLnB1c2goMCk6KHMueXMucHVzaChhLnJlYWRTaG9ydChuLG8pKSxvKz0yKTt9dmFyIHA9MCxVPTA7Zm9yKGk9MDtpPGQ7aSsrKXArPXMueHNbaV0sVSs9cy55c1tpXSxzLnhzW2ldPXAscy55c1tpXT1VO31lbHNlIHt2YXIgZztzLnBhcnRzPVtdO2Rve2c9YS5yZWFkVXNob3J0KG4sbyksbys9Mjt2YXIgUz17bTp7YToxLGI6MCxjOjAsZDoxLHR4OjAsdHk6MH0scDE6LTEscDI6LTF9O2lmKHMucGFydHMucHVzaChTKSxTLmdseXBoSW5kZXg9YS5yZWFkVXNob3J0KG4sbyksbys9MiwxJmcpe3ZhciBtPWEucmVhZFNob3J0KG4sbyk7bys9Mjt2YXIgYj1hLnJlYWRTaG9ydChuLG8pO28rPTI7fWVsc2Uge209YS5yZWFkSW50OChuLG8pO28rKztiPWEucmVhZEludDgobixvKTtvKys7fTImZz8oUy5tLnR4PW0sUy5tLnR5PWIpOihTLnAxPW0sUy5wMj1iKSw4Jmc/KFMubS5hPVMubS5kPWEucmVhZEYyZG90MTQobixvKSxvKz0yKTo2NCZnPyhTLm0uYT1hLnJlYWRGMmRvdDE0KG4sbyksbys9MixTLm0uZD1hLnJlYWRGMmRvdDE0KG4sbyksbys9Mik6MTI4JmcmJihTLm0uYT1hLnJlYWRGMmRvdDE0KG4sbyksbys9MixTLm0uYj1hLnJlYWRGMmRvdDE0KG4sbyksbys9MixTLm0uYz1hLnJlYWRGMmRvdDE0KG4sbyksbys9MixTLm0uZD1hLnJlYWRGMmRvdDE0KG4sbyksbys9Mik7fXdoaWxlKDMyJmcpO2lmKDI1NiZnKXt2YXIgeT1hLnJlYWRVc2hvcnQobixvKTtvKz0yLHMuaW5zdHI9W107Zm9yKGk9MDtpPHk7aSsrKXMuaW5zdHIucHVzaChuW29dKSxvKys7fX1yZXR1cm4gc30sZS5HREVGPXt9LGUuR0RFRi5wYXJzZT1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz10O3QrPTQ7dmFyIHM9ZS5fYmluLnJlYWRVc2hvcnQocix0KTtyZXR1cm4ge2dseXBoQ2xhc3NEZWY6MD09PXM/bnVsbDplLl9sY3RmLnJlYWRDbGFzc0RlZihyLG8rcyl9fSxlLkdQT1M9e30sZS5HUE9TLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3JldHVybiBlLl9sY3RmLnBhcnNlKHIsdCxhLG4sZS5HUE9TLnN1YnQpfSxlLkdQT1Muc3VidD1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW4scz1hLGk9e307aWYoaS5mbXQ9by5yZWFkVXNob3J0KHIsYSksYSs9MiwxPT10fHwyPT10fHwzPT10fHw3PT10fHw4PT10JiZpLmZtdDw9Mil7dmFyIGg9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNvdmVyYWdlPWUuX2xjdGYucmVhZENvdmVyYWdlKHIsaCtzKTt9aWYoMT09dCYmMT09aS5mbXQpe3ZhciBkPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsMCE9ZCYmKGkucG9zPWUuR1BPUy5yZWFkVmFsdWVSZWNvcmQocixhLGQpKTt9ZWxzZSBpZigyPT10JiZpLmZtdD49MSYmaS5mbXQ8PTIpe2Q9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgZj1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciB1PWUuX2xjdGYubnVtT2ZPbmVzKGQpLGw9ZS5fbGN0Zi5udW1PZk9uZXMoZik7aWYoMT09aS5mbXQpe2kucGFpcnNldHM9W107dmFyIHY9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjtmb3IodmFyIGM9MDtjPHY7YysrKXt2YXIgcD1zK28ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIFU9by5yZWFkVXNob3J0KHIscCk7cCs9Mjtmb3IodmFyIGc9W10sUz0wO1M8VTtTKyspe3ZhciBtPW8ucmVhZFVzaG9ydChyLHApO3ArPTIsMCE9ZCYmKFA9ZS5HUE9TLnJlYWRWYWx1ZVJlY29yZChyLHAsZCkscCs9Mip1KSwwIT1mJiYoeD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIscCxmKSxwKz0yKmwpLGcucHVzaCh7Z2lkMjptLHZhbDE6UCx2YWwyOnh9KTt9aS5wYWlyc2V0cy5wdXNoKGcpO319aWYoMj09aS5mbXQpe3ZhciBiPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIHk9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgRj1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciBDPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5jbGFzc0RlZjE9ZS5fbGN0Zi5yZWFkQ2xhc3NEZWYocixzK2IpLGkuY2xhc3NEZWYyPWUuX2xjdGYucmVhZENsYXNzRGVmKHIscyt5KSxpLm1hdHJpeD1bXTtmb3IoYz0wO2M8RjtjKyspe3ZhciBfPVtdO2ZvcihTPTA7UzxDO1MrKyl7dmFyIFA9bnVsbCx4PW51bGw7MCE9ZCYmKFA9ZS5HUE9TLnJlYWRWYWx1ZVJlY29yZChyLGEsZCksYSs9Mip1KSwwIT1mJiYoeD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIsYSxmKSxhKz0yKmwpLF8ucHVzaCh7dmFsMTpQLHZhbDI6eH0pO31pLm1hdHJpeC5wdXNoKF8pO319fWVsc2UgaWYoND09dCYmMT09aS5mbXQpaS5tYXJrQ292ZXJhZ2U9ZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixvLnJlYWRVc2hvcnQocixhKStzKSxpLmJhc2VDb3ZlcmFnZT1lLl9sY3RmLnJlYWRDb3ZlcmFnZShyLG8ucmVhZFVzaG9ydChyLGErMikrcyksaS5tYXJrQ2xhc3NDb3VudD1vLnJlYWRVc2hvcnQocixhKzQpLGkubWFya0FycmF5PWUuR1BPUy5yZWFkTWFya0FycmF5KHIsby5yZWFkVXNob3J0KHIsYSs2KStzKSxpLmJhc2VBcnJheT1lLkdQT1MucmVhZEJhc2VBcnJheShyLG8ucmVhZFVzaG9ydChyLGErOCkrcyxpLm1hcmtDbGFzc0NvdW50KTtlbHNlIGlmKDY9PXQmJjE9PWkuZm10KWkubWFyazFDb3ZlcmFnZT1lLl9sY3RmLnJlYWRDb3ZlcmFnZShyLG8ucmVhZFVzaG9ydChyLGEpK3MpLGkubWFyazJDb3ZlcmFnZT1lLl9sY3RmLnJlYWRDb3ZlcmFnZShyLG8ucmVhZFVzaG9ydChyLGErMikrcyksaS5tYXJrQ2xhc3NDb3VudD1vLnJlYWRVc2hvcnQocixhKzQpLGkubWFyazFBcnJheT1lLkdQT1MucmVhZE1hcmtBcnJheShyLG8ucmVhZFVzaG9ydChyLGErNikrcyksaS5tYXJrMkFycmF5PWUuR1BPUy5yZWFkQmFzZUFycmF5KHIsby5yZWFkVXNob3J0KHIsYSs4KStzLGkubWFya0NsYXNzQ291bnQpO2Vsc2Uge2lmKDk9PXQmJjE9PWkuZm10KXt2YXIgST1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciB3PW8ucmVhZFVpbnQocixhKTtpZihhKz00LDk9PW4ubHR5cGUpbi5sdHlwZT1JO2Vsc2UgaWYobi5sdHlwZSE9SSl0aHJvdyBcImludmFsaWQgZXh0ZW5zaW9uIHN1YnN0aXR1dGlvblwiO3JldHVybiBlLkdQT1Muc3VidChyLG4ubHR5cGUscyt3KX1jb25zb2xlLmRlYnVnKFwidW5zdXBwb3J0ZWQgR1BPUyB0YWJsZSBMb29rdXBUeXBlXCIsdCxcImZvcm1hdFwiLGkuZm10KTt9cmV0dXJuIGl9LGUuR1BPUy5yZWFkVmFsdWVSZWNvcmQ9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPVtdO3JldHVybiBvLnB1c2goMSZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9MSZhPzI6MCxvLnB1c2goMiZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9MiZhPzI6MCxvLnB1c2goNCZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9NCZhPzI6MCxvLnB1c2goOCZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9OCZhPzI6MCxvfSxlLkdQT1MucmVhZEJhc2VBcnJheT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89W10scz10LGk9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGg9MDtoPGk7aCsrKXtmb3IodmFyIGQ9W10sZj0wO2Y8YTtmKyspZC5wdXNoKGUuR1BPUy5yZWFkQW5jaG9yUmVjb3JkKHIscytuLnJlYWRVc2hvcnQocix0KSkpLHQrPTI7by5wdXNoKGQpO31yZXR1cm4gb30sZS5HUE9TLnJlYWRNYXJrQXJyYXk9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj1bXSxvPXQscz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWUuR1BPUy5yZWFkQW5jaG9yUmVjb3JkKHIsYS5yZWFkVXNob3J0KHIsdCsyKStvKTtoLm1hcmtDbGFzcz1hLnJlYWRVc2hvcnQocix0KSxuLnB1c2goaCksdCs9NDt9cmV0dXJuIG59LGUuR1BPUy5yZWFkQW5jaG9yUmVjb3JkPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307cmV0dXJuIG4uZm10PWEucmVhZFVzaG9ydChyLHQpLG4ueD1hLnJlYWRTaG9ydChyLHQrMiksbi55PWEucmVhZFNob3J0KHIsdCs0KSxufSxlLkdTVUI9e30sZS5HU1VCLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3JldHVybiBlLl9sY3RmLnBhcnNlKHIsdCxhLG4sZS5HU1VCLnN1YnQpfSxlLkdTVUIuc3VidD1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW4scz1hLGk9e307aWYoaS5mbXQ9by5yZWFkVXNob3J0KHIsYSksYSs9MiwxIT10JiYyIT10JiY0IT10JiY1IT10JiY2IT10KXJldHVybiBudWxsO2lmKDE9PXR8fDI9PXR8fDQ9PXR8fDU9PXQmJmkuZm10PD0yfHw2PT10JiZpLmZtdDw9Mil7dmFyIGg9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNvdmVyYWdlPWUuX2xjdGYucmVhZENvdmVyYWdlKHIscytoKTt9aWYoMT09dCYmaS5mbXQ+PTEmJmkuZm10PD0yKXtpZigxPT1pLmZtdClpLmRlbHRhPW8ucmVhZFNob3J0KHIsYSksYSs9MjtlbHNlIGlmKDI9PWkuZm10KXt2YXIgZD1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkubmV3Zz1vLnJlYWRVc2hvcnRzKHIsYSxkKSxhKz0yKmkubmV3Zy5sZW5ndGg7fX1lbHNlIGlmKDI9PXQmJjE9PWkuZm10KXtkPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5zZXFzPVtdO2Zvcih2YXIgZj0wO2Y8ZDtmKyspe3ZhciB1PW8ucmVhZFVzaG9ydChyLGEpK3M7YSs9Mjt2YXIgbD1vLnJlYWRVc2hvcnQocix1KTtpLnNlcXMucHVzaChvLnJlYWRVc2hvcnRzKHIsdSsyLGwpKTt9fWVsc2UgaWYoND09dCl7aS52YWxzPVtdO2Q9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjtmb3IoZj0wO2Y8ZDtmKyspe3ZhciB2PW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS52YWxzLnB1c2goZS5HU1VCLnJlYWRMaWdhdHVyZVNldChyLHMrdikpO319ZWxzZSBpZig1PT10JiYyPT1pLmZtdCl7aWYoMj09aS5mbXQpe3ZhciBjPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5jRGVmPWUuX2xjdGYucmVhZENsYXNzRGVmKHIscytjKSxpLnNjc2V0PVtdO3ZhciBwPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7Zm9yKGY9MDtmPHA7ZisrKXt2YXIgVT1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkuc2NzZXQucHVzaCgwPT1VP251bGw6ZS5HU1VCLnJlYWRTdWJDbGFzc1NldChyLHMrVSkpO319fWVsc2UgaWYoNj09dCYmMz09aS5mbXQpe2lmKDM9PWkuZm10KXtmb3IoZj0wO2Y8MztmKyspe2Q9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjtmb3IodmFyIGc9W10sUz0wO1M8ZDtTKyspZy5wdXNoKGUuX2xjdGYucmVhZENvdmVyYWdlKHIscytvLnJlYWRVc2hvcnQocixhKzIqUykpKTthKz0yKmQsMD09ZiYmKGkuYmFja0N2Zz1nKSwxPT1mJiYoaS5pbnB0Q3ZnPWcpLDI9PWYmJihpLmFoZWRDdmc9Zyk7fWQ9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmxvb2t1cFJlYz1lLkdTVUIucmVhZFN1YnN0TG9va3VwUmVjb3JkcyhyLGEsZCk7fX1lbHNlIHtpZig3PT10JiYxPT1pLmZtdCl7dmFyIG09by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgYj1vLnJlYWRVaW50KHIsYSk7aWYoYSs9NCw5PT1uLmx0eXBlKW4ubHR5cGU9bTtlbHNlIGlmKG4ubHR5cGUhPW0pdGhyb3cgXCJpbnZhbGlkIGV4dGVuc2lvbiBzdWJzdGl0dXRpb25cIjtyZXR1cm4gZS5HU1VCLnN1YnQocixuLmx0eXBlLHMrYil9Y29uc29sZS5kZWJ1ZyhcInVuc3VwcG9ydGVkIEdTVUIgdGFibGUgTG9va3VwVHlwZVwiLHQsXCJmb3JtYXRcIixpLmZtdCk7fXJldHVybiBpfSxlLkdTVUIucmVhZFN1YkNsYXNzU2V0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLnJlYWRVc2hvcnQsbj10LG89W10scz1hKHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hKHIsdCk7dCs9MixvLnB1c2goZS5HU1VCLnJlYWRTdWJDbGFzc1J1bGUocixuK2gpKTt9cmV0dXJuIG99LGUuR1NVQi5yZWFkU3ViQ2xhc3NSdWxlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLnJlYWRVc2hvcnQsbj17fSxvPWEocix0KSxzPWEocix0Kz0yKTt0Kz0yLG4uaW5wdXQ9W107Zm9yKHZhciBpPTA7aTxvLTE7aSsrKW4uaW5wdXQucHVzaChhKHIsdCkpLHQrPTI7cmV0dXJuIG4uc3Vic3RMb29rdXBSZWNvcmRzPWUuR1NVQi5yZWFkU3Vic3RMb29rdXBSZWNvcmRzKHIsdCxzKSxufSxlLkdTVUIucmVhZFN1YnN0TG9va3VwUmVjb3Jkcz1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPWUuX2Jpbi5yZWFkVXNob3J0LG89W10scz0wO3M8YTtzKyspby5wdXNoKG4ocix0KSxuKHIsdCsyKSksdCs9NDtyZXR1cm4gb30sZS5HU1VCLnJlYWRDaGFpblN1YkNsYXNzU2V0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPVtdLHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8ucHVzaChlLkdTVUIucmVhZENoYWluU3ViQ2xhc3NSdWxlKHIsbitoKSk7fXJldHVybiBvfSxlLkdTVUIucmVhZENoYWluU3ViQ2xhc3NSdWxlPWZ1bmN0aW9uKHIsdCl7Zm9yKHZhciBhPWUuX2JpbixuPXt9LG89W1wiYmFja3RyYWNrXCIsXCJpbnB1dFwiLFwibG9va2FoZWFkXCJdLHM9MDtzPG8ubGVuZ3RoO3MrKyl7dmFyIGk9YS5yZWFkVXNob3J0KHIsdCk7dCs9MiwxPT1zJiZpLS0sbltvW3NdXT1hLnJlYWRVc2hvcnRzKHIsdCxpKSx0Kz0yKm5bb1tzXV0ubGVuZ3RoO31pPWEucmVhZFVzaG9ydChyLHQpO3JldHVybiB0Kz0yLG4uc3Vic3Q9YS5yZWFkVXNob3J0cyhyLHQsMippKSx0Kz0yKm4uc3Vic3QubGVuZ3RoLG59LGUuR1NVQi5yZWFkTGlnYXR1cmVTZXQ9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89W10scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsby5wdXNoKGUuR1NVQi5yZWFkTGlnYXR1cmUocixuK2gpKTt9cmV0dXJuIG99LGUuR1NVQi5yZWFkTGlnYXR1cmU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17Y2hhaW46W119O24ubmdseXBoPWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIHM9MDtzPG8tMTtzKyspbi5jaGFpbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO3JldHVybiBufSxlLmhlYWQ9e30sZS5oZWFkLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz17fTtyZXR1cm4gbi5yZWFkRml4ZWQocix0KSx0Kz00LG8uZm9udFJldmlzaW9uPW4ucmVhZEZpeGVkKHIsdCksdCs9NCxuLnJlYWRVaW50KHIsdCksdCs9NCxuLnJlYWRVaW50KHIsdCksdCs9NCxvLmZsYWdzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby51bml0c1BlckVtPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5jcmVhdGVkPW4ucmVhZFVpbnQ2NChyLHQpLHQrPTgsby5tb2RpZmllZD1uLnJlYWRVaW50NjQocix0KSx0Kz04LG8ueE1pbj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby55TWluPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLnhNYXg9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ueU1heD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5tYWNTdHlsZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubG93ZXN0UmVjUFBFTT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8uZm9udERpcmVjdGlvbkhpbnQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uaW5kZXhUb0xvY0Zvcm1hdD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5nbHlwaERhdGFGb3JtYXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG99LGUuaGhlYT17fSxlLmhoZWEucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXt9O3JldHVybiBuLnJlYWRGaXhlZChyLHQpLHQrPTQsby5hc2NlbmRlcj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5kZXNjZW5kZXI9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ubGluZUdhcD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5hZHZhbmNlV2lkdGhNYXg9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1pbkxlZnRTaWRlQmVhcmluZz1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5taW5SaWdodFNpZGVCZWFyaW5nPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLnhNYXhFeHRlbnQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uY2FyZXRTbG9wZVJpc2U9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uY2FyZXRTbG9wZVJ1bj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5jYXJldE9mZnNldD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsdCs9OCxvLm1ldHJpY0RhdGFGb3JtYXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ubnVtYmVyT2ZITWV0cmljcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG99LGUuaG10eD17fSxlLmhtdHgucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7Zm9yKHZhciBvPWUuX2JpbixzPXthV2lkdGg6W10sbHNCZWFyaW5nOltdfSxpPTAsaD0wLGQ9MDtkPG4ubWF4cC5udW1HbHlwaHM7ZCsrKWQ8bi5oaGVhLm51bWJlck9mSE1ldHJpY3MmJihpPW8ucmVhZFVzaG9ydChyLHQpLHQrPTIsaD1vLnJlYWRTaG9ydChyLHQpLHQrPTIpLHMuYVdpZHRoLnB1c2goaSkscy5sc0JlYXJpbmcucHVzaChoKTtyZXR1cm4gc30sZS5rZXJuPXt9LGUua2Vybi5wYXJzZT1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW4scz1vLnJlYWRVc2hvcnQocix0KTtpZih0Kz0yLDE9PXMpcmV0dXJuIGUua2Vybi5wYXJzZVYxKHIsdC0yLGEsbik7dmFyIGk9by5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGg9e2dseXBoMTpbXSxydmFsOltdfSxkPTA7ZDxpO2QrKyl7dCs9MjthPW8ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9by5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgdT1mPj4+ODtpZigwIT0odSY9MTUpKXRocm93IFwidW5rbm93biBrZXJuIHRhYmxlIGZvcm1hdDogXCIrdTt0PWUua2Vybi5yZWFkRm9ybWF0MChyLHQsaCk7fXJldHVybiBofSxlLmtlcm4ucGFyc2VWMT1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW47by5yZWFkRml4ZWQocix0KSx0Kz00O3ZhciBzPW8ucmVhZFVpbnQocix0KTt0Kz00O2Zvcih2YXIgaT17Z2x5cGgxOltdLHJ2YWw6W119LGg9MDtoPHM7aCsrKXtvLnJlYWRVaW50KHIsdCksdCs9NDt2YXIgZD1vLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8ucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIGY9ZD4+Pjg7aWYoMCE9KGYmPTE1KSl0aHJvdyBcInVua25vd24ga2VybiB0YWJsZSBmb3JtYXQ6IFwiK2Y7dD1lLmtlcm4ucmVhZEZvcm1hdDAocix0LGkpO31yZXR1cm4gaX0sZS5rZXJuLnJlYWRGb3JtYXQwPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz0tMSxzPW4ucmVhZFVzaG9ydChyLHQpO3QrPTIsbi5yZWFkVXNob3J0KHIsdCksdCs9MixuLnJlYWRVc2hvcnQocix0KSx0Kz0yLG4ucmVhZFVzaG9ydChyLHQpLHQrPTI7Zm9yKHZhciBpPTA7aTxzO2krKyl7dmFyIGg9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBmPW4ucmVhZFNob3J0KHIsdCk7dCs9MixoIT1vJiYoYS5nbHlwaDEucHVzaChoKSxhLnJ2YWwucHVzaCh7Z2x5cGgyOltdLHZhbHM6W119KSk7dmFyIHU9YS5ydmFsW2EucnZhbC5sZW5ndGgtMV07dS5nbHlwaDIucHVzaChkKSx1LnZhbHMucHVzaChmKSxvPWg7fXJldHVybiB0fSxlLmxvY2E9e30sZS5sb2NhLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbixzPVtdLGk9bi5oZWFkLmluZGV4VG9Mb2NGb3JtYXQsaD1uLm1heHAubnVtR2x5cGhzKzE7aWYoMD09aSlmb3IodmFyIGQ9MDtkPGg7ZCsrKXMucHVzaChvLnJlYWRVc2hvcnQocix0KyhkPDwxKSk8PDEpO2lmKDE9PWkpZm9yKGQ9MDtkPGg7ZCsrKXMucHVzaChvLnJlYWRVaW50KHIsdCsoZDw8MikpKTtyZXR1cm4gc30sZS5tYXhwPXt9LGUubWF4cC5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89e30scz1uLnJlYWRVaW50KHIsdCk7cmV0dXJuIHQrPTQsby5udW1HbHlwaHM9bi5yZWFkVXNob3J0KHIsdCksdCs9Miw2NTUzNj09cyYmKG8ubWF4UG9pbnRzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhDb250b3Vycz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Q29tcG9zaXRlUG9pbnRzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhDb21wb3NpdGVDb250b3Vycz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Wm9uZXM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heFR3aWxpZ2h0UG9pbnRzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhTdG9yYWdlPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhGdW5jdGlvbkRlZnM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heEluc3RydWN0aW9uRGVmcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4U3RhY2tFbGVtZW50cz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4U2l6ZU9mSW5zdHJ1Y3Rpb25zPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhDb21wb25lbnRFbGVtZW50cz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Q29tcG9uZW50RGVwdGg9bi5yZWFkVXNob3J0KHIsdCksdCs9Miksb30sZS5uYW1lPXt9LGUubmFtZS5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89e307bi5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgcz1uLnJlYWRVc2hvcnQocix0KTt0Kz0yLG4ucmVhZFVzaG9ydChyLHQpO2Zvcih2YXIgaSxoPVtcImNvcHlyaWdodFwiLFwiZm9udEZhbWlseVwiLFwiZm9udFN1YmZhbWlseVwiLFwiSURcIixcImZ1bGxOYW1lXCIsXCJ2ZXJzaW9uXCIsXCJwb3N0U2NyaXB0TmFtZVwiLFwidHJhZGVtYXJrXCIsXCJtYW51ZmFjdHVyZXJcIixcImRlc2lnbmVyXCIsXCJkZXNjcmlwdGlvblwiLFwidXJsVmVuZG9yXCIsXCJ1cmxEZXNpZ25lclwiLFwibGljZW5jZVwiLFwibGljZW5jZVVSTFwiLFwiLS0tXCIsXCJ0eXBvRmFtaWx5TmFtZVwiLFwidHlwb1N1YmZhbWlseU5hbWVcIixcImNvbXBhdGlibGVGdWxsXCIsXCJzYW1wbGVUZXh0XCIsXCJwb3N0U2NyaXB0Q0lEXCIsXCJ3d3NGYW1pbHlOYW1lXCIsXCJ3d3NTdWJmYW1pbHlOYW1lXCIsXCJsaWdodFBhbGV0dGVcIixcImRhcmtQYWxldHRlXCJdLGQ9dCs9MixmPTA7ZjxzO2YrKyl7dmFyIHU9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgbD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB2PW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGM9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgcD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBVPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGcsUz1oW2NdLG09ZCsxMipzK1U7aWYoMD09dSlnPW4ucmVhZFVuaWNvZGUocixtLHAvMik7ZWxzZSBpZigzPT11JiYwPT1sKWc9bi5yZWFkVW5pY29kZShyLG0scC8yKTtlbHNlIGlmKDA9PWwpZz1uLnJlYWRBU0NJSShyLG0scCk7ZWxzZSBpZigxPT1sKWc9bi5yZWFkVW5pY29kZShyLG0scC8yKTtlbHNlIGlmKDM9PWwpZz1uLnJlYWRVbmljb2RlKHIsbSxwLzIpO2Vsc2Uge2lmKDEhPXUpdGhyb3cgXCJ1bmtub3duIGVuY29kaW5nIFwiK2wrXCIsIHBsYXRmb3JtSUQ6IFwiK3U7Zz1uLnJlYWRBU0NJSShyLG0scCksY29uc29sZS5kZWJ1ZyhcInJlYWRpbmcgdW5rbm93biBNQUMgZW5jb2RpbmcgXCIrbCtcIiBhcyBBU0NJSVwiKTt9dmFyIGI9XCJwXCIrdStcIixcIit2LnRvU3RyaW5nKDE2KTtudWxsPT1vW2JdJiYob1tiXT17fSksb1tiXVt2b2lkIDAhPT1TP1M6Y109ZyxvW2JdLl9sYW5nPXY7fWZvcih2YXIgeSBpbiBvKWlmKG51bGwhPW9beV0ucG9zdFNjcmlwdE5hbWUmJjEwMzM9PW9beV0uX2xhbmcpcmV0dXJuIG9beV07Zm9yKHZhciB5IGluIG8paWYobnVsbCE9b1t5XS5wb3N0U2NyaXB0TmFtZSYmMD09b1t5XS5fbGFuZylyZXR1cm4gb1t5XTtmb3IodmFyIHkgaW4gbylpZihudWxsIT1vW3ldLnBvc3RTY3JpcHROYW1lJiYzMDg0PT1vW3ldLl9sYW5nKXJldHVybiBvW3ldO2Zvcih2YXIgeSBpbiBvKWlmKG51bGwhPW9beV0ucG9zdFNjcmlwdE5hbWUpcmV0dXJuIG9beV07Zm9yKHZhciB5IGluIG8pe2k9eTticmVha31yZXR1cm4gY29uc29sZS5kZWJ1ZyhcInJldHVybmluZyBuYW1lIHRhYmxlIHdpdGggbGFuZ3VhZ2VJRCBcIitvW2ldLl9sYW5nKSxvW2ldfSxlW1wiT1MvMlwiXT17fSxlW1wiT1MvMlwiXS5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBvPXt9O2lmKDA9PW4pZVtcIk9TLzJcIl0udmVyc2lvbjAocix0LG8pO2Vsc2UgaWYoMT09billW1wiT1MvMlwiXS52ZXJzaW9uMShyLHQsbyk7ZWxzZSBpZigyPT1ufHwzPT1ufHw0PT1uKWVbXCJPUy8yXCJdLnZlcnNpb24yKHIsdCxvKTtlbHNlIHtpZig1IT1uKXRocm93IFwidW5rbm93biBPUy8yIHRhYmxlIHZlcnNpb246IFwiK247ZVtcIk9TLzJcIl0udmVyc2lvbjUocix0LG8pO31yZXR1cm4gb30sZVtcIk9TLzJcIl0udmVyc2lvbjA9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbjtyZXR1cm4gYS54QXZnQ2hhcldpZHRoPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnVzV2VpZ2h0Q2xhc3M9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzV2lkdGhDbGFzcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEuZnNUeXBlPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS55U3Vic2NyaXB0WFNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1YnNjcmlwdFlTaXplPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdWJzY3JpcHRYT2Zmc2V0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdWJzY3JpcHRZT2Zmc2V0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdXBlcnNjcmlwdFhTaXplPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdXBlcnNjcmlwdFlTaXplPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdXBlcnNjcmlwdFhPZmZzZXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1cGVyc2NyaXB0WU9mZnNldD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3RyaWtlb3V0U2l6ZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3RyaWtlb3V0UG9zaXRpb249bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEuc0ZhbWlseUNsYXNzPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnBhbm9zZT1uLnJlYWRCeXRlcyhyLHQsMTApLHQrPTEwLGEudWxVbmljb2RlUmFuZ2UxPW4ucmVhZFVpbnQocix0KSx0Kz00LGEudWxVbmljb2RlUmFuZ2UyPW4ucmVhZFVpbnQocix0KSx0Kz00LGEudWxVbmljb2RlUmFuZ2UzPW4ucmVhZFVpbnQocix0KSx0Kz00LGEudWxVbmljb2RlUmFuZ2U0PW4ucmVhZFVpbnQocix0KSx0Kz00LGEuYWNoVmVuZElEPVtuLnJlYWRJbnQ4KHIsdCksbi5yZWFkSW50OChyLHQrMSksbi5yZWFkSW50OChyLHQrMiksbi5yZWFkSW50OChyLHQrMyldLHQrPTQsYS5mc1NlbGVjdGlvbj1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNGaXJzdENoYXJJbmRleD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNMYXN0Q2hhckluZGV4PW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5zVHlwb0FzY2VuZGVyPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnNUeXBvRGVzY2VuZGVyPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnNUeXBvTGluZUdhcD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS51c1dpbkFzY2VudD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNXaW5EZXNjZW50PW4ucmVhZFVzaG9ydChyLHQpLHQrPTJ9LGVbXCJPUy8yXCJdLnZlcnNpb24xPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW47cmV0dXJuIHQ9ZVtcIk9TLzJcIl0udmVyc2lvbjAocix0LGEpLGEudWxDb2RlUGFnZVJhbmdlMT1uLnJlYWRVaW50KHIsdCksdCs9NCxhLnVsQ29kZVBhZ2VSYW5nZTI9bi5yZWFkVWludChyLHQpLHQrPTR9LGVbXCJPUy8yXCJdLnZlcnNpb24yPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW47cmV0dXJuIHQ9ZVtcIk9TLzJcIl0udmVyc2lvbjEocix0LGEpLGEuc3hIZWlnaHQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEuc0NhcEhlaWdodD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS51c0RlZmF1bHQ9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzQnJlYWs9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzTWF4Q29udGV4dD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yfSxlW1wiT1MvMlwiXS52ZXJzaW9uNT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluO3JldHVybiB0PWVbXCJPUy8yXCJdLnZlcnNpb24yKHIsdCxhKSxhLnVzTG93ZXJPcHRpY2FsUG9pbnRTaXplPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c1VwcGVyT3B0aWNhbFBvaW50U2l6ZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yfSxlLnBvc3Q9e30sZS5wb3N0LnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz17fTtyZXR1cm4gby52ZXJzaW9uPW4ucmVhZEZpeGVkKHIsdCksdCs9NCxvLml0YWxpY0FuZ2xlPW4ucmVhZEZpeGVkKHIsdCksdCs9NCxvLnVuZGVybGluZVBvc2l0aW9uPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLnVuZGVybGluZVRoaWNrbmVzcz1uLnJlYWRTaG9ydChyLHQpLHQrPTIsb30sbnVsbD09ZSYmKGU9e30pLG51bGw9PWUuVSYmKGUuVT17fSksZS5VLmNvZGVUb0dseXBoPWZ1bmN0aW9uKHIsZSl7dmFyIHQ9ci5jbWFwLGE9LTE7aWYobnVsbCE9dC5wMGU0P2E9dC5wMGU0Om51bGwhPXQucDNlMT9hPXQucDNlMTpudWxsIT10LnAxZTA/YT10LnAxZTA6bnVsbCE9dC5wMGUzJiYoYT10LnAwZTMpLC0xPT1hKXRocm93IFwibm8gZmFtaWxpYXIgcGxhdGZvcm0gYW5kIGVuY29kaW5nIVwiO3ZhciBuPXQudGFibGVzW2FdO2lmKDA9PW4uZm9ybWF0KXJldHVybiBlPj1uLm1hcC5sZW5ndGg/MDpuLm1hcFtlXTtpZig0PT1uLmZvcm1hdCl7Zm9yKHZhciBvPS0xLHM9MDtzPG4uZW5kQ291bnQubGVuZ3RoO3MrKylpZihlPD1uLmVuZENvdW50W3NdKXtvPXM7YnJlYWt9aWYoLTE9PW8pcmV0dXJuIDA7aWYobi5zdGFydENvdW50W29dPmUpcmV0dXJuIDA7cmV0dXJuIDY1NTM1JigwIT1uLmlkUmFuZ2VPZmZzZXRbb10/bi5nbHlwaElkQXJyYXlbZS1uLnN0YXJ0Q291bnRbb10rKG4uaWRSYW5nZU9mZnNldFtvXT4+MSktKG4uaWRSYW5nZU9mZnNldC5sZW5ndGgtbyldOmUrbi5pZERlbHRhW29dKX1pZigxMj09bi5mb3JtYXQpe2lmKGU+bi5ncm91cHNbbi5ncm91cHMubGVuZ3RoLTFdWzFdKXJldHVybiAwO2ZvcihzPTA7czxuLmdyb3Vwcy5sZW5ndGg7cysrKXt2YXIgaT1uLmdyb3Vwc1tzXTtpZihpWzBdPD1lJiZlPD1pWzFdKXJldHVybiBpWzJdKyhlLWlbMF0pfXJldHVybiAwfXRocm93IFwidW5rbm93biBjbWFwIHRhYmxlIGZvcm1hdCBcIituLmZvcm1hdH0sZS5VLmdseXBoVG9QYXRoPWZ1bmN0aW9uKHIsdCl7dmFyIGE9e2NtZHM6W10sY3JkczpbXX07aWYoci5TVkcmJnIuU1ZHLmVudHJpZXNbdF0pe3ZhciBuPXIuU1ZHLmVudHJpZXNbdF07cmV0dXJuIG51bGw9PW4/YTooXCJzdHJpbmdcIj09dHlwZW9mIG4mJihuPWUuU1ZHLnRvUGF0aChuKSxyLlNWRy5lbnRyaWVzW3RdPW4pLG4pfWlmKHIuQ0ZGKXt2YXIgbz17eDowLHk6MCxzdGFjazpbXSxuU3RlbXM6MCxoYXZlV2lkdGg6ITEsd2lkdGg6ci5DRkYuUHJpdmF0ZT9yLkNGRi5Qcml2YXRlLmRlZmF1bHRXaWR0aFg6MCxvcGVuOiExfSxzPXIuQ0ZGLGk9ci5DRkYuUHJpdmF0ZTtpZihzLlJPUyl7Zm9yKHZhciBoPTA7cy5GRFNlbGVjdFtoKzJdPD10OyloKz0yO2k9cy5GREFycmF5W3MuRkRTZWxlY3RbaCsxXV0uUHJpdmF0ZTt9ZS5VLl9kcmF3Q0ZGKHIuQ0ZGLkNoYXJTdHJpbmdzW3RdLG8scyxpLGEpO31lbHNlIHIuZ2x5ZiYmZS5VLl9kcmF3R2x5Zih0LHIsYSk7cmV0dXJuIGF9LGUuVS5fZHJhd0dseWY9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPXQuZ2x5ZltyXTtudWxsPT1uJiYobj10LmdseWZbcl09ZS5nbHlmLl9wYXJzZUdseWYodCxyKSksbnVsbCE9biYmKG4ubm9jPi0xP2UuVS5fc2ltcGxlR2x5cGgobixhKTplLlUuX2NvbXBvR2x5cGgobix0LGEpKTt9LGUuVS5fc2ltcGxlR2x5cGg9ZnVuY3Rpb24ocix0KXtmb3IodmFyIGE9MDthPHIubm9jO2ErKyl7Zm9yKHZhciBuPTA9PWE/MDpyLmVuZFB0c1thLTFdKzEsbz1yLmVuZFB0c1thXSxzPW47czw9bztzKyspe3ZhciBpPXM9PW4/bzpzLTEsaD1zPT1vP246cysxLGQ9MSZyLmZsYWdzW3NdLGY9MSZyLmZsYWdzW2ldLHU9MSZyLmZsYWdzW2hdLGw9ci54c1tzXSx2PXIueXNbc107aWYocz09bilpZihkKXtpZighZil7ZS5VLlAubW92ZVRvKHQsbCx2KTtjb250aW51ZX1lLlUuUC5tb3ZlVG8odCxyLnhzW2ldLHIueXNbaV0pO31lbHNlIGY/ZS5VLlAubW92ZVRvKHQsci54c1tpXSxyLnlzW2ldKTplLlUuUC5tb3ZlVG8odCwoci54c1tpXStsKS8yLChyLnlzW2ldK3YpLzIpO2Q/ZiYmZS5VLlAubGluZVRvKHQsbCx2KTp1P2UuVS5QLnFjdXJ2ZVRvKHQsbCx2LHIueHNbaF0sci55c1toXSk6ZS5VLlAucWN1cnZlVG8odCxsLHYsKGwrci54c1toXSkvMiwodityLnlzW2hdKS8yKTt9ZS5VLlAuY2xvc2VQYXRoKHQpO319LGUuVS5fY29tcG9HbHlwaD1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPTA7bjxyLnBhcnRzLmxlbmd0aDtuKyspe3ZhciBvPXtjbWRzOltdLGNyZHM6W119LHM9ci5wYXJ0c1tuXTtlLlUuX2RyYXdHbHlmKHMuZ2x5cGhJbmRleCx0LG8pO2Zvcih2YXIgaT1zLm0saD0wO2g8by5jcmRzLmxlbmd0aDtoKz0yKXt2YXIgZD1vLmNyZHNbaF0sZj1vLmNyZHNbaCsxXTthLmNyZHMucHVzaChkKmkuYStmKmkuYitpLnR4KSxhLmNyZHMucHVzaChkKmkuYytmKmkuZCtpLnR5KTt9Zm9yKGg9MDtoPG8uY21kcy5sZW5ndGg7aCsrKWEuY21kcy5wdXNoKG8uY21kc1toXSk7fX0sZS5VLl9nZXRHbHlwaENsYXNzPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fbGN0Zi5nZXRJbnRlcnZhbCh0LHIpO3JldHVybiAtMT09YT8wOnRbYSsyXX0sZS5VLl9hcHBseVN1YnM9ZnVuY3Rpb24ocix0LGEsbil7Zm9yKHZhciBvPXIubGVuZ3RoLXQtMSxzPTA7czxhLnRhYnMubGVuZ3RoO3MrKylpZihudWxsIT1hLnRhYnNbc10pe3ZhciBpLGg9YS50YWJzW3NdO2lmKCFoLmNvdmVyYWdlfHwtMSE9KGk9ZS5fbGN0Zi5jb3ZlcmFnZUluZGV4KGguY292ZXJhZ2Usclt0XSkpKWlmKDE9PWEubHR5cGUpclt0XSwxPT1oLmZtdD9yW3RdPXJbdF0raC5kZWx0YTpyW3RdPWgubmV3Z1tpXTtlbHNlIGlmKDQ9PWEubHR5cGUpZm9yKHZhciBkPWgudmFsc1tpXSxmPTA7ZjxkLmxlbmd0aDtmKyspe3ZhciB1PWRbZl0sbD11LmNoYWluLmxlbmd0aDtpZighKGw+bykpe2Zvcih2YXIgdj0hMCxjPTAscD0wO3A8bDtwKyspe2Zvcig7LTE9PXJbdCtjKygxK3ApXTspYysrO3UuY2hhaW5bcF0hPXJbdCtjKygxK3ApXSYmKHY9ITEpO31pZih2KXtyW3RdPXUubmdseXBoO2ZvcihwPTA7cDxsK2M7cCsrKXJbdCtwKzFdPS0xO2JyZWFrfX19ZWxzZSBpZig1PT1hLmx0eXBlJiYyPT1oLmZtdClmb3IodmFyIFU9ZS5fbGN0Zi5nZXRJbnRlcnZhbChoLmNEZWYsclt0XSksZz1oLmNEZWZbVSsyXSxTPWguc2NzZXRbZ10sbT0wO208Uy5sZW5ndGg7bSsrKXt2YXIgYj1TW21dLHk9Yi5pbnB1dDtpZighKHkubGVuZ3RoPm8pKXtmb3Iodj0hMCxwPTA7cDx5Lmxlbmd0aDtwKyspe3ZhciBGPWUuX2xjdGYuZ2V0SW50ZXJ2YWwoaC5jRGVmLHJbdCsxK3BdKTtpZigtMT09VSYmaC5jRGVmW0YrMl0hPXlbcF0pe3Y9ITE7YnJlYWt9fWlmKHYpe3ZhciBDPWIuc3Vic3RMb29rdXBSZWNvcmRzO2ZvcihmPTA7ZjxDLmxlbmd0aDtmKz0yKUNbZl0sQ1tmKzFdO319fWVsc2UgaWYoNj09YS5sdHlwZSYmMz09aC5mbXQpe2lmKCFlLlUuX2dsc0NvdmVyZWQocixoLmJhY2tDdmcsdC1oLmJhY2tDdmcubGVuZ3RoKSljb250aW51ZTtpZighZS5VLl9nbHNDb3ZlcmVkKHIsaC5pbnB0Q3ZnLHQpKWNvbnRpbnVlO2lmKCFlLlUuX2dsc0NvdmVyZWQocixoLmFoZWRDdmcsdCtoLmlucHRDdmcubGVuZ3RoKSljb250aW51ZTt2YXIgXz1oLmxvb2t1cFJlYztmb3IobT0wO208Xy5sZW5ndGg7bSs9Mil7VT1fW21dO3ZhciBQPW5bX1ttKzFdXTtlLlUuX2FwcGx5U3VicyhyLHQrVSxQLG4pO319fX0sZS5VLl9nbHNDb3ZlcmVkPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7aWYoLTE9PWUuX2xjdGYuY292ZXJhZ2VJbmRleCh0W25dLHJbYStuXSkpcmV0dXJuICExfXJldHVybiAhMH0sZS5VLmdseXBoc1RvUGF0aD1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPXtjbWRzOltdLGNyZHM6W119LG89MCxzPTA7czx0Lmxlbmd0aDtzKyspe3ZhciBpPXRbc107aWYoLTEhPWkpe2Zvcih2YXIgaD1zPHQubGVuZ3RoLTEmJi0xIT10W3MrMV0/dFtzKzFdOjAsZD1lLlUuZ2x5cGhUb1BhdGgocixpKSxmPTA7ZjxkLmNyZHMubGVuZ3RoO2YrPTIpbi5jcmRzLnB1c2goZC5jcmRzW2ZdK28pLG4uY3Jkcy5wdXNoKGQuY3Jkc1tmKzFdKTthJiZuLmNtZHMucHVzaChhKTtmb3IoZj0wO2Y8ZC5jbWRzLmxlbmd0aDtmKyspbi5jbWRzLnB1c2goZC5jbWRzW2ZdKTthJiZuLmNtZHMucHVzaChcIlhcIiksbys9ci5obXR4LmFXaWR0aFtpXSxzPHQubGVuZ3RoLTEmJihvKz1lLlUuZ2V0UGFpckFkanVzdG1lbnQocixpLGgpKTt9fXJldHVybiBufSxlLlUuUD17fSxlLlUuUC5tb3ZlVG89ZnVuY3Rpb24ocixlLHQpe3IuY21kcy5wdXNoKFwiTVwiKSxyLmNyZHMucHVzaChlLHQpO30sZS5VLlAubGluZVRvPWZ1bmN0aW9uKHIsZSx0KXtyLmNtZHMucHVzaChcIkxcIiksci5jcmRzLnB1c2goZSx0KTt9LGUuVS5QLmN1cnZlVG89ZnVuY3Rpb24ocixlLHQsYSxuLG8scyl7ci5jbWRzLnB1c2goXCJDXCIpLHIuY3Jkcy5wdXNoKGUsdCxhLG4sbyxzKTt9LGUuVS5QLnFjdXJ2ZVRvPWZ1bmN0aW9uKHIsZSx0LGEsbil7ci5jbWRzLnB1c2goXCJRXCIpLHIuY3Jkcy5wdXNoKGUsdCxhLG4pO30sZS5VLlAuY2xvc2VQYXRoPWZ1bmN0aW9uKHIpe3IuY21kcy5wdXNoKFwiWlwiKTt9LGUuVS5fZHJhd0NGRj1mdW5jdGlvbihyLHQsYSxuLG8pe2Zvcih2YXIgcz10LnN0YWNrLGk9dC5uU3RlbXMsaD10LmhhdmVXaWR0aCxkPXQud2lkdGgsZj10Lm9wZW4sdT0wLGw9dC54LHY9dC55LGM9MCxwPTAsVT0wLGc9MCxTPTAsbT0wLGI9MCx5PTAsRj0wLEM9MCxfPXt2YWw6MCxzaXplOjB9O3U8ci5sZW5ndGg7KXtlLkNGRi5nZXRDaGFyU3RyaW5nKHIsdSxfKTt2YXIgUD1fLnZhbDtpZih1Kz1fLnNpemUsXCJvMVwiPT1QfHxcIm8xOFwiPT1QKXMubGVuZ3RoJTIhPTAmJiFoJiYoZD1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYKSxpKz1zLmxlbmd0aD4+MSxzLmxlbmd0aD0wLGg9ITA7ZWxzZSBpZihcIm8zXCI9PVB8fFwibzIzXCI9PVApe3MubGVuZ3RoJTIhPTAmJiFoJiYoZD1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYKSxpKz1zLmxlbmd0aD4+MSxzLmxlbmd0aD0wLGg9ITA7fWVsc2UgaWYoXCJvNFwiPT1QKXMubGVuZ3RoPjEmJiFoJiYoZD1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYLGg9ITApLGYmJmUuVS5QLmNsb3NlUGF0aChvKSx2Kz1zLnBvcCgpLGUuVS5QLm1vdmVUbyhvLGwsdiksZj0hMDtlbHNlIGlmKFwibzVcIj09UClmb3IoO3MubGVuZ3RoPjA7KWwrPXMuc2hpZnQoKSx2Kz1zLnNoaWZ0KCksZS5VLlAubGluZVRvKG8sbCx2KTtlbHNlIGlmKFwibzZcIj09UHx8XCJvN1wiPT1QKWZvcih2YXIgeD1zLmxlbmd0aCxJPVwibzZcIj09UCx3PTA7dzx4O3crKyl7dmFyIGs9cy5zaGlmdCgpO0k/bCs9azp2Kz1rLEk9IUksZS5VLlAubGluZVRvKG8sbCx2KTt9ZWxzZSBpZihcIm84XCI9PVB8fFwibzI0XCI9PVApe3g9cy5sZW5ndGg7Zm9yKHZhciBHPTA7Rys2PD14OyljPWwrcy5zaGlmdCgpLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLGw9VStzLnNoaWZ0KCksdj1nK3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxsLHYpLEcrPTY7XCJvMjRcIj09UCYmKGwrPXMuc2hpZnQoKSx2Kz1zLnNoaWZ0KCksZS5VLlAubGluZVRvKG8sbCx2KSk7fWVsc2Uge2lmKFwibzExXCI9PVApYnJlYWs7aWYoXCJvMTIzNFwiPT1QfHxcIm8xMjM1XCI9PVB8fFwibzEyMzZcIj09UHx8XCJvMTIzN1wiPT1QKVwibzEyMzRcIj09UCYmKHA9dixVPShjPWwrcy5zaGlmdCgpKStzLnNoaWZ0KCksQz1nPXArcy5zaGlmdCgpLG09Zyx5PXYsbD0oYj0oUz0oRj1VK3Muc2hpZnQoKSkrcy5zaGlmdCgpKStzLnNoaWZ0KCkpK3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxGLEMpLGUuVS5QLmN1cnZlVG8obyxTLG0sYix5LGwsdikpLFwibzEyMzVcIj09UCYmKGM9bCtzLnNoaWZ0KCkscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksRj1VK3Muc2hpZnQoKSxDPWcrcy5zaGlmdCgpLFM9RitzLnNoaWZ0KCksbT1DK3Muc2hpZnQoKSxiPVMrcy5zaGlmdCgpLHk9bStzLnNoaWZ0KCksbD1iK3Muc2hpZnQoKSx2PXkrcy5zaGlmdCgpLHMuc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxGLEMpLGUuVS5QLmN1cnZlVG8obyxTLG0sYix5LGwsdikpLFwibzEyMzZcIj09UCYmKGM9bCtzLnNoaWZ0KCkscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLEM9Zz1wK3Muc2hpZnQoKSxtPWcsYj0oUz0oRj1VK3Muc2hpZnQoKSkrcy5zaGlmdCgpKStzLnNoaWZ0KCkseT1tK3Muc2hpZnQoKSxsPWIrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLEYsQyksZS5VLlAuY3VydmVUbyhvLFMsbSxiLHksbCx2KSksXCJvMTIzN1wiPT1QJiYoYz1sK3Muc2hpZnQoKSxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxGPVUrcy5zaGlmdCgpLEM9ZytzLnNoaWZ0KCksUz1GK3Muc2hpZnQoKSxtPUMrcy5zaGlmdCgpLGI9UytzLnNoaWZ0KCkseT1tK3Muc2hpZnQoKSxNYXRoLmFicyhiLWwpPk1hdGguYWJzKHktdik/bD1iK3Muc2hpZnQoKTp2PXkrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLEYsQyksZS5VLlAuY3VydmVUbyhvLFMsbSxiLHksbCx2KSk7ZWxzZSBpZihcIm8xNFwiPT1QKXtpZihzLmxlbmd0aD4wJiYhaCYmKGQ9cy5zaGlmdCgpK2Eubm9taW5hbFdpZHRoWCxoPSEwKSw0PT1zLmxlbmd0aCl7dmFyIE89cy5zaGlmdCgpLFQ9cy5zaGlmdCgpLEQ9cy5zaGlmdCgpLEI9cy5zaGlmdCgpLEE9ZS5DRkYuZ2x5cGhCeVNFKGEsRCksUj1lLkNGRi5nbHlwaEJ5U0UoYSxCKTtlLlUuX2RyYXdDRkYoYS5DaGFyU3RyaW5nc1tBXSx0LGEsbixvKSx0Lng9Tyx0Lnk9VCxlLlUuX2RyYXdDRkYoYS5DaGFyU3RyaW5nc1tSXSx0LGEsbixvKTt9ZiYmKGUuVS5QLmNsb3NlUGF0aChvKSxmPSExKTt9ZWxzZSBpZihcIm8xOVwiPT1QfHxcIm8yMFwiPT1QKXtzLmxlbmd0aCUyIT0wJiYhaCYmKGQ9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCksaSs9cy5sZW5ndGg+PjEscy5sZW5ndGg9MCxoPSEwLHUrPWkrNz4+Mzt9ZWxzZSBpZihcIm8yMVwiPT1QKXMubGVuZ3RoPjImJiFoJiYoZD1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYLGg9ITApLHYrPXMucG9wKCksbCs9cy5wb3AoKSxmJiZlLlUuUC5jbG9zZVBhdGgobyksZS5VLlAubW92ZVRvKG8sbCx2KSxmPSEwO2Vsc2UgaWYoXCJvMjJcIj09UClzLmxlbmd0aD4xJiYhaCYmKGQ9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCxoPSEwKSxsKz1zLnBvcCgpLGYmJmUuVS5QLmNsb3NlUGF0aChvKSxlLlUuUC5tb3ZlVG8obyxsLHYpLGY9ITA7ZWxzZSBpZihcIm8yNVwiPT1QKXtmb3IoO3MubGVuZ3RoPjY7KWwrPXMuc2hpZnQoKSx2Kz1zLnNoaWZ0KCksZS5VLlAubGluZVRvKG8sbCx2KTtjPWwrcy5zaGlmdCgpLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLGw9VStzLnNoaWZ0KCksdj1nK3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxsLHYpO31lbHNlIGlmKFwibzI2XCI9PVApZm9yKHMubGVuZ3RoJTImJihsKz1zLnNoaWZ0KCkpO3MubGVuZ3RoPjA7KWM9bCxwPXYrcy5zaGlmdCgpLGw9VT1jK3Muc2hpZnQoKSx2PShnPXArcy5zaGlmdCgpKStzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsbCx2KTtlbHNlIGlmKFwibzI3XCI9PVApZm9yKHMubGVuZ3RoJTImJih2Kz1zLnNoaWZ0KCkpO3MubGVuZ3RoPjA7KXA9dixVPShjPWwrcy5zaGlmdCgpKStzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxsPVUrcy5zaGlmdCgpLHY9ZyxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxsLHYpO2Vsc2UgaWYoXCJvMTBcIj09UHx8XCJvMjlcIj09UCl7dmFyIEw9XCJvMTBcIj09UD9uOmE7aWYoMD09cy5sZW5ndGgpY29uc29sZS5kZWJ1ZyhcImVycm9yOiBlbXB0eSBzdGFja1wiKTtlbHNlIHt2YXIgVz1zLnBvcCgpLE09TC5TdWJyc1tXK0wuQmlhc107dC54PWwsdC55PXYsdC5uU3RlbXM9aSx0LmhhdmVXaWR0aD1oLHQud2lkdGg9ZCx0Lm9wZW49ZixlLlUuX2RyYXdDRkYoTSx0LGEsbixvKSxsPXQueCx2PXQueSxpPXQublN0ZW1zLGg9dC5oYXZlV2lkdGgsZD10LndpZHRoLGY9dC5vcGVuO319ZWxzZSBpZihcIm8zMFwiPT1QfHxcIm8zMVwiPT1QKXt2YXIgVj1zLmxlbmd0aCxFPShHPTAsXCJvMzFcIj09UCk7Zm9yKEcrPVYtKHg9LTMmVik7Rzx4OylFPyhwPXYsVT0oYz1sK3Muc2hpZnQoKSkrcy5zaGlmdCgpLHY9KGc9cCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSx4LUc9PTU/KGw9VStzLnNoaWZ0KCksRysrKTpsPVUsRT0hMSk6KGM9bCxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxsPVUrcy5zaGlmdCgpLHgtRz09NT8odj1nK3Muc2hpZnQoKSxHKyspOnY9ZyxFPSEwKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxsLHYpLEcrPTQ7fWVsc2Uge2lmKFwib1wiPT0oUCtcIlwiKS5jaGFyQXQoMCkpdGhyb3cgY29uc29sZS5kZWJ1ZyhcIlVua25vd24gb3BlcmF0aW9uOiBcIitQLHIpLFA7cy5wdXNoKFApO319fXQueD1sLHQueT12LHQublN0ZW1zPWksdC5oYXZlV2lkdGg9aCx0LndpZHRoPWQsdC5vcGVuPWY7fTt2YXIgdD1lLGE9e1R5cHI6dH07cmV0dXJuIHIuVHlwcj10LHIuZGVmYXVsdD1hLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHJ9KHt9KS5UeXByfVxuXG4vKiFcbkN1c3RvbSBidW5kbGUgb2Ygd29mZjJvdGYgKGh0dHBzOi8vZ2l0aHViLmNvbS9hcnR5LW5hbWUvd29mZjJvdGYpIHdpdGggZmZsYXRlXG4oaHR0cHM6Ly9naXRodWIuY29tLzEwMWFycm93ei9mZmxhdGUpIGZvciB1c2UgaW4gVHJvaWthIHRleHQgcmVuZGVyaW5nLiBcbk9yaWdpbmFsIGxpY2Vuc2VzIGFwcGx5OiBcbi0gZmZsYXRlOiBodHRwczovL2dpdGh1Yi5jb20vMTAxYXJyb3d6L2ZmbGF0ZS9ibG9iL21hc3Rlci9MSUNFTlNFIChNSVQpXG4tIHdvZmYyb3RmLmpzOiBodHRwczovL2dpdGh1Yi5jb20vYXJ0eS1uYW1lL3dvZmYyb3RmL2Jsb2IvbWFzdGVyL3dvZmYyb3RmLmpzIChBcGFjaGUyKVxuKi9cbmZ1bmN0aW9uIHdvZmYyb3RmRmFjdG9yeSgpe3JldHVybiBmdW5jdGlvbihyKXt2YXIgZT1VaW50OEFycmF5LG49VWludDE2QXJyYXksdD1VaW50MzJBcnJheSxhPW5ldyBlKFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDAsMCwwLDBdKSxpPW5ldyBlKFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzLDAsMF0pLG89bmV3IGUoWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdKSxmPWZ1bmN0aW9uKHIsZSl7Zm9yKHZhciBhPW5ldyBuKDMxKSxpPTA7aTwzMTsrK2kpYVtpXT1lKz0xPDxyW2ktMV07dmFyIG89bmV3IHQoYVszMF0pO2ZvcihpPTE7aTwzMDsrK2kpZm9yKHZhciBmPWFbaV07ZjxhW2krMV07KytmKW9bZl09Zi1hW2ldPDw1fGk7cmV0dXJuIFthLG9dfSx1PWYoYSwyKSx2PXVbMF0scz11WzFdO3ZbMjhdPTI1OCxzWzI1OF09Mjg7Zm9yKHZhciBsPWYoaSwwKVswXSxjPW5ldyBuKDMyNzY4KSxnPTA7ZzwzMjc2ODsrK2cpe3ZhciBoPSg0MzY5MCZnKT4+PjF8KDIxODQ1JmcpPDwxO2g9KDYxNjgwJihoPSg1MjQyOCZoKT4+PjJ8KDEzMTA3JmgpPDwyKSk+Pj40fCgzODU1JmgpPDw0LGNbZ109KCg2NTI4MCZoKT4+Pjh8KDI1NSZoKTw8OCk+Pj4xO312YXIgdz1mdW5jdGlvbihyLGUsdCl7Zm9yKHZhciBhPXIubGVuZ3RoLGk9MCxvPW5ldyBuKGUpO2k8YTsrK2kpKytvW3JbaV0tMV07dmFyIGYsdT1uZXcgbihlKTtmb3IoaT0wO2k8ZTsrK2kpdVtpXT11W2ktMV0rb1tpLTFdPDwxO2lmKHQpe2Y9bmV3IG4oMTw8ZSk7dmFyIHY9MTUtZTtmb3IoaT0wO2k8YTsrK2kpaWYocltpXSlmb3IodmFyIHM9aTw8NHxyW2ldLGw9ZS1yW2ldLGc9dVtyW2ldLTFdKys8PGwsaD1nfCgxPDxsKS0xO2c8PWg7KytnKWZbY1tnXT4+PnZdPXM7fWVsc2UgZm9yKGY9bmV3IG4oYSksaT0wO2k8YTsrK2kpcltpXSYmKGZbaV09Y1t1W3JbaV0tMV0rK10+Pj4xNS1yW2ldKTtyZXR1cm4gZn0sZD1uZXcgZSgyODgpO2ZvcihnPTA7ZzwxNDQ7KytnKWRbZ109ODtmb3IoZz0xNDQ7ZzwyNTY7KytnKWRbZ109OTtmb3IoZz0yNTY7ZzwyODA7KytnKWRbZ109Nztmb3IoZz0yODA7ZzwyODg7KytnKWRbZ109ODt2YXIgbT1uZXcgZSgzMik7Zm9yKGc9MDtnPDMyOysrZyltW2ddPTU7dmFyIGI9dyhkLDksMSkscD13KG0sNSwxKSx5PWZ1bmN0aW9uKHIpe2Zvcih2YXIgZT1yWzBdLG49MTtuPHIubGVuZ3RoOysrbilyW25dPmUmJihlPXJbbl0pO3JldHVybiBlfSxMPWZ1bmN0aW9uKHIsZSxuKXt2YXIgdD1lLzh8MDtyZXR1cm4gKHJbdF18clt0KzFdPDw4KT4+KDcmZSkmbn0sVT1mdW5jdGlvbihyLGUpe3ZhciBuPWUvOHwwO3JldHVybiAocltuXXxyW24rMV08PDh8cltuKzJdPDwxNik+Pig3JmUpfSxrPVtcInVuZXhwZWN0ZWQgRU9GXCIsXCJpbnZhbGlkIGJsb2NrIHR5cGVcIixcImludmFsaWQgbGVuZ3RoL2xpdGVyYWxcIixcImludmFsaWQgZGlzdGFuY2VcIixcInN0cmVhbSBmaW5pc2hlZFwiLFwibm8gc3RyZWFtIGhhbmRsZXJcIiwsXCJubyBjYWxsYmFja1wiLFwiaW52YWxpZCBVVEYtOCBkYXRhXCIsXCJleHRyYSBmaWVsZCB0b28gbG9uZ1wiLFwiZGF0ZSBub3QgaW4gcmFuZ2UgMTk4MC0yMDk5XCIsXCJmaWxlbmFtZSB0b28gbG9uZ1wiLFwic3RyZWFtIGZpbmlzaGluZ1wiLFwiaW52YWxpZCB6aXAgZGF0YVwiXSxUPWZ1bmN0aW9uKHIsZSxuKXt2YXIgdD1uZXcgRXJyb3IoZXx8a1tyXSk7aWYodC5jb2RlPXIsRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UmJkVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHQsVCksIW4pdGhyb3cgdDtyZXR1cm4gdH0sTz1mdW5jdGlvbihyLGYsdSl7dmFyIHM9ci5sZW5ndGg7aWYoIXN8fHUmJiF1LmwmJnM8NSlyZXR1cm4gZnx8bmV3IGUoMCk7dmFyIGM9IWZ8fHUsZz0hdXx8dS5pO3V8fCh1PXt9KSxmfHwoZj1uZXcgZSgzKnMpKTt2YXIgaCxkPWZ1bmN0aW9uKHIpe3ZhciBuPWYubGVuZ3RoO2lmKHI+bil7dmFyIHQ9bmV3IGUoTWF0aC5tYXgoMipuLHIpKTt0LnNldChmKSxmPXQ7fX0sbT11LmZ8fDAsaz11LnB8fDAsTz11LmJ8fDAsQT11LmwseD11LmQsRT11Lm0sRD11Lm4sTT04KnM7ZG97aWYoIUEpe3UuZj1tPUwocixrLDEpO3ZhciBTPUwocixrKzEsMyk7aWYoays9MywhUyl7dmFyIFY9clsoST0oKGg9aykvOHwwKSsoNyZoJiYxKSs0KS00XXxyW0ktM108PDgsXz1JK1Y7aWYoXz5zKXtnJiZUKDApO2JyZWFrfWMmJmQoTytWKSxmLnNldChyLnN1YmFycmF5KEksXyksTyksdS5iPU8rPVYsdS5wPWs9OCpfO2NvbnRpbnVlfWlmKDE9PVMpQT1iLHg9cCxFPTksRD01O2Vsc2UgaWYoMj09Uyl7dmFyIGo9TChyLGssMzEpKzI1Nyx6PUwocixrKzEwLDE1KSs0LEM9aitMKHIsays1LDMxKSsxO2srPTE0O2Zvcih2YXIgRj1uZXcgZShDKSxQPW5ldyBlKDE5KSxxPTA7cTx6OysrcSlQW29bcV1dPUwocixrKzMqcSw3KTtrKz0zKno7dmFyIEI9eShQKSxHPSgxPDxCKS0xLEg9dyhQLEIsMSk7Zm9yKHE9MDtxPEM7KXt2YXIgSSxKPUhbTChyLGssRyldO2lmKGsrPTE1JkosKEk9Sj4+PjQpPDE2KUZbcSsrXT1JO2Vsc2Uge3ZhciBLPTAsTj0wO2ZvcigxNj09ST8oTj0zK0wocixrLDMpLGsrPTIsSz1GW3EtMV0pOjE3PT1JPyhOPTMrTChyLGssNyksays9Myk6MTg9PUkmJihOPTExK0wocixrLDEyNyksays9Nyk7Ti0tOylGW3ErK109Szt9fXZhciBRPUYuc3ViYXJyYXkoMCxqKSxSPUYuc3ViYXJyYXkoaik7RT15KFEpLEQ9eShSKSxBPXcoUSxFLDEpLHg9dyhSLEQsMSk7fWVsc2UgVCgxKTtpZihrPk0pe2cmJlQoMCk7YnJlYWt9fWMmJmQoTysxMzEwNzIpO2Zvcih2YXIgVz0oMTw8RSktMSxYPSgxPDxEKS0xLFk9azs7WT1rKXt2YXIgWj0oSz1BW1UocixrKSZXXSk+Pj40O2lmKChrKz0xNSZLKT5NKXtnJiZUKDApO2JyZWFrfWlmKEt8fFQoMiksWjwyNTYpZltPKytdPVo7ZWxzZSB7aWYoMjU2PT1aKXtZPWssQT1udWxsO2JyZWFrfXZhciAkPVotMjU0O2lmKFo+MjY0KXt2YXIgcnI9YVtxPVotMjU3XTskPUwocixrLCgxPDxyciktMSkrdltxXSxrKz1ycjt9dmFyIGVyPXhbVShyLGspJlhdLG5yPWVyPj4+NDtlcnx8VCgzKSxrKz0xNSZlcjtSPWxbbnJdO2lmKG5yPjMpe3JyPWlbbnJdO1IrPVUocixrKSYoMTw8cnIpLTEsays9cnI7fWlmKGs+TSl7ZyYmVCgwKTticmVha31jJiZkKE8rMTMxMDcyKTtmb3IodmFyIHRyPU8rJDtPPHRyO08rPTQpZltPXT1mW08tUl0sZltPKzFdPWZbTysxLVJdLGZbTysyXT1mW08rMi1SXSxmW08rM109ZltPKzMtUl07Tz10cjt9fXUubD1BLHUucD1ZLHUuYj1PLEEmJihtPTEsdS5tPUUsdS5kPXgsdS5uPUQpO313aGlsZSghbSk7cmV0dXJuIE89PWYubGVuZ3RoP2Y6ZnVuY3Rpb24ocixhLGkpeyhudWxsPT1hfHxhPDApJiYoYT0wKSwobnVsbD09aXx8aT5yLmxlbmd0aCkmJihpPXIubGVuZ3RoKTt2YXIgbz1uZXcociBpbnN0YW5jZW9mIG4/bjpyIGluc3RhbmNlb2YgdD90OmUpKGktYSk7cmV0dXJuIG8uc2V0KHIuc3ViYXJyYXkoYSxpKSksb30oZiwwLE8pfSxBPW5ldyBlKDApO3ZhciB4PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2RlciYmbmV3IFRleHREZWNvZGVyO3RyeXt4LmRlY29kZShBLHtzdHJlYW06ITB9KSwxO31jYXRjaChyKXt9cmV0dXJuIHIuY29udmVydF9zdHJlYW1zPWZ1bmN0aW9uKHIpe3ZhciBlPW5ldyBEYXRhVmlldyhyKSxuPTA7ZnVuY3Rpb24gdCgpe3ZhciByPWUuZ2V0VWludDE2KG4pO3JldHVybiBuKz0yLHJ9ZnVuY3Rpb24gYSgpe3ZhciByPWUuZ2V0VWludDMyKG4pO3JldHVybiBuKz00LHJ9ZnVuY3Rpb24gaShyKXttLnNldFVpbnQxNihiLHIpLGIrPTI7fWZ1bmN0aW9uIG8ocil7bS5zZXRVaW50MzIoYixyKSxiKz00O31mb3IodmFyIGY9e3NpZ25hdHVyZTphKCksZmxhdm9yOmEoKSxsZW5ndGg6YSgpLG51bVRhYmxlczp0KCkscmVzZXJ2ZWQ6dCgpLHRvdGFsU2ZudFNpemU6YSgpLG1ham9yVmVyc2lvbjp0KCksbWlub3JWZXJzaW9uOnQoKSxtZXRhT2Zmc2V0OmEoKSxtZXRhTGVuZ3RoOmEoKSxtZXRhT3JpZ0xlbmd0aDphKCkscHJpdk9mZnNldDphKCkscHJpdkxlbmd0aDphKCl9LHU9MDtNYXRoLnBvdygyLHUpPD1mLm51bVRhYmxlczspdSsrO3UtLTtmb3IodmFyIHY9MTYqTWF0aC5wb3coMix1KSxzPTE2KmYubnVtVGFibGVzLXYsbD0xMixjPVtdLGc9MDtnPGYubnVtVGFibGVzO2crKyljLnB1c2goe3RhZzphKCksb2Zmc2V0OmEoKSxjb21wTGVuZ3RoOmEoKSxvcmlnTGVuZ3RoOmEoKSxvcmlnQ2hlY2tzdW06YSgpfSksbCs9MTY7dmFyIGgsdz1uZXcgVWludDhBcnJheSgxMisxNipjLmxlbmd0aCtjLnJlZHVjZSgoZnVuY3Rpb24ocixlKXtyZXR1cm4gcitlLm9yaWdMZW5ndGgrNH0pLDApKSxkPXcuYnVmZmVyLG09bmV3IERhdGFWaWV3KGQpLGI9MDtyZXR1cm4gbyhmLmZsYXZvciksaShmLm51bVRhYmxlcyksaSh2KSxpKHUpLGkocyksYy5mb3JFYWNoKChmdW5jdGlvbihyKXtvKHIudGFnKSxvKHIub3JpZ0NoZWNrc3VtKSxvKGwpLG8oci5vcmlnTGVuZ3RoKSxyLm91dE9mZnNldD1sLChsKz1yLm9yaWdMZW5ndGgpJTQhPTAmJihsKz00LWwlNCk7fSkpLGMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG4sdD1yLnNsaWNlKGUub2Zmc2V0LGUub2Zmc2V0K2UuY29tcExlbmd0aCk7aWYoZS5jb21wTGVuZ3RoIT1lLm9yaWdMZW5ndGgpe3ZhciBhPW5ldyBVaW50OEFycmF5KGUub3JpZ0xlbmd0aCk7bj1uZXcgVWludDhBcnJheSh0LDIpLE8obixhKTt9ZWxzZSBhPW5ldyBVaW50OEFycmF5KHQpO3cuc2V0KGEsZS5vdXRPZmZzZXQpO3ZhciBpPTA7KGw9ZS5vdXRPZmZzZXQrZS5vcmlnTGVuZ3RoKSU0IT0wJiYoaT00LWwlNCksdy5zZXQobmV3IFVpbnQ4QXJyYXkoaSkuYnVmZmVyLGUub3V0T2Zmc2V0K2Uub3JpZ0xlbmd0aCksaD1sK2k7fSkpLGQuc2xpY2UoMCxoKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSkscn0oe30pLmNvbnZlcnRfc3RyZWFtc31cblxuLyoqXG4gKiBBIGZhY3Rvcnkgd3JhcHBlciBwYXJzaW5nIGEgZm9udCBmaWxlIHVzaW5nIFR5cHIuXG4gKiBBbHNvIGFkZHMgc3VwcG9ydCBmb3IgV09GRiBmaWxlcyAobm90IFdPRkYyKS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIFBhcnNlZEZvbnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhc2NlbmRlclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlc2NlbmRlclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHhIZWlnaHRcbiAqIEBwcm9wZXJ0eSB7KG51bWJlcikgPT4gYm9vbGVhbn0gc3VwcG9ydHNDb2RlUG9pbnRcbiAqIEBwcm9wZXJ0eSB7KHRleHQ6c3RyaW5nLCBmb250U2l6ZTpudW1iZXIsIGxldHRlclNwYWNpbmc6bnVtYmVyLCBjYWxsYmFjaykgPT4gbnVtYmVyfSBmb3JFYWNoR2x5cGhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lR2FwXG4gKiBAcHJvcGVydHkge251bWJlcn0gY2FwSGVpZ2h0XG4gKiBAcHJvcGVydHkge251bWJlcn0gdW5pdHNQZXJFbVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhidWZmZXI6IEFycmF5QnVmZmVyKSA9PiBQYXJzZWRGb250fSBGb250UGFyc2VyXG4gKi9cblxuLyoqXG4gKiBAcmV0dXJucyB7Rm9udFBhcnNlcn1cbiAqL1xuZnVuY3Rpb24gcGFyc2VyRmFjdG9yeShUeXByLCB3b2ZmMm90Zikge1xuICBjb25zdCBjbWRBcmdMZW5ndGhzID0ge1xuICAgIE06IDIsXG4gICAgTDogMixcbiAgICBROiA0LFxuICAgIEM6IDYsXG4gICAgWjogMFxuICB9O1xuXG4gIC8vIHtqb2luVHlwZTogXCJza2lwK3N0ZXAsLi4uXCJ9XG4gIGNvbnN0IGpvaW5pbmdUeXBlUmF3RGF0YSA9IHtcIkNcIjpcIjE4ZyxjYSwzNjgsMWt6XCIsXCJEXCI6XCIxN2ssNiwyLDIrNCw1K2MsMis2LDIrMSwxMCsxLDkrZixqKzExLDIrMSxhLDIsMisxLDE1KzIsMyxqKzIsNiszLDIrOCwyLDIsMisxLHcrYSw0K2UsMyszLDIsMysyLDMrNSwyMyt3LDJmKzQsMywyKzksMixiLDIrMywzLDFrKzksNisxLDMrMSwyKzIsMitkLDMwZyxwK3ksMSwxKzFnLGYreCwyLHNkMisxZCxqZjMrNCxmKzMsMis0LDIrMixiKzMsNDIsMiw0KzIsMisxLDIsMyx0KzEsOWYrdywyLGVsKzIsMitnLGQrMiwybCwyKzEsNSwzKzEsMisxLDIsMyw2LDE2d20rMXZcIixcIlJcIjpcIjE3bSszLDIsMiw2KzMsbSwxNSsyLDIrMixoK2gsMTMsMys4LDIsMiwzKzEsMixwKzEseCw1KzQsNSxhLDIsMiwzLHUsYysyLGcrMSw1LDIrMSw0KzEsNWosNisxLDIsYiwyKzIsZiwyKzEsMXMrMiwyLDMrMSw3LDFlejAsMiwyKzEsNCs0LGIsNCwzLGIsNDIsMisyLDQsMywyKzEsMixvKzMsYWUsZXAseCwybysyLDMrMSwzLDUrMSw2XCIsXCJMXCI6XCJ4OXUsamZmLGEsZmQsanZcIixcIlRcIjpcIjR0LGdqKzMzLDdvKzQsMSsxLDdjKzE4LDIsMisxLDIrMSwyLDIxK2EsMiwxYitrLGgsMnUrNiwzKzUsMysxLDIrMyx5LDIsditxLDJrK2EsMW4rOCxhLHArMywyKzgsMisyLDIrNCwxOCsyLDNjK2UsMit2LDFrLDIsNSs3LDUsNCs2LGIrMSx1LDFuLDUrMyw5LGwrMSxyLDMrMSwxbSw1KzEsNSsxLDMrMiw0LHYrMSw0LGMrMSwxbSw1KzQsMisxLDUsbCsxLG4rNSwyLDFuLDMsMiszLDksOCsxLGMrMSx2LDFxLGQsMWYsNCwxbSsyLDYrMiwyKzMsOCsxLGMrMSx1LDFuLDMsNyw2KzEsbCsxLHQrMSwxbSsxLDUrMyw5LGwrMSx1LDIxLDgrMiwyLDJqLDMrNixkKzcsMnIsMys4LGMrNSwyMysxLHMsMiwyLDFrK2QsMis0LDIrMSw2K2EsMit6LGEsMnYrMywyKzUsMisxLDMrMSxxKzEsNSsyLGgrMyxlLDMrMSw3LGcsamsrMixxYisyLHUrMix1KzEsdisxLDF0KzEsMis2LDksMythLGEsMWErMiwzYysxLHosM2IrMiw1KzEsYSw3KzIsNjQrMSwzLDFuLDIrNiwyLDIsMys3LDcrOSwzLDFkK2QsMSwxKzEsMXMrMywxZCwyKzQsMiw2LDE1KzgsZCsxLHgrMywzKzEsMisyLDFsLDIrMSw0LDIrMiwxbis3LDMrMSw0OSsyLDIrYywyKzYsNSw3LDQrMSw1aisxbCwyKzQsZWssMysxLHIrNCwxZSs0LDYrNSwycCtjLDErMywxLDErMiwxK2IsMmRiKzIsM3ksMnArdixmZiszLDMwKzEsbjl4LDErMiwyKzkseCsxLDI5KzEsN2wsNCw1LHErMSw2LDQ4KzEscitoLGUsMTMrNyxxK2EsMWIrMiwxZCwzKzMsMysxLDE0LDF3KzUsMysxLDMrMSxkLDksMWMsMWcsMisyLDMrMSw2KzEsMiwxNysxLDksNm4sMyw1LGZuNSxraStmLGgrZiw1cyw2eSsyLGVhLDZiLDQ2KzQsMWFmKzIsMisxLDYrMywxNSsyLDUsNG0rMSxmeSszLGFzKzEsNGErYSw0eCwxaitlLDFsKzIsMWUrMywzKzEsMXkrMiwxMSs0LDIrNywxcixkKzEsMWgrOCxiKzMsMywybysyLDMsMisxLDcsNGgsNCs3LG0rMSwxbSsxLDQsMTIrNiw0KzQsNWcrNywzKzIsMixvLDJkKzUsMiw1KzEsMisxLDZuKzMsNysxLDIrMSxzKzEsMmUrNywzLDIrMSwyeiwyLDMrNSwyLDJ1KzIsMyszLDIrNCw3OCs4LDIrMSw3NSsxLDIsNSw0MSszLDMrMSw1LHgrOSwxNSs1LDMrMyw5LGErNSwzKzIsMWIrYywyKzEsYmIrNiwyKzUsMiwyYitsLDMrNiwyKzEsMisxLDNmKzUsNCwyKzEsMis2LDIsMjErMSw0LDIsOW8rMSw0NzArOCxhdDQrNCwxbys2LHQ1LDFzKzMsMmEsZjVsKzEsMiszLDQzbysyLGErNywxKzcsMys2LHYrMyw0NSsyLDFqMCsxaSw1KzFkLDksZixuKzQsMitlLDExdCs2LDIrZywzKzYsMisxLDIrNCw3YSs2LGM2KzMsMTV0KzYsMzIrNiwxLGd6YXUsdisybiwzbCs2blwifTtcblxuICBjb25zdCBKVF9MRUZUID0gMSwgLy9pbmRpY2F0ZXMgdGhhdCBhIGNoYXJhY3RlciBqb2lucyB3aXRoIHRoZSBzdWJzZXF1ZW50IGNoYXJhY3RlciwgYnV0IGRvZXMgbm90IGpvaW4gd2l0aCB0aGUgcHJlY2VkaW5nIGNoYXJhY3Rlci5cbiAgICBKVF9SSUdIVCA9IDIsIC8vaW5kaWNhdGVzIHRoYXQgYSBjaGFyYWN0ZXIgam9pbnMgd2l0aCB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlciwgYnV0IGRvZXMgbm90IGpvaW4gd2l0aCB0aGUgc3Vic2VxdWVudCBjaGFyYWN0ZXIuXG4gICAgSlRfRFVBTCA9IDQsIC8vaW5kaWNhdGVzIHRoYXQgYSBjaGFyYWN0ZXIgam9pbnMgd2l0aCB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlciBhbmQgam9pbnMgd2l0aCB0aGUgc3Vic2VxdWVudCBjaGFyYWN0ZXIuXG4gICAgSlRfVFJBTlNQQVJFTlQgPSA4LCAvL2luZGljYXRlcyB0aGF0IHRoZSBjaGFyYWN0ZXIgZG9lcyBub3Qgam9pbiB3aXRoIGFkamFjZW50IGNoYXJhY3RlcnMgYW5kIHRoYXQgdGhlIGNoYXJhY3RlciBtdXN0IGJlIHNraXBwZWQgb3ZlciB3aGVuIHRoZSBzaGFwaW5nIGVuZ2luZSBpcyBldmFsdWF0aW5nIHRoZSBqb2luaW5nIHBvc2l0aW9ucyBpbiBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMuIFdoZW4gYSBKVF9UUkFOU1BBUkVOVCBjaGFyYWN0ZXIgaXMgZW5jb3VudGVyZWQgaW4gYSBzZXF1ZW5jZSwgdGhlIEpPSU5JTkdfVFlQRSBvZiB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlciBwYXNzZXMgdGhyb3VnaC4gRGlhY3JpdGljYWwgbWFya3MgYXJlIGZyZXF1ZW50bHkgYXNzaWduZWQgdGhpcyB2YWx1ZS5cbiAgICBKVF9KT0lOX0NBVVNJTkcgPSAxNiwgLy9pbmRpY2F0ZXMgdGhhdCB0aGUgY2hhcmFjdGVyIGZvcmNlcyB0aGUgdXNlIG9mIGpvaW5pbmcgZm9ybXMgd2l0aCB0aGUgcHJlY2VkaW5nIGFuZCBzdWJzZXF1ZW50IGNoYXJhY3RlcnMuIEthc2hpZGFzIGFuZCB0aGUgWmVybyBXaWR0aCBKb2luZXIgKFUrMjAwRCkgYXJlIGJvdGggSk9JTl9DQVVTSU5HIGNoYXJhY3RlcnMuXG4gICAgSlRfTk9OX0pPSU5JTkcgPSAzMjsgLy9pbmRpY2F0ZXMgdGhhdCBhIGNoYXJhY3RlciBkb2VzIG5vdCBqb2luIHdpdGggdGhlIHByZWNlZGluZyBvciB3aXRoIHRoZSBzdWJzZXF1ZW50IGNoYXJhY3Rlci4sXG5cbiAgbGV0IGpvaW5pbmdUeXBlTWFwO1xuICBmdW5jdGlvbiBnZXRDaGFySm9pbmluZ1R5cGUoY2gpIHtcbiAgICBpZiAoIWpvaW5pbmdUeXBlTWFwKSB7XG4gICAgICBjb25zdCBtID0ge1xuICAgICAgICBSOiBKVF9SSUdIVCxcbiAgICAgICAgTDogSlRfTEVGVCxcbiAgICAgICAgRDogSlRfRFVBTCxcbiAgICAgICAgQzogSlRfSk9JTl9DQVVTSU5HLFxuICAgICAgICBVOiBKVF9OT05fSk9JTklORyxcbiAgICAgICAgVDogSlRfVFJBTlNQQVJFTlRcbiAgICAgIH07XG4gICAgICBqb2luaW5nVHlwZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIGZvciAobGV0IHR5cGUgaW4gam9pbmluZ1R5cGVSYXdEYXRhKSB7XG4gICAgICAgIGxldCBsYXN0Q29kZSA9IDA7XG4gICAgICAgIGpvaW5pbmdUeXBlUmF3RGF0YVt0eXBlXS5zcGxpdCgnLCcpLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgIGxldCBbc2tpcCwgc3RlcF0gPSByYW5nZS5zcGxpdCgnKycpO1xuICAgICAgICAgIHNraXAgPSBwYXJzZUludChza2lwLDM2KTtcbiAgICAgICAgICBzdGVwID0gc3RlcCA/IHBhcnNlSW50KHN0ZXAsIDM2KSA6IDA7XG4gICAgICAgICAgam9pbmluZ1R5cGVNYXAuc2V0KGxhc3RDb2RlICs9IHNraXAsIG1bdHlwZV0pO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBzdGVwOyBpLS07KSB7XG4gICAgICAgICAgICBqb2luaW5nVHlwZU1hcC5zZXQoKytsYXN0Q29kZSwgbVt0eXBlXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGpvaW5pbmdUeXBlTWFwLmdldChjaCkgfHwgSlRfTk9OX0pPSU5JTkdcbiAgfVxuXG4gIGNvbnN0IElTT0wgPSAxLCBJTklUID0gMiwgRklOQSA9IDMsIE1FREkgPSA0O1xuICBjb25zdCBmb3Jtc1RvRmVhdHVyZXMgPSBbbnVsbCwgJ2lzb2wnLCAnaW5pdCcsICdmaW5hJywgJ21lZGknXTtcblxuICBmdW5jdGlvbiBkZXRlY3RKb2luaW5nRm9ybXMoc3RyKSB7XG4gICAgLy8gVGhpcyBpbXBsZW1lbnRzIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkIGhlcmU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL244d2lsbGlzL29wZW50eXBlLXNoYXBpbmctZG9jdW1lbnRzL2Jsb2IvbWFzdGVyL29wZW50eXBlLXNoYXBpbmctYXJhYmljLWdlbmVyYWwubWRcbiAgICBjb25zdCBqb2luaW5nRm9ybXMgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgICBsZXQgcHJldkpvaW5pbmdUeXBlID0gSlRfTk9OX0pPSU5JTkc7XG4gICAgbGV0IHByZXZGb3JtID0gSVNPTDtcbiAgICBsZXQgcHJldkluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgICBsZXQgam9pbmluZ1R5cGUgPSBnZXRDaGFySm9pbmluZ1R5cGUoY29kZSkgfCAwO1xuICAgICAgbGV0IGZvcm0gPSBJU09MO1xuICAgICAgaWYgKGpvaW5pbmdUeXBlICYgSlRfVFJBTlNQQVJFTlQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2Sm9pbmluZ1R5cGUgJiAoSlRfTEVGVCB8IEpUX0RVQUwgfCBKVF9KT0lOX0NBVVNJTkcpKSB7XG4gICAgICAgIGlmIChqb2luaW5nVHlwZSAmIChKVF9SSUdIVCB8IEpUX0RVQUwgfCBKVF9KT0lOX0NBVVNJTkcpKSB7XG4gICAgICAgICAgZm9ybSA9IEZJTkE7XG4gICAgICAgICAgLy8gaXNvbC0+aW5pdCwgZmluYS0+bWVkaVxuICAgICAgICAgIGlmIChwcmV2Rm9ybSA9PT0gSVNPTCB8fCBwcmV2Rm9ybSA9PT0gRklOQSkge1xuICAgICAgICAgICAgam9pbmluZ0Zvcm1zW3ByZXZJbmRleF0rKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoam9pbmluZ1R5cGUgJiAoSlRfTEVGVCB8IEpUX05PTl9KT0lOSU5HKSkge1xuICAgICAgICAgIC8vIG1lZGktPmZpbmEsIGluaXQtPmlzb2xcbiAgICAgICAgICBpZiAocHJldkZvcm0gPT09IElOSVQgfHwgcHJldkZvcm0gPT09IE1FREkpIHtcbiAgICAgICAgICAgIGpvaW5pbmdGb3Jtc1twcmV2SW5kZXhdLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwcmV2Sm9pbmluZ1R5cGUgJiAoSlRfUklHSFQgfCBKVF9OT05fSk9JTklORykpIHtcbiAgICAgICAgLy8gbWVkaS0+ZmluYSwgaW5pdC0+aXNvbFxuICAgICAgICBpZiAocHJldkZvcm0gPT09IElOSVQgfHwgcHJldkZvcm0gPT09IE1FREkpIHtcbiAgICAgICAgICBqb2luaW5nRm9ybXNbcHJldkluZGV4XS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcmV2Rm9ybSA9IGpvaW5pbmdGb3Jtc1tpXSA9IGZvcm07XG4gICAgICBwcmV2Sm9pbmluZ1R5cGUgPSBqb2luaW5nVHlwZTtcbiAgICAgIHByZXZJbmRleCA9IGk7XG4gICAgICBpZiAoY29kZSA+IDB4ZmZmZikgaSsrO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZyhzdHIuc3BsaXQoJycpLm1hcChjaCA9PiBjaC5jb2RlUG9pbnRBdCgwKS50b1N0cmluZygxNikpKVxuICAgIC8vIGNvbnNvbGUubG9nKHN0ci5zcGxpdCgnJykubWFwKGNoID0+IGdldENoYXJKb2luaW5nVHlwZShjaC5jb2RlUG9pbnRBdCgwKSkpKVxuICAgIC8vIGNvbnNvbGUubG9nKEFycmF5LmZyb20oam9pbmluZ0Zvcm1zKS5tYXAoZiA9PiBmb3Jtc1RvRmVhdHVyZXNbZl0gfHwgJ25vbmUnKSlcbiAgICByZXR1cm4gam9pbmluZ0Zvcm1zXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdUb0dseXBocyAoZm9udCwgc3RyKSB7XG4gICAgY29uc3QgZ2x5cGhJZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2MgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgICBpZiAoY2MgPiAweGZmZmYpIGkrKztcbiAgICAgIGdseXBoSWRzLnB1c2goVHlwci5VLmNvZGVUb0dseXBoKGZvbnQsIGNjKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZ3N1YiA9IGZvbnRbJ0dTVUInXTtcbiAgICBpZiAoZ3N1Yikge1xuICAgICAgY29uc3Qge2xvb2t1cExpc3QsIGZlYXR1cmVMaXN0fSA9IGdzdWI7XG4gICAgICBsZXQgam9pbmluZ0Zvcm1zO1xuICAgICAgY29uc3Qgc3VwcG9ydGVkRmVhdHVyZXMgPSAvXihybGlnfGxpZ2F8bXNldHxpc29sfGluaXR8ZmluYXxtZWRpfGhhbGZ8cHJlc3xibHdzfGNjbXApJC87XG4gICAgICBjb25zdCB1c2VkTG9va3VwcyA9IFtdO1xuICAgICAgZmVhdHVyZUxpc3QuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICAgICAgaWYgKHN1cHBvcnRlZEZlYXR1cmVzLnRlc3QoZmVhdHVyZS50YWcpKSB7XG4gICAgICAgICAgZm9yIChsZXQgdGkgPSAwOyB0aSA8IGZlYXR1cmUudGFiLmxlbmd0aDsgdGkrKykge1xuICAgICAgICAgICAgaWYgKHVzZWRMb29rdXBzW2ZlYXR1cmUudGFiW3RpXV0pIGNvbnRpbnVlXG4gICAgICAgICAgICB1c2VkTG9va3Vwc1tmZWF0dXJlLnRhYlt0aV1dID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRhYiA9IGxvb2t1cExpc3RbZmVhdHVyZS50YWJbdGldXTtcbiAgICAgICAgICAgIGNvbnN0IGlzSm9pbmluZ0ZlYXR1cmUgPSAvXihpc29sfGluaXR8ZmluYXxtZWRpKSQvLnRlc3QoZmVhdHVyZS50YWcpO1xuICAgICAgICAgICAgaWYgKGlzSm9pbmluZ0ZlYXR1cmUgJiYgIWpvaW5pbmdGb3JtcykgeyAvL2xhenlcbiAgICAgICAgICAgICAgam9pbmluZ0Zvcm1zID0gZGV0ZWN0Sm9pbmluZ0Zvcm1zKHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBjaSA9IDA7IGNpIDwgZ2x5cGhJZHMubGVuZ3RoOyBjaSsrKSB7XG4gICAgICAgICAgICAgIGlmICgham9pbmluZ0Zvcm1zIHx8ICFpc0pvaW5pbmdGZWF0dXJlIHx8IGZvcm1zVG9GZWF0dXJlc1tqb2luaW5nRm9ybXNbY2ldXSA9PT0gZmVhdHVyZS50YWcpIHtcbiAgICAgICAgICAgICAgICBUeXByLlUuX2FwcGx5U3VicyhnbHlwaElkcywgY2ksIHRhYiwgbG9va3VwTGlzdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaElkc1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGFkdmFuY2VzIGFuZCB4L3kgb2Zmc2V0cyBmb3IgZWFjaCBnbHlwaCwgZS5nLiBrZXJuaW5nIGFuZCBtYXJrXG4gIC8vIGF0dGFjaG1lbnRzLiBUaGlzIGlzIGEgbW9yZSBjb21wbGV0ZSB2ZXJzaW9uIG9mIFR5cHIuVS5nZXRQYWlyQWRqdXN0bWVudFxuICAvLyBhbmQgc2hvdWxkIGJlY29tZSBhbiB1cHN0cmVhbSByZXBsYWNlbWVudCBldmVudHVhbGx5LlxuICBmdW5jdGlvbiBjYWxjR2x5cGhQb3NpdGlvbnMoZm9udCwgZ2x5cGhJZHMpIHtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgSW50MTZBcnJheShnbHlwaElkcy5sZW5ndGggKiAzKTsgLy8gW29mZnNldFgsIG9mZnNldFksIGFkdmFuY2VYLCAuLi5dXG4gICAgbGV0IGdseXBoSW5kZXggPSAwO1xuICAgIGZvciAoOyBnbHlwaEluZGV4IDwgZ2x5cGhJZHMubGVuZ3RoOyBnbHlwaEluZGV4KyspIHtcbiAgICAgIGNvbnN0IGdseXBoSWQgPSBnbHlwaElkc1tnbHlwaEluZGV4XTtcbiAgICAgIGlmIChnbHlwaElkID09PSAtMSkgY29udGludWU7XG5cbiAgICAgIHBvc2l0aW9uc1tnbHlwaEluZGV4ICogMyArIDJdID0gZm9udC5obXR4LmFXaWR0aFtnbHlwaElkXTsgLy8gcG9wdWxhdGUgYWR2YW5jZVggaW4uLi5hZHZhbmNlLlxuXG4gICAgICBjb25zdCBncG9zID0gZm9udC5HUE9TO1xuICAgICAgaWYgKGdwb3MpIHtcbiAgICAgICAgY29uc3QgbGxpc3QgPSBncG9zLmxvb2t1cExpc3Q7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBsb29rdXAgPSBsbGlzdFtpXTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvb2t1cC50YWJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCB0YWIgPSBsb29rdXAudGFic1tqXTtcbiAgICAgICAgICAgIC8vIFNpbmdsZSBjaGFyIHBsYWNlbWVudFxuICAgICAgICAgICAgaWYgKGxvb2t1cC5sdHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICBjb25zdCBpbmQgPSBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgodGFiLmNvdmVyYWdlLCBnbHlwaElkKTtcbiAgICAgICAgICAgICAgaWYgKGluZCAhPT0gLTEgJiYgdGFiLnBvcykge1xuICAgICAgICAgICAgICAgIGFwcGx5VmFsdWVSZWNvcmQodGFiLnBvcywgZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFpcnMgKGtlcm5pbmcpXG4gICAgICAgICAgICBlbHNlIGlmIChsb29rdXAubHR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgbGV0IGFkaiA9IG51bGw7XG4gICAgICAgICAgICAgIGxldCBwcmV2R2x5cGhJbmRleCA9IGdldFByZXZHbHlwaEluZGV4KCk7XG4gICAgICAgICAgICAgIGlmIChwcmV2R2x5cGhJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3ZlcmFnZUluZGV4ID0gVHlwci5fbGN0Zi5jb3ZlcmFnZUluZGV4KHRhYi5jb3ZlcmFnZSwgZ2x5cGhJZHNbcHJldkdseXBoSW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAoY292ZXJhZ2VJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0YWIuZm10ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gdGFiLnBhaXJzZXRzW2NvdmVyYWdlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJpZ2h0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0W2tdLmdpZDIgPT09IGdseXBoSWQpIGFkaiA9IHJpZ2h0W2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhYi5mbXQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYzEgPSBUeXByLlUuX2dldEdseXBoQ2xhc3MoZ2x5cGhJZHNbcHJldkdseXBoSW5kZXhdLCB0YWIuY2xhc3NEZWYxKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYzIgPSBUeXByLlUuX2dldEdseXBoQ2xhc3MoZ2x5cGhJZCwgdGFiLmNsYXNzRGVmMik7XG4gICAgICAgICAgICAgICAgICAgIGFkaiA9IHRhYi5tYXRyaXhbYzFdW2MyXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChhZGopIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkai52YWwxKSBhcHBseVZhbHVlUmVjb3JkKGFkai52YWwxLCBwcmV2R2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGoudmFsMikgYXBwbHlWYWx1ZVJlY29yZChhZGoudmFsMiwgZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYXJrIHRvIGJhc2VcbiAgICAgICAgICAgIGVsc2UgaWYgKGxvb2t1cC5sdHlwZSA9PT0gNCkge1xuICAgICAgICAgICAgICBjb25zdCBtYXJrQXJySW5kZXggPSBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgodGFiLm1hcmtDb3ZlcmFnZSwgZ2x5cGhJZCk7XG4gICAgICAgICAgICAgIGlmIChtYXJrQXJySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUdseXBoSW5kZXggPSBnZXRQcmV2R2x5cGhJbmRleChpc0Jhc2VHbHlwaCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUFyckluZGV4ID0gYmFzZUdseXBoSW5kZXggPT09IC0xID8gLTEgOiBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgodGFiLmJhc2VDb3ZlcmFnZSwgZ2x5cGhJZHNbYmFzZUdseXBoSW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAoYmFzZUFyckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWFya1JlY29yZCA9IHRhYi5tYXJrQXJyYXlbbWFya0FyckluZGV4XTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VBbmNob3IgPSB0YWIuYmFzZUFycmF5W2Jhc2VBcnJJbmRleF1bbWFya1JlY29yZC5tYXJrQ2xhc3NdO1xuICAgICAgICAgICAgICAgICAgcG9zaXRpb25zW2dseXBoSW5kZXggKiAzXSA9IGJhc2VBbmNob3IueCAtIG1hcmtSZWNvcmQueCArIHBvc2l0aW9uc1tiYXNlR2x5cGhJbmRleCAqIDNdIC0gcG9zaXRpb25zW2Jhc2VHbHlwaEluZGV4ICogMyArIDJdO1xuICAgICAgICAgICAgICAgICAgcG9zaXRpb25zW2dseXBoSW5kZXggKiAzICsgMV0gPSBiYXNlQW5jaG9yLnkgLSBtYXJrUmVjb3JkLnkgKyBwb3NpdGlvbnNbYmFzZUdseXBoSW5kZXggKiAzICsgMV07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hcmsgdG8gbWFya1xuICAgICAgICAgICAgZWxzZSBpZiAobG9va3VwLmx0eXBlID09PSA2KSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hcmsxQXJySW5kZXggPSBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgodGFiLm1hcmsxQ292ZXJhZ2UsIGdseXBoSWQpO1xuICAgICAgICAgICAgICBpZiAobWFyazFBcnJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2R2x5cGhJbmRleCA9IGdldFByZXZHbHlwaEluZGV4KCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZHbHlwaEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcHJldkdseXBoSWQgPSBnbHlwaElkc1twcmV2R2x5cGhJbmRleF07XG4gICAgICAgICAgICAgICAgICBpZiAoZ2V0R2x5cGhDbGFzcyhmb250LCBwcmV2R2x5cGhJZCkgPT09IDMpIHsgLy8gb25seSBjaGVjayBtYXJrIGdseXBoc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJrMkFyckluZGV4ID0gVHlwci5fbGN0Zi5jb3ZlcmFnZUluZGV4KHRhYi5tYXJrMkNvdmVyYWdlLCBwcmV2R2x5cGhJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXJrMkFyckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmsxUmVjb3JkID0gdGFiLm1hcmsxQXJyYXlbbWFyazFBcnJJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFyazJBbmNob3IgPSB0YWIubWFyazJBcnJheVttYXJrMkFyckluZGV4XVttYXJrMVJlY29yZC5tYXJrQ2xhc3NdO1xuICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tnbHlwaEluZGV4ICogM10gPSBtYXJrMkFuY2hvci54IC0gbWFyazFSZWNvcmQueCArIHBvc2l0aW9uc1twcmV2R2x5cGhJbmRleCAqIDNdIC0gcG9zaXRpb25zW3ByZXZHbHlwaEluZGV4ICogMyArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tnbHlwaEluZGV4ICogMyArIDFdID0gbWFyazJBbmNob3IueSAtIG1hcmsxUmVjb3JkLnkgKyBwb3NpdGlvbnNbcHJldkdseXBoSW5kZXggKiAzICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGtlcm4gdGFibGUgaWYgbm8gR1BPU1xuICAgICAgZWxzZSBpZiAoZm9udC5rZXJuICYmICFmb250LmNmZikge1xuICAgICAgICBjb25zdCBwcmV2R2x5cGhJbmRleCA9IGdldFByZXZHbHlwaEluZGV4KCk7XG4gICAgICAgIGlmIChwcmV2R2x5cGhJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBjb25zdCBpbmQxID0gZm9udC5rZXJuLmdseXBoMS5pbmRleE9mKGdseXBoSWRzW3ByZXZHbHlwaEluZGV4XSk7XG4gICAgICAgICAgaWYgKGluZDEgIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBpbmQyID0gZm9udC5rZXJuLnJ2YWxbaW5kMV0uZ2x5cGgyLmluZGV4T2YoZ2x5cGhJZCk7XG4gICAgICAgICAgICBpZiAoaW5kMiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25zW3ByZXZHbHlwaEluZGV4ICogMyArIDJdICs9IGZvbnQua2Vybi5ydmFsW2luZDFdLnZhbHNbaW5kMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9ucztcblxuICAgIGZ1bmN0aW9uIGdldFByZXZHbHlwaEluZGV4KGZpbHRlcikge1xuICAgICAgZm9yIChsZXQgaSA9IGdseXBoSW5kZXggLSAxOyBpID49MDsgaS0tKSB7XG4gICAgICAgIGlmIChnbHlwaElkc1tpXSAhPT0gLTEgJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKGdseXBoSWRzW2ldKSkpIHtcbiAgICAgICAgICByZXR1cm4gaVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCYXNlR2x5cGgoZ2x5cGhJZCkge1xuICAgICAgcmV0dXJuIGdldEdseXBoQ2xhc3MoZm9udCwgZ2x5cGhJZCkgPT09IDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlWYWx1ZVJlY29yZChzb3VyY2UsIGdpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBwb3NpdGlvbnNbZ2kgKiAzICsgaV0gKz0gc291cmNlW2ldIHx8IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0R2x5cGhDbGFzcyhmb250LCBnbHlwaElkKSB7XG4gICAgY29uc3QgY2xhc3NEZWYgPSBmb250LkdERUYgJiYgZm9udC5HREVGLmdseXBoQ2xhc3NEZWY7XG4gICAgcmV0dXJuIGNsYXNzRGVmID8gVHlwci5VLl9nZXRHbHlwaENsYXNzKGdseXBoSWQsIGNsYXNzRGVmKSA6IDA7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJzdE51bSguLi5hcmdzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2ldXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIFBhcnNlZEZvbnRcbiAgICovXG4gIGZ1bmN0aW9uIHdyYXBGb250T2JqKHR5cHJGb250KSB7XG4gICAgY29uc3QgZ2x5cGhNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgY29uc3Qgb3MyID0gdHlwckZvbnRbJ09TLzInXTtcbiAgICBjb25zdCBoaGVhID0gdHlwckZvbnQuaGhlYTtcbiAgICBjb25zdCB1bml0c1BlckVtID0gdHlwckZvbnQuaGVhZC51bml0c1BlckVtO1xuICAgIGNvbnN0IGFzY2VuZGVyID0gZmlyc3ROdW0ob3MyICYmIG9zMi5zVHlwb0FzY2VuZGVyLCBoaGVhICYmIGhoZWEuYXNjZW5kZXIsIHVuaXRzUGVyRW0pO1xuXG4gICAgLyoqIEB0eXBlIFBhcnNlZEZvbnQgKi9cbiAgICBjb25zdCBmb250T2JqID0ge1xuICAgICAgdW5pdHNQZXJFbSxcbiAgICAgIGFzY2VuZGVyLFxuICAgICAgZGVzY2VuZGVyOiBmaXJzdE51bShvczIgJiYgb3MyLnNUeXBvRGVzY2VuZGVyLCBoaGVhICYmIGhoZWEuZGVzY2VuZGVyLCAwKSxcbiAgICAgIGNhcEhlaWdodDogZmlyc3ROdW0ob3MyICYmIG9zMi5zQ2FwSGVpZ2h0LCBhc2NlbmRlciksXG4gICAgICB4SGVpZ2h0OiBmaXJzdE51bShvczIgJiYgb3MyLnN4SGVpZ2h0LCBhc2NlbmRlciksXG4gICAgICBsaW5lR2FwOiBmaXJzdE51bShvczIgJiYgb3MyLnNUeXBvTGluZUdhcCwgaGhlYSAmJiBoaGVhLmxpbmVHYXApLFxuICAgICAgc3VwcG9ydHNDb2RlUG9pbnQoY29kZSkge1xuICAgICAgICByZXR1cm4gVHlwci5VLmNvZGVUb0dseXBoKHR5cHJGb250LCBjb2RlKSA+IDBcbiAgICAgIH0sXG4gICAgICBmb3JFYWNoR2x5cGgodGV4dCwgZm9udFNpemUsIGxldHRlclNwYWNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBwZW5YID0gMDtcbiAgICAgICAgY29uc3QgZm9udFNjYWxlID0gMSAvIGZvbnRPYmoudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuXG4gICAgICAgIGNvbnN0IGdseXBoSWRzID0gc3RyaW5nVG9HbHlwaHModHlwckZvbnQsIHRleHQpO1xuICAgICAgICBsZXQgY2hhckluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gY2FsY0dseXBoUG9zaXRpb25zKHR5cHJGb250LCBnbHlwaElkcyk7XG5cbiAgICAgICAgZ2x5cGhJZHMuZm9yRWFjaCgoZ2x5cGhJZCwgaSkgPT4ge1xuICAgICAgICAgIC8vIFR5cHIgcmV0dXJucyBhIGdseXBoIGluZGV4IHBlciBzdHJpbmcgY29kZXBvaW50LCB3aXRoIC0xcyBpbiBwbGFjZSBvZiB0aG9zZSB0aGF0XG4gICAgICAgICAgLy8gd2VyZSBvbWl0dGVkIGR1ZSB0byBsaWdhdHVyZSBzdWJzdGl0dXRpb24uIFNvIHdlIGNhbiB0cmFjayBvcmlnaW5hbCBpbmRleCBpbiB0aGVcbiAgICAgICAgICAvLyBzdHJpbmcgdmlhIHNpbXBsZSBpbmNyZW1lbnQsIGFuZCBza2lwIGV2ZXJ5dGhpbmcgZWxzZSB3aGVuIHNlZWluZyBhIC0xLlxuICAgICAgICAgIGlmIChnbHlwaElkICE9PSAtMSkge1xuICAgICAgICAgICAgbGV0IGdseXBoT2JqID0gZ2x5cGhNYXBbZ2x5cGhJZF07XG4gICAgICAgICAgICBpZiAoIWdseXBoT2JqKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtjbWRzLCBjcmRzfSA9IFR5cHIuVS5nbHlwaFRvUGF0aCh0eXByRm9udCwgZ2x5cGhJZCk7XG5cbiAgICAgICAgICAgICAgLy8gQnVpbGQgcGF0aCBzdHJpbmdcbiAgICAgICAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgICAgICAgbGV0IGNyZHNJZHggPSAwO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY21kcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bUFyZ3MgPSBjbWRBcmdMZW5ndGhzW2NtZHNbaV1dO1xuICAgICAgICAgICAgICAgIHBhdGggKz0gY21kc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBudW1BcmdzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHBhdGggKz0gKGogPiAxID8gJywnIDogJycpICsgY3Jkc1tjcmRzSWR4KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEZpbmQgZXh0ZW50cyAtIEdseWYgZ2l2ZXMgdGhpcyBpbiBtZXRhZGF0YSBidXQgbm90IENGRiwgYW5kIFR5cHIgZG9lc24ndFxuICAgICAgICAgICAgICAvLyBub3JtYWxpemUgdGhlIHR3bywgc28gaXQncyBzaW1wbGVzdCBqdXN0IHRvIGl0ZXJhdGUgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICBsZXQgeE1pbiwgeU1pbiwgeE1heCwgeU1heDtcbiAgICAgICAgICAgICAgaWYgKGNyZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgeE1pbiA9IHlNaW4gPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICB4TWF4ID0geU1heCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgbGV0IHggPSBjcmRzW2ldO1xuICAgICAgICAgICAgICAgICAgbGV0IHkgPSBjcmRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgIGlmICh4IDwgeE1pbikgeE1pbiA9IHg7XG4gICAgICAgICAgICAgICAgICBpZiAoeSA8IHlNaW4pIHlNaW4gPSB5O1xuICAgICAgICAgICAgICAgICAgaWYgKHggPiB4TWF4KSB4TWF4ID0geDtcbiAgICAgICAgICAgICAgICAgIGlmICh5ID4geU1heCkgeU1heCA9IHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHhNaW4gPSB4TWF4ID0geU1pbiA9IHlNYXggPSAwO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZ2x5cGhPYmogPSBnbHlwaE1hcFtnbHlwaElkXSA9IHtcbiAgICAgICAgICAgICAgICBpbmRleDogZ2x5cGhJZCxcbiAgICAgICAgICAgICAgICBhZHZhbmNlV2lkdGg6IHR5cHJGb250LmhtdHguYVdpZHRoW2dseXBoSWRdLFxuICAgICAgICAgICAgICAgIHhNaW4sXG4gICAgICAgICAgICAgICAgeU1pbixcbiAgICAgICAgICAgICAgICB4TWF4LFxuICAgICAgICAgICAgICAgIHlNYXgsXG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgZ2x5cGhPYmosXG4gICAgICAgICAgICAgIHBlblggKyBwb3NpdGlvbnNbaSAqIDNdICogZm9udFNjYWxlLFxuICAgICAgICAgICAgICBwb3NpdGlvbnNbaSAqIDMgKyAxXSAqIGZvbnRTY2FsZSxcbiAgICAgICAgICAgICAgY2hhckluZGV4XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBwZW5YICs9IHBvc2l0aW9uc1tpICogMyArIDJdICogZm9udFNjYWxlO1xuICAgICAgICAgICAgaWYgKGxldHRlclNwYWNpbmcpIHtcbiAgICAgICAgICAgICAgcGVuWCArPSBsZXR0ZXJTcGFjaW5nICogZm9udFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoYXJJbmRleCArPSAodGV4dC5jb2RlUG9pbnRBdChjaGFySW5kZXgpID4gMHhmZmZmID8gMiA6IDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGVuWFxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZm9udE9ialxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIEZvbnRQYXJzZXJcbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiBwYXJzZShidWZmZXIpIHtcbiAgICAvLyBMb29rIHRvIHNlZSBpZiB3ZSBoYXZlIGEgV09GRiBmaWxlIGFuZCBjb252ZXJ0IGl0IGlmIHNvOlxuICAgIGNvbnN0IHBlZWsgPSBuZXcgVWludDhBcnJheShidWZmZXIsIDAsIDQpO1xuICAgIGNvbnN0IHRhZyA9IFR5cHIuX2Jpbi5yZWFkQVNDSUkocGVlaywgMCwgNCk7XG4gICAgaWYgKHRhZyA9PT0gJ3dPRkYnKSB7XG4gICAgICBidWZmZXIgPSB3b2ZmMm90ZihidWZmZXIpO1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAnd09GMicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignd29mZjIgZm9udHMgbm90IHN1cHBvcnRlZCcpXG4gICAgfVxuICAgIHJldHVybiB3cmFwRm9udE9iaihUeXByLnBhcnNlKGJ1ZmZlcilbMF0pXG4gIH1cbn1cblxuXG5jb25zdCB3b3JrZXJNb2R1bGUgPSAvKiNfX1BVUkVfXyovZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgbmFtZTogJ1R5cHIgRm9udCBQYXJzZXInLFxuICBkZXBlbmRlbmNpZXM6IFt0eXByRmFjdG9yeSwgd29mZjJvdGZGYWN0b3J5LCBwYXJzZXJGYWN0b3J5XSxcbiAgaW5pdCh0eXByRmFjdG9yeSwgd29mZjJvdGZGYWN0b3J5LCBwYXJzZXJGYWN0b3J5KSB7XG4gICAgY29uc3QgVHlwciA9IHR5cHJGYWN0b3J5KCk7XG4gICAgY29uc3Qgd29mZjJvdGYgPSB3b2ZmMm90ZkZhY3RvcnkoKTtcbiAgICByZXR1cm4gcGFyc2VyRmFjdG9yeShUeXByLCB3b2ZmMm90ZilcbiAgfVxufSk7XG5cbi8qIVxuQ3VzdG9tIGJ1bmRsZSBvZiBAdW5pY29kZS1mb250LXJlc29sdmVyL2NsaWVudCB2MS4wLjIgKGh0dHBzOi8vZ2l0aHViLmNvbS9sb2pqaWMvdW5pY29kZS1mb250LXJlc29sdmVyKVxuZm9yIHVzZSBpbiBUcm9pa2EgdGV4dCByZW5kZXJpbmcuIFxuT3JpZ2luYWwgTUlUIGxpY2Vuc2UgYXBwbGllc1xuKi9cbmZ1bmN0aW9uIHVuaWNvZGVGb250UmVzb2x2ZXJDbGllbnRGYWN0b3J5KCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBuPWZ1bmN0aW9uKCl7dGhpcy5idWNrZXRzPW5ldyBNYXA7fTtuLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7dmFyIG49dD4+NTt0aGlzLmJ1Y2tldHMuc2V0KG4sKHRoaXMuYnVja2V0cy5nZXQobil8fDApfDE8PCgzMSZ0KSk7fSxuLnByb3RvdHlwZS5oYXM9ZnVuY3Rpb24odCl7dmFyIG49dGhpcy5idWNrZXRzLmdldCh0Pj41KTtyZXR1cm4gdm9pZCAwIT09biYmMCE9KG4mMTw8KDMxJnQpKX0sbi5wcm90b3R5cGUuc2VyaWFsaXplPWZ1bmN0aW9uKCl7dmFyIHQ9W107cmV0dXJuIHRoaXMuYnVja2V0cy5mb3JFYWNoKChmdW5jdGlvbihuLHIpe3QucHVzaCgoK3IpLnRvU3RyaW5nKDM2KStcIjpcIituLnRvU3RyaW5nKDM2KSk7fSkpLHQuam9pbihcIixcIil9LG4ucHJvdG90eXBlLmRlc2VyaWFsaXplPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7dGhpcy5idWNrZXRzLmNsZWFyKCksdC5zcGxpdChcIixcIikuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIHI9dC5zcGxpdChcIjpcIik7bi5idWNrZXRzLnNldChwYXJzZUludChyWzBdLDM2KSxwYXJzZUludChyWzFdLDM2KSk7fSkpO307dmFyIHI9TWF0aC5wb3coMiw4KSxlPXItMSxvPX5lO2Z1bmN0aW9uIGEodCl7dmFyIG49ZnVuY3Rpb24odCl7cmV0dXJuIHQmb30odCkudG9TdHJpbmcoMTYpLGU9ZnVuY3Rpb24odCl7cmV0dXJuICh0Jm8pK3ItMX0odCkudG9TdHJpbmcoMTYpO3JldHVybiBcImNvZGVwb2ludC1pbmRleC9wbGFuZVwiKyh0Pj4xNikrXCIvXCIrbitcIi1cIitlK1wiLmpzb25cIn1mdW5jdGlvbiBpKHQsbil7dmFyIHI9dCZlLG89bi5jb2RlUG9pbnRBdChyLzZ8MCk7cmV0dXJuIDAhPSgobz0ob3x8NDgpLTQ4KSYxPDxyJTYpfWZ1bmN0aW9uIHUodCxuKXt2YXIgcjsocj10LHIucmVwbGFjZSgvVVxcKy9naSxcIlwiKS5yZXBsYWNlKC9eLCt8LCskL2csXCJcIikuc3BsaXQoLywrLykubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zcGxpdChcIi1cIikubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gcGFyc2VJbnQodC50cmltKCksMTYpfSkpfSkpKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgcj10WzBdLGU9dFsxXTt2b2lkIDA9PT1lJiYoZT1yKSxuKHIsZSk7fSkpO31mdW5jdGlvbiBjKHQsbil7dSh0LChmdW5jdGlvbih0LHIpe2Zvcih2YXIgZT10O2U8PXI7ZSsrKW4oZSk7fSkpO312YXIgcz17fSxmPXt9LGw9bmV3IFdlYWtNYXAsdj1cImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9naC9sb2pqaWMvdW5pY29kZS1mb250LXJlc29sdmVyQHYxLjAuMS9wYWNrYWdlcy9kYXRhXCI7ZnVuY3Rpb24gZCh0KXt2YXIgcj1sLmdldCh0KTtyZXR1cm4gcnx8KHI9bmV3IG4sYyh0LnJhbmdlcywoZnVuY3Rpb24odCl7cmV0dXJuIHIuYWRkKHQpfSkpLGwuc2V0KHQscikpLHJ9dmFyIGgscD1uZXcgTWFwO2Z1bmN0aW9uIGcodCxuLHIpe3JldHVybiB0W25dP246dFtyXT9yOmZ1bmN0aW9uKHQpe2Zvcih2YXIgbiBpbiB0KXJldHVybiBufSh0KX1mdW5jdGlvbiB3KHQsbil7dmFyIHI9bjtpZighdC5pbmNsdWRlcyhyKSl7cj0xLzA7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKyspTWF0aC5hYnModFtlXS1uKTxNYXRoLmFicyhyLW4pJiYocj10W2VdKTt9cmV0dXJuIHJ9ZnVuY3Rpb24gayh0KXtyZXR1cm4gaHx8KGg9bmV3IFNldCxjKFwiOS1ELDIwLDg1LEEwLDE2ODAsMjAwMC0yMDBBLDIwMjgtMjAyRiwyMDVGLDMwMDBcIiwoZnVuY3Rpb24odCl7aC5hZGQodCk7fSkpKSxoLmhhcyh0KX1yZXR1cm4gdC5Db2RlUG9pbnRTZXQ9bix0LmNsZWFyQ2FjaGU9ZnVuY3Rpb24oKXtzPXt9LGY9e307fSx0LmdldEZvbnRzRm9yU3RyaW5nPWZ1bmN0aW9uKHQsbil7dm9pZCAwPT09biYmKG49e30pO3ZhciByLGU9bi5sYW5nO3ZvaWQgMD09PWUmJihlPS9cXHB7U2NyaXB0PUhhbmd1bH0vdS50ZXN0KHI9dCk/XCJrb1wiOi9cXHB7U2NyaXB0PUhpcmFnYW5hfXxcXHB7U2NyaXB0PUthdGFrYW5hfS91LnRlc3Qocik/XCJqYVwiOlwiZW5cIik7dmFyIG89bi5jYXRlZ29yeTt2b2lkIDA9PT1vJiYobz1cInNhbnMtc2VyaWZcIik7dmFyIHU9bi5zdHlsZTt2b2lkIDA9PT11JiYodT1cIm5vcm1hbFwiKTt2YXIgYz1uLndlaWdodDt2b2lkIDA9PT1jJiYoYz00MDApO3ZhciBsPShuLmRhdGFVcmx8fHYpLnJlcGxhY2UoL1xcLyQvZyxcIlwiKSxoPW5ldyBNYXAseT1uZXcgVWludDhBcnJheSh0Lmxlbmd0aCksYj17fSxtPXt9LEE9bmV3IEFycmF5KHQubGVuZ3RoKSxTPW5ldyBNYXAsaj0hMTtmdW5jdGlvbiBNKHQpe3ZhciBuPXAuZ2V0KHQpO3JldHVybiBufHwobj1mZXRjaChsK1wiL1wiK3QpLnRoZW4oKGZ1bmN0aW9uKHQpe2lmKCF0Lm9rKXRocm93IG5ldyBFcnJvcih0LnN0YXR1c1RleHQpO3JldHVybiB0Lmpzb24oKS50aGVuKChmdW5jdGlvbih0KXtpZighQXJyYXkuaXNBcnJheSh0KXx8MSE9PXRbMF0pdGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IHNjaGVtYSB2ZXJzaW9uOyBuZWVkIDEsIGdvdCBcIit0WzBdKTtyZXR1cm4gdFsxXX0pKX0pKS5jYXRjaCgoZnVuY3Rpb24obil7aWYobCE9PXYpcmV0dXJuIGp8fChjb25zb2xlLmVycm9yKCd1bmljb2RlLWZvbnQtcmVzb2x2ZXI6IEZhaWxlZCBsb2FkaW5nIGZyb20gZGF0YVVybCBcIicrbCsnXCIsIHRyeWluZyBkZWZhdWx0IENETi4gJytuLm1lc3NhZ2UpLGo9ITApLGw9dixwLmRlbGV0ZSh0KSxNKHQpO3Rocm93IG59KSkscC5zZXQodCxuKSksbn1mb3IodmFyIFA9ZnVuY3Rpb24obil7dmFyIHI9dC5jb2RlUG9pbnRBdChuKSxlPWEocik7QVtuXT1lLHNbZV18fFMuaGFzKGUpfHxTLnNldChlLE0oZSkudGhlbigoZnVuY3Rpb24odCl7c1tlXT10O30pKSkscj42NTUzNSYmKG4rKyxFPW4pO30sRT0wO0U8dC5sZW5ndGg7RSsrKVAoRSk7cmV0dXJuIFByb21pc2UuYWxsKFMudmFsdWVzKCkpLnRoZW4oKGZ1bmN0aW9uKCl7Uy5jbGVhcigpO2Zvcih2YXIgbj1mdW5jdGlvbihuKXt2YXIgbz10LmNvZGVQb2ludEF0KG4pLGE9bnVsbCx1PXNbQVtuXV0sYz12b2lkIDA7Zm9yKHZhciBsIGluIHUpe3ZhciB2PW1bbF07aWYodm9pZCAwPT09diYmKHY9bVtsXT1uZXcgUmVnRXhwKGwpLnRlc3QoZXx8XCJlblwiKSksdil7Zm9yKHZhciBkIGluIGM9bCx1W2xdKWlmKGkobyx1W2xdW2RdKSl7YT1kO2JyZWFrfWJyZWFrfX1pZighYSl0OmZvcih2YXIgaCBpbiB1KWlmKGghPT1jKWZvcih2YXIgcCBpbiB1W2hdKWlmKGkobyx1W2hdW3BdKSl7YT1wO2JyZWFrIHR9YXx8KGNvbnNvbGUuZGVidWcoXCJObyBmb250IGNvdmVyYWdlIGZvciBVK1wiK28udG9TdHJpbmcoMTYpKSxhPVwibGF0aW5cIiksQVtuXT1hLGZbYV18fFMuaGFzKGEpfHxTLnNldChhLE0oXCJmb250LW1ldGEvXCIrYStcIi5qc29uXCIpLnRoZW4oKGZ1bmN0aW9uKHQpe2ZbYV09dDt9KSkpLG8+NjU1MzUmJihuKysscj1uKTt9LHI9MDtyPHQubGVuZ3RoO3IrKyluKHIpO3JldHVybiBQcm9taXNlLmFsbChTLnZhbHVlcygpKX0pKS50aGVuKChmdW5jdGlvbigpe2Zvcih2YXIgbixyPW51bGwsZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgYT10LmNvZGVQb2ludEF0KGUpO2lmKHImJihrKGEpfHxkKHIpLmhhcyhhKSkpeVtlXT15W2UtMV07ZWxzZSB7cj1mW0FbZV1dO3ZhciBpPWJbci5pZF07aWYoIWkpe3ZhciBzPXIudHlwZWZvcm1zLHY9ZyhzLG8sXCJzYW5zLXNlcmlmXCIpLHA9ZyhzW3ZdLHUsXCJub3JtYWxcIiksbT13KG51bGw9PT0obj1zW3ZdKXx8dm9pZCAwPT09bj92b2lkIDA6bltwXSxjKTtpPWJbci5pZF09bCtcIi9mb250LWZpbGVzL1wiK3IuaWQrXCIvXCIrditcIi5cIitwK1wiLlwiK20rXCIud29mZlwiO312YXIgUz1oLmdldChpKTtudWxsPT1TJiYoUz1oLnNpemUsaC5zZXQoaSxTKSkseVtlXT1TO31hPjY1NTM1JiYoZSsrLHlbZV09eVtlLTFdKTt9cmV0dXJuIHtmb250VXJsczpBcnJheS5mcm9tKGgua2V5cygpKSxjaGFyczp5fX0pKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdH0oe30pfVxuXG4vKipcbiAqIEB0eXBlZGVmIHtzdHJpbmcgfCB7c3JjOnN0cmluZywgbGFiZWw/OnN0cmluZywgdW5pY29kZVJhbmdlPzpzdHJpbmcsIGxhbmc/OnN0cmluZ319IFVzZXJGb250XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Q2xpZW50T3B0aW9uc30gRm9udFJlc29sdmVyT3B0aW9uc1xuICogQHByb3BlcnR5IHtBcnJheTxVc2VyRm9udD58VXNlckZvbnR9IFtmb250c11cbiAqIEBwcm9wZXJ0eSB7J25vcm1hbCd8J2l0YWxpYyd9IFtzdHlsZV1cbiAqIEBwcm9wZXJ0eSB7J25vcm1hbCd8J2JvbGQnfG51bWJlcn0gW3N0eWxlXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1bmljb2RlRm9udHNVUkxdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGb250UmVzb2x2ZXJSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gY2hhcnNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8UGFyc2VkRm9udCAmIHtzcmM6c3RyaW5nfT59IGZvbnRzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb259IEZvbnRSZXNvbHZlclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7KEZvbnRSZXNvbHZlclJlc3VsdCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7Rm9udFJlc29sdmVyT3B0aW9uc30gW29wdGlvbnNdXG4gKi9cblxuLyoqXG4gKiBGYWN0b3J5IGZvciB0aGUgRm9udFJlc29sdmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGb250UGFyc2VyfSBmb250UGFyc2VyXG4gKiBAcGFyYW0ge3tnZXRGb250c0ZvclN0cmluZzogZnVuY3Rpb24sIENvZGVQb2ludFNldDogZnVuY3Rpb259fSB1bmljb2RlRm9udFJlc29sdmVyQ2xpZW50XG4gKiBAcmV0dXJuIHtGb250UmVzb2x2ZXJ9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZvbnRSZXNvbHZlcihmb250UGFyc2VyLCB1bmljb2RlRm9udFJlc29sdmVyQ2xpZW50KSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgUGFyc2VkRm9udD59XG4gICAqL1xuICBjb25zdCBwYXJzZWRGb250cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBBcnJheTwoUGFyc2VkRm9udCkgPT4gdm9pZD4+fVxuICAgKi9cbiAgY29uc3QgbG9hZGluZ0ZvbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvKipcbiAgICogTG9hZCBhIGdpdmVuIGZvbnQgdXJsXG4gICAqL1xuICBmdW5jdGlvbiBkb0xvYWRGb250KHVybCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBvbkVycm9yID0gZXJyID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWx1cmUgbG9hZGluZyBmb250ICR7dXJsfWAsIGVycik7XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgcmVxdWVzdC5vcGVuKCdnZXQnLCB1cmwsIHRydWUpO1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgICBvbkVycm9yKG5ldyBFcnJvcihyZXF1ZXN0LnN0YXR1c1RleHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXF1ZXN0LnN0YXR1cyA+IDApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZm9udE9iaiA9IGZvbnRQYXJzZXIocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICBmb250T2JqLnNyYyA9IHVybDtcbiAgICAgICAgICAgIGNhbGxiYWNrKGZvbnRPYmopO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVxdWVzdC5vbmVycm9yID0gb25FcnJvcjtcbiAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICBvbkVycm9yKGVycik7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogTG9hZCBhIGdpdmVuIGZvbnQgdXJsIGlmIG5lZWRlZCwgaW52b2tpbmcgYSBjYWxsYmFjayB3aGVuIGl0J3MgbG9hZGVkLiBJZiBhbHJlYWR5XG4gICAqIGxvYWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb250VXJsXG4gICAqIEBwYXJhbSB7KGZvbnQ6IFBhcnNlZEZvbnQpID0+IHZvaWR9IGNhbGxiYWNrXG4gICAqL1xuICBmdW5jdGlvbiBsb2FkRm9udChmb250VXJsLCBjYWxsYmFjaykge1xuICAgIGxldCBmb250ID0gcGFyc2VkRm9udHNbZm9udFVybF07XG4gICAgaWYgKGZvbnQpIHtcbiAgICAgIGNhbGxiYWNrKGZvbnQpO1xuICAgIH0gZWxzZSBpZiAobG9hZGluZ0ZvbnRzW2ZvbnRVcmxdKSB7XG4gICAgICBsb2FkaW5nRm9udHNbZm9udFVybF0ucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRpbmdGb250c1tmb250VXJsXSA9IFtjYWxsYmFja107XG4gICAgICBkb0xvYWRGb250KGZvbnRVcmwsIGZvbnRPYmogPT4ge1xuICAgICAgICBmb250T2JqLnNyYyA9IGZvbnRVcmw7XG4gICAgICAgIHBhcnNlZEZvbnRzW2ZvbnRVcmxdID0gZm9udE9iajtcbiAgICAgICAgbG9hZGluZ0ZvbnRzW2ZvbnRVcmxdLmZvckVhY2goY2IgPT4gY2IoZm9udE9iaikpO1xuICAgICAgICBkZWxldGUgbG9hZGluZ0ZvbnRzW2ZvbnRVcmxdO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvciBhIGdpdmVuIHN0cmluZyBvZiB0ZXh0LCBkZXRlcm1pbmUgd2hpY2ggZm9udHMgYXJlIHJlcXVpcmVkIHRvIGZ1bGx5IHJlbmRlciBpdCBhbmRcbiAgICogZW5zdXJlIHRob3NlIGZvbnRzIGFyZSBsb2FkZWQuXG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gKHRleHQsIGNhbGxiYWNrLCB7XG4gICAgbGFuZyxcbiAgICBmb250czogdXNlckZvbnRzID0gW10sXG4gICAgc3R5bGUgPSAnbm9ybWFsJyxcbiAgICB3ZWlnaHQgPSAnbm9ybWFsJyxcbiAgICB1bmljb2RlRm9udHNVUkxcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgY2hhclJlc29sdXRpb25zID0gbmV3IFVpbnQ4QXJyYXkodGV4dC5sZW5ndGgpO1xuICAgIGNvbnN0IGZvbnRSZXNvbHV0aW9ucyA9IFtdO1xuICAgIGlmICghdGV4dC5sZW5ndGgpIHtcbiAgICAgIGFsbERvbmUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb250SW5kaWNlcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBmYWxsYmFja1JhbmdlcyA9IFtdOyAvLyBbW3N0YXJ0LCBlbmRdLCAuLi5dXG5cbiAgICBpZiAoc3R5bGUgIT09ICdpdGFsaWMnKSBzdHlsZSA9ICdub3JtYWwnO1xuICAgIGlmICh0eXBlb2Ygd2VpZ2h0ICE9PSAnbnVtYmVyJykge1xuICAgICAgd2VpZ2h0ID0gd2VpZ2h0ID09PSAnYm9sZCcgPyA3MDAgOiA0MDA7XG4gICAgfVxuXG4gICAgaWYgKHVzZXJGb250cyAmJiAhQXJyYXkuaXNBcnJheSh1c2VyRm9udHMpKSB7XG4gICAgICB1c2VyRm9udHMgPSBbdXNlckZvbnRzXTtcbiAgICB9XG4gICAgdXNlckZvbnRzID0gdXNlckZvbnRzLnNsaWNlKClcbiAgICAgIC8vIGZpbHRlciBieSBsYW5ndWFnZVxuICAgICAgLmZpbHRlcihkZWYgPT4gIWRlZi5sYW5nIHx8IGRlZi5sYW5nLnRlc3QobGFuZykpXG4gICAgICAvLyBzd2l0Y2ggb3JkZXIgZm9yIGVhc2llciBpdGVyYXRpb25cbiAgICAgIC5yZXZlcnNlKCk7XG4gICAgaWYgKHVzZXJGb250cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IFVOS05PV04gPSAwO1xuICAgICAgY29uc3QgUkVTT0xWRUQgPSAxO1xuICAgICAgY29uc3QgTkVFRFNfRkFMTEJBQ0sgPSAyO1xuICAgICAgbGV0IHByZXZDaGFyUmVzdWx0ID0gVU5LTk9XTlxuXG4gICAgICA7KGZ1bmN0aW9uIHJlc29sdmVVc2VyRm9udHMgKHN0YXJ0SW5kZXggPSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4LCBpTGVuID0gdGV4dC5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSB0ZXh0LmNvZGVQb2ludEF0KGkpO1xuICAgICAgICAgIC8vIENhcnJ5IHByZXZpb3VzIGNoYXJhY3RlcidzIHJlc3VsdCBmb3J3YXJkIGlmOlxuICAgICAgICAgIC8vIC0gaXQgcmVzb2x2ZWQgdG8gYSBmb250IHRoYXQgYWxzbyBjb3ZlcnMgdGhpcyBjaGFyYWN0ZXJcbiAgICAgICAgICAvLyAtIHRoaXMgY2hhcmFjdGVyIGlzIHdoaXRlc3BhY2VcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAocHJldkNoYXJSZXN1bHQgPT09IFJFU09MVkVEICYmIGZvbnRSZXNvbHV0aW9uc1tjaGFyUmVzb2x1dGlvbnNbaSAtIDFdXS5zdXBwb3J0c0NvZGVQb2ludChjb2RlUG9pbnQpKSB8fFxuICAgICAgICAgICAgL1xccy8udGVzdCh0ZXh0W2ldKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY2hhclJlc29sdXRpb25zW2ldID0gY2hhclJlc29sdXRpb25zW2kgLSAxXTtcbiAgICAgICAgICAgIGlmIChwcmV2Q2hhclJlc3VsdCA9PT0gTkVFRFNfRkFMTEJBQ0spIHtcbiAgICAgICAgICAgICAgZmFsbGJhY2tSYW5nZXNbZmFsbGJhY2tSYW5nZXMubGVuZ3RoIC0gMV1bMV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGNoYXJSZXNvbHV0aW9uc1tpXSwgakxlbiA9IHVzZXJGb250cy5sZW5ndGg7IGogPD0gakxlbjsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChqID09PSBqTGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9uZSBvZiB0aGUgdXNlciBmb250cyBtYXRjaGVkOyBuZWVkcyBmYWxsYmFja1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcHJldkNoYXJSZXN1bHQgPT09IE5FRURTX0ZBTExCQUNLID9cbiAgICAgICAgICAgICAgICAgIGZhbGxiYWNrUmFuZ2VzW2ZhbGxiYWNrUmFuZ2VzLmxlbmd0aCAtIDFdIDpcbiAgICAgICAgICAgICAgICAgIChmYWxsYmFja1Jhbmdlc1tmYWxsYmFja1Jhbmdlcy5sZW5ndGhdID0gW2ksIGldKTtcbiAgICAgICAgICAgICAgICByYW5nZVsxXSA9IGk7XG4gICAgICAgICAgICAgICAgcHJldkNoYXJSZXN1bHQgPSBORUVEU19GQUxMQkFDSztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFyUmVzb2x1dGlvbnNbaV0gPSBqO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3JjLCB1bmljb2RlUmFuZ2UgfSA9IHVzZXJGb250c1tqXTtcbiAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgYnkgb3B0aW9uYWwgZXhwbGljaXQgdW5pY29kZSByYW5nZXNcbiAgICAgICAgICAgICAgICBpZiAoIXVuaWNvZGVSYW5nZSB8fCBpc0NvZGVJblJhbmdlcyhjb2RlUG9pbnQsIHVuaWNvZGVSYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZvbnRPYmogPSBwYXJzZWRGb250c1tzcmNdO1xuICAgICAgICAgICAgICAgICAgLy8gZm9udCBub3QgeWV0IGxvYWRlZCwgbG9hZCBpdCBhbmQgcmVzdW1lXG4gICAgICAgICAgICAgICAgICBpZiAoIWZvbnRPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZEZvbnQoc3JjLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVVzZXJGb250cyhpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmb250IGFjdHVhbGx5IGNvbnRhaW5zIGEgZ2x5cGggZm9yIHRoaXMgY2hhciwgbG9jayBpdCBpblxuICAgICAgICAgICAgICAgICAgaWYgKGZvbnRPYmouc3VwcG9ydHNDb2RlUG9pbnQoY29kZVBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm9udEluZGV4ID0gZm9udEluZGljZXMuZ2V0KGZvbnRPYmopO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvbnRJbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb250SW5kZXggPSBmb250UmVzb2x1dGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgIGZvbnRSZXNvbHV0aW9ucy5wdXNoKGZvbnRPYmopO1xuICAgICAgICAgICAgICAgICAgICAgIGZvbnRJbmRpY2VzLnNldChmb250T2JqLCBmb250SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJSZXNvbHV0aW9uc1tpXSA9IGZvbnRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgcHJldkNoYXJSZXN1bHQgPSBSRVNPTFZFRDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4ZmZmZiAmJiBpICsgMSA8IGlMZW4pIHtcbiAgICAgICAgICAgIGNoYXJSZXNvbHV0aW9uc1tpICsgMV0gPSBjaGFyUmVzb2x1dGlvbnNbaV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAocHJldkNoYXJSZXN1bHQgPT09IE5FRURTX0ZBTExCQUNLKSB7XG4gICAgICAgICAgICAgIGZhbGxiYWNrUmFuZ2VzW2ZhbGxiYWNrUmFuZ2VzLmxlbmd0aCAtIDFdWzFdID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZUZhbGxiYWNrcygpO1xuICAgICAgfSkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmFsbGJhY2tSYW5nZXMucHVzaChbMCwgdGV4dC5sZW5ndGggLSAxXSk7XG4gICAgICByZXNvbHZlRmFsbGJhY2tzKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZUZhbGxiYWNrcygpIHtcbiAgICAgIGlmIChmYWxsYmFja1Jhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gQ29tYmluZSBhbGwgZmFsbGJhY2sgc3Vic3RyaW5ncyBpbnRvIGEgc2luZ2xlIHN0cmluZyBmb3IgcXVlcnlpbmdcbiAgICAgICAgY29uc3QgZmFsbGJhY2tTdHJpbmcgPSBmYWxsYmFja1Jhbmdlcy5tYXAocmFuZ2UgPT4gdGV4dC5zdWJzdHJpbmcocmFuZ2VbMF0sIHJhbmdlWzFdICsgMSkpLmpvaW4oJ1xcbicpO1xuICAgICAgICB1bmljb2RlRm9udFJlc29sdmVyQ2xpZW50LmdldEZvbnRzRm9yU3RyaW5nKGZhbGxiYWNrU3RyaW5nLCB7XG4gICAgICAgICAgbGFuZzogbGFuZyB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgd2VpZ2h0LFxuICAgICAgICAgIGRhdGFVcmw6IHVuaWNvZGVGb250c1VSTFxuICAgICAgICB9KS50aGVuKCh7Zm9udFVybHMsIGNoYXJzfSkgPT4ge1xuICAgICAgICAgIC8vIEV4dHJhY3QgcmVzdWx0cyBhbmQgcHV0IHRoZW0gYmFjayBpbiB0aGUgbWFpbiBhcnJheVxuICAgICAgICAgIGNvbnN0IGZvbnRJbmRleE9mZnNldCA9IGZvbnRSZXNvbHV0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgbGV0IGNoYXJJZHggPSAwO1xuICAgICAgICAgIGZhbGxiYWNrUmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGVuZElkeCA9IHJhbmdlWzFdIC0gcmFuZ2VbMF07IGkgPD0gZW5kSWR4OyBpKyspIHtcbiAgICAgICAgICAgICAgY2hhclJlc29sdXRpb25zW3JhbmdlWzBdICsgaV0gPSBjaGFyc1tjaGFySWR4KytdICsgZm9udEluZGV4T2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhcklkeCsrOyAvL3NraXAgc2VnbWVudCBzZXBhcmF0b3JcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIExvYWQgYW5kIHBhcnNlIHRoZSBmYWxsYmFjayBmb250cyAtIGF2b2lkaW5nIFByb21pc2UgaGVyZSB0byBwcmV2ZW50IHBvbHlmaWxscyBpbiB0aGUgd29ya2VyXG4gICAgICAgICAgbGV0IGxvYWRlZENvdW50ID0gMDtcbiAgICAgICAgICBmb250VXJscy5mb3JFYWNoKCh1cmwsIGkpID0+IHtcbiAgICAgICAgICAgIGxvYWRGb250KHVybCwgZm9udE9iaiA9PiB7XG4gICAgICAgICAgICAgIGZvbnRSZXNvbHV0aW9uc1tpICsgZm9udEluZGV4T2Zmc2V0XSA9IGZvbnRPYmo7XG4gICAgICAgICAgICAgIGlmICgrK2xvYWRlZENvdW50ID09PSBmb250VXJscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhbGxEb25lKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbERvbmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbGxEb25lKCkge1xuICAgICAgY2FsbGJhY2soe1xuICAgICAgICBjaGFyczogY2hhclJlc29sdXRpb25zLFxuICAgICAgICBmb250czogZm9udFJlc29sdXRpb25zXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0NvZGVJblJhbmdlcyhjb2RlLCByYW5nZXMpIHtcbiAgICAgIC8vIHRvZG8gb3B0aW1pemUgc2VhcmNoIC0gQ29kZVBvaW50U2V0IGZyb20gdW5pY29kZS1mb250LXJlc29sdmVyP1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByYW5nZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmQgPSBzdGFydF0gPSByYW5nZXNba107XG4gICAgICAgIGlmIChzdGFydCA8PSBjb2RlICYmIGNvZGUgPD0gZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGZvbnRSZXNvbHZlcldvcmtlck1vZHVsZSA9IC8qI19fUFVSRV9fKi9kZWZpbmVXb3JrZXJNb2R1bGUoe1xuICBuYW1lOiAnRm9udFJlc29sdmVyJyxcbiAgZGVwZW5kZW5jaWVzOiBbXG4gICAgY3JlYXRlRm9udFJlc29sdmVyLFxuICAgIHdvcmtlck1vZHVsZSxcbiAgICB1bmljb2RlRm9udFJlc29sdmVyQ2xpZW50RmFjdG9yeSxcbiAgXSxcbiAgaW5pdChjcmVhdGVGb250UmVzb2x2ZXIsIGZvbnRQYXJzZXIsIHVuaWNvZGVGb250UmVzb2x2ZXJDbGllbnRGYWN0b3J5KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZvbnRSZXNvbHZlcihmb250UGFyc2VyLCB1bmljb2RlRm9udFJlc29sdmVyQ2xpZW50RmFjdG9yeSgpKTtcbiAgfVxufSk7XG5cbi8qKlxuICogQHR5cGVkZWYge251bWJlcnwnbGVmdCd8J2NlbnRlcid8J3JpZ2h0J30gQW5jaG9yWFZhbHVlXG4gKi9cbi8qKlxuICogQHR5cGVkZWYge251bWJlcnwndG9wJ3wndG9wLWJhc2VsaW5lJ3wndG9wLWNhcCd8J3RvcC1leCd8J21pZGRsZSd8J2JvdHRvbS1iYXNlbGluZSd8J2JvdHRvbSd9IEFuY2hvcllWYWx1ZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gVHlwZXNldFBhcmFtc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHRleHRcbiAqIEBwcm9wZXJ0eSB7VXNlckZvbnR8VXNlckZvbnRbXX0gW2ZvbnRdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xhbmddXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3NkZkdseXBoU2l6ZT02NF1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZm9udFNpemU9MV1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfCdub3JtYWwnfCdib2xkJ30gW2ZvbnRXZWlnaHQ9J25vcm1hbCddXG4gKiBAcHJvcGVydHkgeydub3JtYWwnfCdpdGFsaWMnfSBbZm9udFN0eWxlPSdub3JtYWwnXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsZXR0ZXJTcGFjaW5nPTBdXG4gKiBAcHJvcGVydHkgeydub3JtYWwnfG51bWJlcn0gW2xpbmVIZWlnaHQ9J25vcm1hbCddXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFdpZHRoXVxuICogQHByb3BlcnR5IHsnbHRyJ3wncnRsJ30gW2RpcmVjdGlvbj0nbHRyJ11cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdGV4dEFsaWduPSdsZWZ0J11cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGV4dEluZGVudD0wXVxuICogQHByb3BlcnR5IHsnbm9ybWFsJ3wnbm93cmFwJ30gW3doaXRlU3BhY2U9J25vcm1hbCddXG4gKiBAcHJvcGVydHkgeydub3JtYWwnfCdicmVhay13b3JkJ30gW292ZXJmbG93V3JhcD0nbm9ybWFsJ11cbiAqIEBwcm9wZXJ0eSB7QW5jaG9yWFZhbHVlfSBbYW5jaG9yWD0wXVxuICogQHByb3BlcnR5IHtBbmNob3JZVmFsdWV9IFthbmNob3JZPTBdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFttZXRyaWNzT25seT1mYWxzZV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdW5pY29kZUZvbnRzVVJMXVxuICogQHByb3BlcnR5IHtGb250UmVzb2x2ZXJSZXN1bHR9IFtwcmVSZXNvbHZlZEZvbnRzXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbaW5jbHVkZUNhcmV0UG9zaXRpb25zPWZhbHNlXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjaHVua2VkQm91bmRzU2l6ZT04MTkyXVxuICogQHByb3BlcnR5IHt7W3JhbmdlU3RhcnRJbmRleF06IG51bWJlcn19IFtjb2xvclJhbmdlc11cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFR5cGVzZXRSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7VWludDE2QXJyYXl9IGdseXBoSWRzIGlkIGZvciBlYWNoIGdseXBoLCBzcGVjaWZpYyB0byB0aGF0IGdseXBoJ3MgZm9udFxuICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBnbHlwaEZvbnRJbmRpY2VzIGluZGV4IGludG8gZm9udERhdGEgZm9yIGVhY2ggZ2x5cGhcbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBnbHlwaFBvc2l0aW9ucyB4LHkgb2YgZWFjaCBnbHlwaCdzIG9yaWdpbiBpbiBsYXlvdXRcbiAqIEBwcm9wZXJ0eSB7e1tmb250XToge1tnbHlwaElkXToge3BhdGg6IHN0cmluZywgcGF0aEJvdW5kczogbnVtYmVyW119fX19IGdseXBoRGF0YSBkYXRhIGFib3V0IGVhY2ggZ2x5cGggYXBwZWFyaW5nIGluIHRoZSB0ZXh0XG4gKiBAcHJvcGVydHkge1R5cGVzZXRGb250RGF0YVtdfSBmb250RGF0YSBkYXRhIGFib3V0IGVhY2ggZm9udCB1c2VkIGluIHRoZSB0ZXh0XG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gW2NhcmV0UG9zaXRpb25zXSBzdGFydFgsZW5kWCxib3R0b21ZIGNhcmV0IHBvc2l0aW9ucyBmb3IgZWFjaCBjaGFyXG4gKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IFtnbHlwaENvbG9yc10gY29sb3IgZm9yIGVhY2ggZ2x5cGgsIGlmIGNvbG9yIHJhbmdlcyBzdXBwbGllZFxuICogICAgICAgICBjaHVua2VkQm91bmRzLCAvL3RvdGFsIHJlY3RzIHBlciAobj1jaHVua2VkQm91bmRzU2l6ZSkgY29uc2VjdXRpdmUgZ2x5cGhzXG4gKiAgICAgICAgIGZvbnRTaXplLCAvL2NhbGN1bGF0ZWQgZW0gaGVpZ2h0XG4gKiAgICAgICAgIHRvcEJhc2VsaW5lOiBhbmNob3JZT2Zmc2V0ICsgbGluZXNbMF0uYmFzZWxpbmUsIC8veSBjb29yZGluYXRlIG9mIHRoZSB0b3AgbGluZSdzIGJhc2VsaW5lXG4gKiAgICAgICAgIGJsb2NrQm91bmRzOiBbIC8vYm91bmRzIGZvciB0aGUgd2hvbGUgYmxvY2sgb2YgdGV4dCwgaW5jbHVkaW5nIHZlcnRpY2FsIHBhZGRpbmcgZm9yIGxpbmVIZWlnaHRcbiAqICAgICAgICAgICBhbmNob3JYT2Zmc2V0LFxuICogICAgICAgICAgIGFuY2hvcllPZmZzZXQgLSB0b3RhbEhlaWdodCxcbiAqICAgICAgICAgICBhbmNob3JYT2Zmc2V0ICsgbWF4TGluZVdpZHRoLFxuICogICAgICAgICAgIGFuY2hvcllPZmZzZXRcbiAqICAgICAgICAgXSxcbiAqICAgICAgICAgdmlzaWJsZUJvdW5kcywgLy90b3RhbCBib3VuZHMgb2YgdmlzaWJsZSB0ZXh0IHBhdGhzLCBtYXkgYmUgbGFyZ2VyIG9yIHNtYWxsZXIgdGhhbiBibG9ja0JvdW5kc1xuICogICAgICAgICB0aW1pbmdzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUeXBlc2V0Rm9udERhdGFcbiAqIEBwcm9wZXJ0eSBzcmNcbiAqIEBwcm9wZXJ0eSB1bml0c1BlckVtXG4gKiBAcHJvcGVydHkgYXNjZW5kZXJcbiAqIEBwcm9wZXJ0eSBkZXNjZW5kZXJcbiAqIEBwcm9wZXJ0eSBsaW5lSGVpZ2h0XG4gKiBAcHJvcGVydHkgY2FwSGVpZ2h0XG4gKiBAcHJvcGVydHkgeEhlaWdodFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9ufSBUeXBlc2V0dGVyVHlwZXNldEZ1bmN0aW9uIC0gY29tcHV0ZSBmb250cyBhbmQgbGF5b3V0IGZvciBzb21lIHRleHQuXG4gKiBAcGFyYW0ge1R5cGVzZXRQYXJhbXN9IHBhcmFtc1xuICogQHBhcmFtIHsoVHlwZXNldFJlc3VsdCkgPT4gdm9pZH0gY2FsbGJhY2sgLSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0eXBlc2V0dGluZyBpcyBjb21wbGV0ZS5cbiAqICAgIElmIHRoZSBwYXJhbXMgaW5jbHVkZWQgYHByZVJlc29sdmVkRm9udHNgLCB0aGlzIHdpbGwgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb259IFR5cGVzZXR0ZXJNZWFzdXJlRnVuY3Rpb24gLSBjb21wdXRlIHdpZHRoL2hlaWdodCBmb3Igc29tZSB0ZXh0LlxuICogQHBhcmFtIHtUeXBlc2V0UGFyYW1zfSBwYXJhbXNcbiAqIEBwYXJhbSB7KHdpZHRoOm51bWJlciwgaGVpZ2h0Om51bWJlcikgPT4gdm9pZH0gY2FsbGJhY2sgLSBmdW5jdGlvbiBjYWxsZWQgd2hlbiBtZWFzdXJlbWVudCBpcyBjb21wbGV0ZS5cbiAqICAgIElmIHRoZSBwYXJhbXMgaW5jbHVkZWQgYHByZVJlc29sdmVkRm9udHNgLCB0aGlzIHdpbGwgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkuXG4gKi9cblxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgc2VsZi1jb250YWluZWQgZW52aXJvbm1lbnQgZm9yIHByb2Nlc3NpbmcgdGV4dCB0eXBlc2V0dGluZyByZXF1ZXN0cy5cbiAqXG4gKiBJdCBpcyBpbXBvcnRhbnQgdGhhdCB0aGlzIGZ1bmN0aW9uIGhhcyBubyBjbG9zdXJlIGRlcGVuZGVuY2llcywgc28gdGhhdCBpdCBjYW4gYmUgZWFzaWx5IGluamVjdGVkXG4gKiBpbnRvIHRoZSBzb3VyY2UgZm9yIGEgV29ya2VyIHdpdGhvdXQgcmVxdWlyaW5nIGEgYnVpbGQgc3RlcCBvciBjb21wbGV4IGRlcGVuZGVuY3kgbG9hZGluZy4gQWxsIGl0c1xuICogZGVwZW5kZW5jaWVzIG11c3QgYmUgcGFzc2VkIGluIGF0IGluaXRpYWxpemF0aW9uLlxuICpcbiAqIEBwYXJhbSB7Rm9udFJlc29sdmVyfSByZXNvbHZlRm9udHMgLSBmdW5jdGlvbiB0byByZXNvbHZlIGEgc3RyaW5nIHRvIHBhcnNlZCBmb250c1xuICogQHBhcmFtIHtvYmplY3R9IGJpZGkgLSB0aGUgYmlkaS5qcyBpbXBsZW1lbnRhdGlvbiBvYmplY3RcbiAqIEByZXR1cm4ge3t0eXBlc2V0OiBUeXBlc2V0dGVyVHlwZXNldEZ1bmN0aW9uLCBtZWFzdXJlOiBUeXBlc2V0dGVyTWVhc3VyZUZ1bmN0aW9ufX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHlwZXNldHRlcihyZXNvbHZlRm9udHMsIGJpZGkpIHtcbiAgY29uc3QgSU5GID0gSW5maW5pdHk7XG5cbiAgLy8gU2V0IG9mIFVuaWNvZGUgRGVmYXVsdF9JZ25vcmFibGVfQ29kZV9Qb2ludCBjaGFyYWN0ZXJzLCB0aGVzZSB3aWxsIG5vdCBwcm9kdWNlIHZpc2libGUgZ2x5cGhzXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzc1xuICBjb25zdCBERUZBVUxUX0lHTk9SQUJMRV9DSEFSUyA9IC9bXFx1MDBBRFxcdTAzNEZcXHUwNjFDXFx1MTE1Ri1cXHUxMTYwXFx1MTdCNC1cXHUxN0I1XFx1MTgwQi1cXHUxODBFXFx1MjAwQi1cXHUyMDBGXFx1MjAyQS1cXHUyMDJFXFx1MjA2MC1cXHUyMDZGXFx1MzE2NFxcdUZFMDAtXFx1RkUwRlxcdUZFRkZcXHVGRkEwXFx1RkZGMC1cXHVGRkY4XS87XG5cbiAgLy8gVGhpcyByZWdleCAoaW5zdGVhZCBvZiAvXFxzLykgYWxsb3dzIHVzIHRvIHNlbGVjdCBhbGwgd2hpdGVzcGFjZSBFWENFUFQgZm9yIG5vbi1icmVha2luZyB3aGl0ZSBzcGFjZXNcbiAgY29uc3QgbGluZUJyZWFraW5nV2hpdGVTcGFjZSA9IGBbXlxcXFxTXFxcXHUwMEEwXWA7XG5cbiAgLy8gSW5jb21wbGV0ZSBzZXQgb2YgY2hhcmFjdGVycyB0aGF0IGFsbG93IGxpbmUgYnJlYWtpbmcgYWZ0ZXIgdGhlbVxuICAvLyBJbiB0aGUgZnV0dXJlIHdlIG1heSBjb25zaWRlciBhIGZ1bGwgVW5pY29kZSBsaW5lIGJyZWFraW5nIGFsZ29yaXRobSBpbXBsOiBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMTRcbiAgY29uc3QgQlJFQUtfQUZURVJfQ0hBUlMgPSBuZXcgUmVnRXhwKGAke2xpbmVCcmVha2luZ1doaXRlU3BhY2V9fFtcXFxcLVxcXFx1MDA3Q1xcXFx1MDBBRFxcXFx1MjAxMFxcXFx1MjAxMi1cXFxcdTIwMTRcXFxcdTIwMjdcXFxcdTIwNTZcXFxcdTJFMTdcXFxcdTJFNDBdYCk7XG5cbiAgLyoqXG4gICAqIExvYWQgYW5kIHBhcnNlIGFsbCB0aGUgbmVjZXNzYXJ5IGZvbnRzIHRvIHJlbmRlciBhIGdpdmVuIHN0cmluZyBvZiB0ZXh0LCB0aGVuIGdyb3VwXG4gICAqIHRoZW0gaW50byBjb25zZWN1dGl2ZSBydW5zIG9mIGNoYXJhY3RlcnMgc2hhcmluZyBhIGZvbnQuXG4gICAqL1xuICBmdW5jdGlvbiBjYWxjdWxhdGVGb250UnVucyh7dGV4dCwgbGFuZywgZm9udHMsIHN0eWxlLCB3ZWlnaHQsIHByZVJlc29sdmVkRm9udHMsIHVuaWNvZGVGb250c1VSTH0sIG9uRG9uZSkge1xuICAgIGNvbnN0IG9uUmVzb2x2ZWQgPSAoe2NoYXJzLCBmb250czogcGFyc2VkRm9udHN9KSA9PiB7XG4gICAgICBsZXQgY3VyUnVuLCBwcmV2VmFsO1xuICAgICAgY29uc3QgcnVucyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY2hhcnNbaV0gIT09IHByZXZWYWwpIHtcbiAgICAgICAgICBwcmV2VmFsID0gY2hhcnNbaV07XG4gICAgICAgICAgcnVucy5wdXNoKGN1clJ1biA9IHsgc3RhcnQ6IGksIGVuZDogaSwgZm9udE9iajogcGFyc2VkRm9udHNbY2hhcnNbaV1dfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VyUnVuLmVuZCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9uRG9uZShydW5zKTtcbiAgICB9O1xuICAgIGlmIChwcmVSZXNvbHZlZEZvbnRzKSB7XG4gICAgICBvblJlc29sdmVkKHByZVJlc29sdmVkRm9udHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlRm9udHMoXG4gICAgICAgIHRleHQsXG4gICAgICAgIG9uUmVzb2x2ZWQsXG4gICAgICAgIHsgbGFuZywgZm9udHMsIHN0eWxlLCB3ZWlnaHQsIHVuaWNvZGVGb250c1VSTCB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWluIGVudHJ5IHBvaW50LlxuICAgKiBQcm9jZXNzIGEgdGV4dCBzdHJpbmcgd2l0aCBnaXZlbiBmb250IGFuZCBmb3JtYXR0aW5nIHBhcmFtZXRlcnMsIGFuZCByZXR1cm4gYWxsIGluZm9cbiAgICogbmVjZXNzYXJ5IHRvIHJlbmRlciBhbGwgaXRzIGdseXBocy5cbiAgICogQHR5cGUgVHlwZXNldHRlclR5cGVzZXRGdW5jdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gdHlwZXNldChcbiAgICB7XG4gICAgICB0ZXh0PScnLFxuICAgICAgZm9udCxcbiAgICAgIGxhbmcsXG4gICAgICBzZGZHbHlwaFNpemU9NjQsXG4gICAgICBmb250U2l6ZT00MDAsXG4gICAgICBmb250V2VpZ2h0PTEsXG4gICAgICBmb250U3R5bGU9J25vcm1hbCcsXG4gICAgICBsZXR0ZXJTcGFjaW5nPTAsXG4gICAgICBsaW5lSGVpZ2h0PSdub3JtYWwnLFxuICAgICAgbWF4V2lkdGg9SU5GLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgdGV4dEFsaWduPSdsZWZ0JyxcbiAgICAgIHRleHRJbmRlbnQ9MCxcbiAgICAgIHdoaXRlU3BhY2U9J25vcm1hbCcsXG4gICAgICBvdmVyZmxvd1dyYXA9J25vcm1hbCcsXG4gICAgICBhbmNob3JYID0gMCxcbiAgICAgIGFuY2hvclkgPSAwLFxuICAgICAgbWV0cmljc09ubHk9ZmFsc2UsXG4gICAgICB1bmljb2RlRm9udHNVUkwsXG4gICAgICBwcmVSZXNvbHZlZEZvbnRzPW51bGwsXG4gICAgICBpbmNsdWRlQ2FyZXRQb3NpdGlvbnM9ZmFsc2UsXG4gICAgICBjaHVua2VkQm91bmRzU2l6ZT04MTkyLFxuICAgICAgY29sb3JSYW5nZXM9bnVsbFxuICAgIH0sXG4gICAgY2FsbGJhY2tcbiAgKSB7XG4gICAgY29uc3QgbWFpblN0YXJ0ID0gbm93KCk7XG4gICAgY29uc3QgdGltaW5ncyA9IHtmb250TG9hZDogMCwgdHlwZXNldHRpbmc6IDB9O1xuXG4gICAgLy8gRW5zdXJlIG5ld2xpbmVzIGFyZSBub3JtYWxpemVkXG4gICAgaWYgKHRleHQuaW5kZXhPZignXFxyJykgPiAtMSkge1xuICAgICAgY29uc29sZS5pbmZvKCdUeXBlc2V0dGVyOiBnb3QgdGV4dCB3aXRoIFxcXFxyIGNoYXJzOyBub3JtYWxpemluZyB0byBcXFxcbicpO1xuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKS5yZXBsYWNlKC9cXHIvZywgJ1xcbicpO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB3ZSd2ZSBnb3QgbnVtYmVycyBub3Qgc3RyaW5nc1xuICAgIGZvbnRTaXplID0gK2ZvbnRTaXplO1xuICAgIGxldHRlclNwYWNpbmcgPSArbGV0dGVyU3BhY2luZztcbiAgICBtYXhXaWR0aCA9ICttYXhXaWR0aDtcbiAgICBsaW5lSGVpZ2h0ID0gbGluZUhlaWdodCB8fCAnbm9ybWFsJztcbiAgICB0ZXh0SW5kZW50ID0gK3RleHRJbmRlbnQ7XG5cbiAgICBjYWxjdWxhdGVGb250UnVucyh7XG4gICAgICB0ZXh0LFxuICAgICAgbGFuZyxcbiAgICAgIHN0eWxlOiBmb250U3R5bGUsXG4gICAgICB3ZWlnaHQ6IGZvbnRXZWlnaHQsXG4gICAgICBmb250czogdHlwZW9mIGZvbnQgPT09ICdzdHJpbmcnID8gW3tzcmM6IGZvbnR9XSA6IGZvbnQsXG4gICAgICB1bmljb2RlRm9udHNVUkwsXG4gICAgICBwcmVSZXNvbHZlZEZvbnRzXG4gICAgfSwgcnVucyA9PiB7XG4gICAgICB0aW1pbmdzLmZvbnRMb2FkID0gbm93KCkgLSBtYWluU3RhcnQ7XG4gICAgICBjb25zdCBoYXNNYXhXaWR0aCA9IGlzRmluaXRlKG1heFdpZHRoKTtcbiAgICAgIGxldCBnbHlwaElkcyA9IG51bGw7XG4gICAgICBsZXQgZ2x5cGhGb250SW5kaWNlcyA9IG51bGw7XG4gICAgICBsZXQgZ2x5cGhQb3NpdGlvbnMgPSBudWxsO1xuICAgICAgbGV0IGdseXBoRGF0YSA9IG51bGw7XG4gICAgICBsZXQgZ2x5cGhDb2xvcnMgPSBudWxsO1xuICAgICAgbGV0IGNhcmV0UG9zaXRpb25zID0gbnVsbDtcbiAgICAgIGxldCB2aXNpYmxlQm91bmRzID0gbnVsbDtcbiAgICAgIGxldCBjaHVua2VkQm91bmRzID0gbnVsbDtcbiAgICAgIGxldCBtYXhMaW5lV2lkdGggPSAwO1xuICAgICAgbGV0IHJlbmRlcmFibGVHbHlwaENvdW50ID0gMDtcbiAgICAgIGxldCBjYW5XcmFwID0gd2hpdGVTcGFjZSAhPT0gJ25vd3JhcCc7XG4gICAgICBjb25zdCBtZXRyaWNzQnlGb250ID0gbmV3IE1hcCgpOyAvLyBmb250T2JqIC0+IG1ldHJpY3NcbiAgICAgIGNvbnN0IHR5cGVzZXRTdGFydCA9IG5vdygpO1xuXG4gICAgICAvLyBEaXN0cmlidXRlIGdseXBocyBpbnRvIGxpbmVzIGJhc2VkIG9uIHdyYXBwaW5nXG4gICAgICBsZXQgbGluZVhPZmZzZXQgPSB0ZXh0SW5kZW50O1xuICAgICAgbGV0IHByZXZSdW5FbmRYID0gMDtcbiAgICAgIGxldCBjdXJyZW50TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgY29uc3QgbGluZXMgPSBbY3VycmVudExpbmVdO1xuICAgICAgcnVucy5mb3JFYWNoKHJ1biA9PiB7XG4gICAgICAgIGNvbnN0IHsgZm9udE9iaiB9ID0gcnVuO1xuICAgICAgICBjb25zdCB7IGFzY2VuZGVyLCBkZXNjZW5kZXIsIHVuaXRzUGVyRW0sIGxpbmVHYXAsIGNhcEhlaWdodCwgeEhlaWdodCB9ID0gZm9udE9iajtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgbWV0cmljcyBmb3IgZWFjaCBmb250IHVzZWRcbiAgICAgICAgbGV0IGZvbnREYXRhID0gbWV0cmljc0J5Rm9udC5nZXQoZm9udE9iaik7XG4gICAgICAgIGlmICghZm9udERhdGEpIHtcbiAgICAgICAgICAvLyBGaW5kIGNvbnZlcnNpb24gYmV0d2VlbiBuYXRpdmUgZm9udCB1bml0cyBhbmQgZm9udFNpemUgdW5pdHNcbiAgICAgICAgICBjb25zdCBmb250U2l6ZU11bHQgPSBmb250U2l6ZSAvIHVuaXRzUGVyRW07XG5cbiAgICAgICAgICAvLyBEZXRlcm1pbmUgYXBwcm9wcmlhdGUgdmFsdWUgZm9yICdub3JtYWwnIGxpbmUgaGVpZ2h0IGJhc2VkIG9uIHRoZSBmb250J3MgYWN0dWFsIG1ldHJpY3NcbiAgICAgICAgICAvLyBUaGlzIGRvZXMgbm90IGd1YXJhbnRlZSBpbmRpdmlkdWFsIGdseXBocyB3b24ndCBleGNlZWQgdGhlIGxpbmUgaGVpZ2h0LCBlLmcuIFJvYm90bzsgc2hvdWxkIHdlIHVzZSB5TWluL01heCBpbnN0ZWFkP1xuICAgICAgICAgIGNvbnN0IGNhbGNMaW5lSGVpZ2h0ID0gbGluZUhlaWdodCA9PT0gJ25vcm1hbCcgP1xuICAgICAgICAgICAgKGFzY2VuZGVyIC0gZGVzY2VuZGVyICsgbGluZUdhcCkgKiBmb250U2l6ZU11bHQgOiBsaW5lSGVpZ2h0ICogZm9udFNpemU7XG5cbiAgICAgICAgICAvLyBEZXRlcm1pbmUgbGluZSBoZWlnaHQgYW5kIGxlYWRpbmcgYWRqdXN0bWVudHNcbiAgICAgICAgICBjb25zdCBoYWxmTGVhZGluZyA9IChjYWxjTGluZUhlaWdodCAtIChhc2NlbmRlciAtIGRlc2NlbmRlcikgKiBmb250U2l6ZU11bHQpIC8gMjtcbiAgICAgICAgICBjb25zdCBjYXJldEhlaWdodCA9IE1hdGgubWluKGNhbGNMaW5lSGVpZ2h0LCAoYXNjZW5kZXIgLSBkZXNjZW5kZXIpICogZm9udFNpemVNdWx0KTtcbiAgICAgICAgICBjb25zdCBjYXJldFRvcCA9IChhc2NlbmRlciArIGRlc2NlbmRlcikgLyAyICogZm9udFNpemVNdWx0ICsgY2FyZXRIZWlnaHQgLyAyO1xuICAgICAgICAgIGZvbnREYXRhID0ge1xuICAgICAgICAgICAgaW5kZXg6IG1ldHJpY3NCeUZvbnQuc2l6ZSxcbiAgICAgICAgICAgIHNyYzogZm9udE9iai5zcmMsXG4gICAgICAgICAgICBmb250T2JqLFxuICAgICAgICAgICAgZm9udFNpemVNdWx0LFxuICAgICAgICAgICAgdW5pdHNQZXJFbSxcbiAgICAgICAgICAgIGFzY2VuZGVyOiBhc2NlbmRlciAqIGZvbnRTaXplTXVsdCxcbiAgICAgICAgICAgIGRlc2NlbmRlcjogZGVzY2VuZGVyICogZm9udFNpemVNdWx0LFxuICAgICAgICAgICAgY2FwSGVpZ2h0OiBjYXBIZWlnaHQgKiBmb250U2l6ZU11bHQsXG4gICAgICAgICAgICB4SGVpZ2h0OiB4SGVpZ2h0ICogZm9udFNpemVNdWx0LFxuICAgICAgICAgICAgbGluZUhlaWdodDogY2FsY0xpbmVIZWlnaHQsXG4gICAgICAgICAgICBiYXNlbGluZTogLWhhbGZMZWFkaW5nIC0gYXNjZW5kZXIgKiBmb250U2l6ZU11bHQsIC8vIGJhc2VsaW5lIG9mZnNldCBmcm9tIHRvcCBvZiBsaW5lIGhlaWdodFxuICAgICAgICAgICAgLy8gY2FwOiAtaGFsZkxlYWRpbmcgLSBjYXBIZWlnaHQgKiBmb250U2l6ZU11bHQsIC8vIGNhcCBmcm9tIHRvcCBvZiBsaW5lIGhlaWdodFxuICAgICAgICAgICAgLy8gZXg6IC1oYWxmTGVhZGluZyAtIHhIZWlnaHQgKiBmb250U2l6ZU11bHQsIC8vIGV4IGZyb20gdG9wIG9mIGxpbmUgaGVpZ2h0XG4gICAgICAgICAgICBjYXJldFRvcDogKGFzY2VuZGVyICsgZGVzY2VuZGVyKSAvIDIgKiBmb250U2l6ZU11bHQgKyBjYXJldEhlaWdodCAvIDIsXG4gICAgICAgICAgICBjYXJldEJvdHRvbTogY2FyZXRUb3AgLSBjYXJldEhlaWdodFxuICAgICAgICAgIH07XG4gICAgICAgICAgbWV0cmljc0J5Rm9udC5zZXQoZm9udE9iaiwgZm9udERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZm9udFNpemVNdWx0IH0gPSBmb250RGF0YTtcblxuICAgICAgICBjb25zdCBydW5UZXh0ID0gdGV4dC5zbGljZShydW4uc3RhcnQsIHJ1bi5lbmQgKyAxKTtcbiAgICAgICAgbGV0IHByZXZHbHlwaFgsIHByZXZHbHlwaE9iajtcbiAgICAgICAgZm9udE9iai5mb3JFYWNoR2x5cGgocnVuVGV4dCwgZm9udFNpemUsIGxldHRlclNwYWNpbmcsIChnbHlwaE9iaiwgZ2x5cGhYLCBnbHlwaFksIGNoYXJJbmRleCkgPT4ge1xuICAgICAgICAgIGdseXBoWCArPSBwcmV2UnVuRW5kWDtcbiAgICAgICAgICBjaGFySW5kZXggKz0gcnVuLnN0YXJ0O1xuICAgICAgICAgIHByZXZHbHlwaFggPSBnbHlwaFg7XG4gICAgICAgICAgcHJldkdseXBoT2JqID0gZ2x5cGhPYmo7XG4gICAgICAgICAgY29uc3QgY2hhciA9IHRleHQuY2hhckF0KGNoYXJJbmRleCk7XG4gICAgICAgICAgY29uc3QgZ2x5cGhXaWR0aCA9IGdseXBoT2JqLmFkdmFuY2VXaWR0aCAqIGZvbnRTaXplTXVsdDtcbiAgICAgICAgICBjb25zdCBjdXJMaW5lQ291bnQgPSBjdXJyZW50TGluZS5jb3VudDtcbiAgICAgICAgICBsZXQgbmV4dExpbmU7XG5cbiAgICAgICAgICAvLyBDYWxjIGlzV2hpdGVzcGFjZSBhbmQgaXNFbXB0eSBvbmNlIHBlciBnbHlwaE9ialxuICAgICAgICAgIGlmICghKCdpc0VtcHR5JyBpbiBnbHlwaE9iaikpIHtcbiAgICAgICAgICAgIGdseXBoT2JqLmlzV2hpdGVzcGFjZSA9ICEhY2hhciAmJiBuZXcgUmVnRXhwKGxpbmVCcmVha2luZ1doaXRlU3BhY2UpLnRlc3QoY2hhcik7XG4gICAgICAgICAgICBnbHlwaE9iai5jYW5CcmVha0FmdGVyID0gISFjaGFyICYmIEJSRUFLX0FGVEVSX0NIQVJTLnRlc3QoY2hhcik7XG4gICAgICAgICAgICBnbHlwaE9iai5pc0VtcHR5ID0gZ2x5cGhPYmoueE1pbiA9PT0gZ2x5cGhPYmoueE1heCB8fCBnbHlwaE9iai55TWluID09PSBnbHlwaE9iai55TWF4IHx8IERFRkFVTFRfSUdOT1JBQkxFX0NIQVJTLnRlc3QoY2hhcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZ2x5cGhPYmouaXNXaGl0ZXNwYWNlICYmICFnbHlwaE9iai5pc0VtcHR5KSB7XG4gICAgICAgICAgICByZW5kZXJhYmxlR2x5cGhDb3VudCsrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIGEgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyIG92ZXJmbG93cyB0aGUgbWF4IHdpZHRoLCB3ZSBuZWVkIHRvIHNvZnQtd3JhcFxuICAgICAgICAgIGlmIChjYW5XcmFwICYmIGhhc01heFdpZHRoICYmICFnbHlwaE9iai5pc1doaXRlc3BhY2UgJiYgZ2x5cGhYICsgZ2x5cGhXaWR0aCArIGxpbmVYT2Zmc2V0ID4gbWF4V2lkdGggJiYgY3VyTGluZUNvdW50KSB7XG4gICAgICAgICAgICAvLyBJZiBpdCdzIHRoZSBmaXJzdCBjaGFyIGFmdGVyIGEgd2hpdGVzcGFjZSwgc3RhcnQgYSBuZXcgbGluZVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaW5lLmdseXBoQXQoY3VyTGluZUNvdW50IC0gMSkuZ2x5cGhPYmouY2FuQnJlYWtBZnRlcikge1xuICAgICAgICAgICAgICBuZXh0TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgICAgICAgICBsaW5lWE9mZnNldCA9IC1nbHlwaFg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBCYWNrIHVwIGxvb2tpbmcgZm9yIGEgd2hpdGVzcGFjZSBjaGFyYWN0ZXIgdG8gd3JhcCBhdFxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gY3VyTGluZUNvdW50OyBpLS07KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZ290IHRoZSBzdGFydCBvZiB0aGUgbGluZSB0aGVyZSdzIG5vIHNvZnQgYnJlYWsgcG9pbnQ7IG1ha2UgaGFyZCBicmVhayBpZiBvdmVyZmxvd1dyYXA9J2JyZWFrLXdvcmQnXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgJiYgb3ZlcmZsb3dXcmFwID09PSAnYnJlYWstd29yZCcpIHtcbiAgICAgICAgICAgICAgICAgIG5leHRMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgICBsaW5lWE9mZnNldCA9IC1nbHlwaFg7XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGb3VuZCBhIHNvZnQgYnJlYWsgcG9pbnQ7IG1vdmUgYWxsIGNoYXJzIHNpbmNlIGl0IHRvIGEgbmV3IGxpbmVcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50TGluZS5nbHlwaEF0KGkpLmdseXBoT2JqLmNhbkJyZWFrQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgIG5leHRMaW5lID0gY3VycmVudExpbmUuc3BsaXRBdChpICsgMSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhZGp1c3RYID0gbmV4dExpbmUuZ2x5cGhBdCgwKS54O1xuICAgICAgICAgICAgICAgICAgbGluZVhPZmZzZXQgLT0gYWRqdXN0WDtcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBuZXh0TGluZS5jb3VudDsgai0tOykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0TGluZS5nbHlwaEF0KGopLnggLT0gYWRqdXN0WDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dExpbmUpIHtcbiAgICAgICAgICAgICAgY3VycmVudExpbmUuaXNTb2Z0V3JhcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGN1cnJlbnRMaW5lID0gbmV4dExpbmU7XG4gICAgICAgICAgICAgIGxpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgICAgICAgICAgICBtYXhMaW5lV2lkdGggPSBtYXhXaWR0aDsgLy9hZnRlciBzb2Z0IHdyYXBwaW5nIHVzZSBtYXhXaWR0aCBhcyBjYWxjdWxhdGVkIHdpZHRoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGZseSA9IGN1cnJlbnRMaW5lLmdseXBoQXQoY3VycmVudExpbmUuY291bnQpO1xuICAgICAgICAgIGZseS5nbHlwaE9iaiA9IGdseXBoT2JqO1xuICAgICAgICAgIGZseS54ID0gZ2x5cGhYICsgbGluZVhPZmZzZXQ7XG4gICAgICAgICAgZmx5LnkgPSBnbHlwaFk7XG4gICAgICAgICAgZmx5LndpZHRoID0gZ2x5cGhXaWR0aDtcbiAgICAgICAgICBmbHkuY2hhckluZGV4ID0gY2hhckluZGV4O1xuICAgICAgICAgIGZseS5mb250RGF0YSA9IGZvbnREYXRhO1xuXG4gICAgICAgICAgLy8gSGFuZGxlIGhhcmQgbGluZSBicmVha3NcbiAgICAgICAgICBpZiAoY2hhciA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGN1cnJlbnRMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcbiAgICAgICAgICAgIGxpbmVYT2Zmc2V0ID0gLShnbHlwaFggKyBnbHlwaFdpZHRoICsgKGxldHRlclNwYWNpbmcgKiBmb250U2l6ZSkpICsgdGV4dEluZGVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBdCB0aGUgZW5kIG9mIGEgcnVuIHdlIG11c3QgY2FwdHVyZSB0aGUgeCBwb3NpdGlvbiBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHRoZSBuZXh0IHJ1blxuICAgICAgICBwcmV2UnVuRW5kWCA9IHByZXZHbHlwaFggKyBwcmV2R2x5cGhPYmouYWR2YW5jZVdpZHRoICogZm9udFNpemVNdWx0ICsgbGV0dGVyU3BhY2luZyAqIGZvbnRTaXplO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB3aWR0aC9oZWlnaHQvYmFzZWxpbmUgb2YgZWFjaCBsaW5lIChleGNsdWRpbmcgdHJhaWxpbmcgd2hpdGVzcGFjZSkgYW5kIG1heGltdW0gYmxvY2sgd2lkdGhcbiAgICAgIGxldCB0b3RhbEhlaWdodCA9IDA7XG4gICAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICBsZXQgaXNUcmFpbGluZ1doaXRlc3BhY2UgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gbGluZS5jb3VudDsgaS0tOykge1xuICAgICAgICAgIGNvbnN0IGdseXBoSW5mbyA9IGxpbmUuZ2x5cGhBdChpKTtcbiAgICAgICAgICAvLyBvbWl0IHRyYWlsaW5nIHdoaXRlc3BhY2UgZnJvbSB3aWR0aCBjYWxjdWxhdGlvblxuICAgICAgICAgIGlmIChpc1RyYWlsaW5nV2hpdGVzcGFjZSAmJiAhZ2x5cGhJbmZvLmdseXBoT2JqLmlzV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgbGluZS53aWR0aCA9IGdseXBoSW5mby54ICsgZ2x5cGhJbmZvLndpZHRoO1xuICAgICAgICAgICAgaWYgKGxpbmUud2lkdGggPiBtYXhMaW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gbGluZS53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzVHJhaWxpbmdXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHVzZSB0aGUgdGFsbGVzdCBsaW5lIGhlaWdodCwgbG93ZXN0IGJhc2VsaW5lLCBhbmQgaGlnaGVzdCBjYXAvZXhcbiAgICAgICAgICBsZXQge2xpbmVIZWlnaHQsIGNhcEhlaWdodCwgeEhlaWdodCwgYmFzZWxpbmV9ID0gZ2x5cGhJbmZvLmZvbnREYXRhO1xuICAgICAgICAgIGlmIChsaW5lSGVpZ2h0ID4gbGluZS5saW5lSGVpZ2h0KSBsaW5lLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IGJhc2VsaW5lRGlmZiA9IGJhc2VsaW5lIC0gbGluZS5iYXNlbGluZTtcbiAgICAgICAgICBpZiAoYmFzZWxpbmVEaWZmIDwgMCkgeyAvL3NoaWZ0IGFsbCBtZXRyaWNzIGRvd25cbiAgICAgICAgICAgIGxpbmUuYmFzZWxpbmUgKz0gYmFzZWxpbmVEaWZmO1xuICAgICAgICAgICAgbGluZS5jYXAgKz0gYmFzZWxpbmVEaWZmO1xuICAgICAgICAgICAgbGluZS5leCArPSBiYXNlbGluZURpZmY7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNvbXBhcmUgY2FwL2V4IGJhc2VkIG9uIG5ldyBsb3dlc3QgYmFzZWxpbmVcbiAgICAgICAgICBsaW5lLmNhcCA9IE1hdGgubWF4KGxpbmUuY2FwLCBsaW5lLmJhc2VsaW5lICsgY2FwSGVpZ2h0KTtcbiAgICAgICAgICBsaW5lLmV4ID0gTWF0aC5tYXgobGluZS5leCwgbGluZS5iYXNlbGluZSArIHhIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUuYmFzZWxpbmUgLT0gdG90YWxIZWlnaHQ7XG4gICAgICAgIGxpbmUuY2FwIC09IHRvdGFsSGVpZ2h0O1xuICAgICAgICBsaW5lLmV4IC09IHRvdGFsSGVpZ2h0O1xuICAgICAgICB0b3RhbEhlaWdodCArPSBsaW5lLmxpbmVIZWlnaHQ7XG4gICAgICB9KTtcblxuICAgICAgLy8gRmluZCBvdmVyYWxsIHBvc2l0aW9uIGFkanVzdG1lbnRzIGZvciBhbmNob3JpbmdcbiAgICAgIGxldCBhbmNob3JYT2Zmc2V0ID0gMDtcbiAgICAgIGxldCBhbmNob3JZT2Zmc2V0ID0gMDtcbiAgICAgIGlmIChhbmNob3JYKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYW5jaG9yWCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBhbmNob3JYT2Zmc2V0ID0gLWFuY2hvclg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFuY2hvclggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgYW5jaG9yWE9mZnNldCA9IC1tYXhMaW5lV2lkdGggKiAoXG4gICAgICAgICAgICBhbmNob3JYID09PSAnbGVmdCcgPyAwIDpcbiAgICAgICAgICAgIGFuY2hvclggPT09ICdjZW50ZXInID8gMC41IDpcbiAgICAgICAgICAgIGFuY2hvclggPT09ICdyaWdodCcgPyAxIDpcbiAgICAgICAgICAgIHBhcnNlUGVyY2VudChhbmNob3JYKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhbmNob3JZKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYW5jaG9yWSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBhbmNob3JZT2Zmc2V0ID0gLWFuY2hvclk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFuY2hvclkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgYW5jaG9yWU9mZnNldCA9IGFuY2hvclkgPT09ICd0b3AnID8gMCA6XG4gICAgICAgICAgICBhbmNob3JZID09PSAndG9wLWJhc2VsaW5lJyA/IC1saW5lc1swXS5iYXNlbGluZSA6XG4gICAgICAgICAgICBhbmNob3JZID09PSAndG9wLWNhcCcgPyAtbGluZXNbMF0uY2FwIDpcbiAgICAgICAgICAgIGFuY2hvclkgPT09ICd0b3AtZXgnID8gLWxpbmVzWzBdLmV4IDpcbiAgICAgICAgICAgIGFuY2hvclkgPT09ICdtaWRkbGUnID8gdG90YWxIZWlnaHQgLyAyIDpcbiAgICAgICAgICAgIGFuY2hvclkgPT09ICdib3R0b20nID8gdG90YWxIZWlnaHQgOlxuICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ2JvdHRvbS1iYXNlbGluZScgPyBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5iYXNlbGluZSA6XG4gICAgICAgICAgICBwYXJzZVBlcmNlbnQoYW5jaG9yWSkgKiB0b3RhbEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW1ldHJpY3NPbmx5KSB7XG4gICAgICAgIC8vIFJlc29sdmUgYmlkaSBsZXZlbHNcbiAgICAgICAgY29uc3QgYmlkaUxldmVsc1Jlc3VsdCA9IGJpZGkuZ2V0RW1iZWRkaW5nTGV2ZWxzKHRleHQsIGRpcmVjdGlvbik7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIGxpbmUsIGFwcGx5aW5nIGFsaWdubWVudCBvZmZzZXRzLCBhZGRpbmcgZWFjaCBnbHlwaCB0byB0aGUgYXRsYXMsIGFuZFxuICAgICAgICAvLyBjb2xsZWN0aW5nIGFsbCByZW5kZXJhYmxlIGdseXBocyBpbnRvIGEgc2luZ2xlIGNvbGxlY3Rpb24uXG4gICAgICAgIGdseXBoSWRzID0gbmV3IFVpbnQxNkFycmF5KHJlbmRlcmFibGVHbHlwaENvdW50KTtcbiAgICAgICAgZ2x5cGhGb250SW5kaWNlcyA9IG5ldyBVaW50OEFycmF5KHJlbmRlcmFibGVHbHlwaENvdW50KTtcbiAgICAgICAgZ2x5cGhQb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHJlbmRlcmFibGVHbHlwaENvdW50ICogMik7XG4gICAgICAgIGdseXBoRGF0YSA9IHt9O1xuICAgICAgICB2aXNpYmxlQm91bmRzID0gW0lORiwgSU5GLCAtSU5GLCAtSU5GXTtcbiAgICAgICAgY2h1bmtlZEJvdW5kcyA9IFtdO1xuICAgICAgICBpZiAoaW5jbHVkZUNhcmV0UG9zaXRpb25zKSB7XG4gICAgICAgICAgY2FyZXRQb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KHRleHQubGVuZ3RoICogNCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbG9yUmFuZ2VzKSB7XG4gICAgICAgICAgZ2x5cGhDb2xvcnMgPSBuZXcgVWludDhBcnJheShyZW5kZXJhYmxlR2x5cGhDb3VudCAqIDMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZW5kZXJhYmxlR2x5cGhJbmRleCA9IDA7XG4gICAgICAgIGxldCBwcmV2Q2hhckluZGV4ID0gLTE7XG4gICAgICAgIGxldCBjb2xvckNoYXJJbmRleCA9IC0xO1xuICAgICAgICBsZXQgY2h1bms7XG4gICAgICAgIGxldCBjdXJyZW50Q29sb3I7XG4gICAgICAgIGxpbmVzLmZvckVhY2goKGxpbmUsIGxpbmVJbmRleCkgPT4ge1xuICAgICAgICAgIGxldCB7Y291bnQ6bGluZUdseXBoQ291bnQsIHdpZHRoOmxpbmVXaWR0aH0gPSBsaW5lO1xuXG4gICAgICAgICAgLy8gSWdub3JlIGVtcHR5IGxpbmVzXG4gICAgICAgICAgaWYgKGxpbmVHbHlwaENvdW50ID4gMCkge1xuICAgICAgICAgICAgLy8gQ291bnQgdHJhaWxpbmcgd2hpdGVzcGFjZXMsIHdlIHdhbnQgdG8gaWdub3JlIHRoZXNlIGZvciBjZXJ0YWluIHRoaW5nc1xuICAgICAgICAgICAgbGV0IHRyYWlsaW5nV2hpdGVzcGFjZUNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsaW5lR2x5cGhDb3VudDsgaS0tICYmIGxpbmUuZ2x5cGhBdChpKS5nbHlwaE9iai5pc1doaXRlc3BhY2U7KSB7XG4gICAgICAgICAgICAgIHRyYWlsaW5nV2hpdGVzcGFjZUNvdW50Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IGhvcml6b250YWwgYWxpZ25tZW50IGFkanVzdG1lbnRzXG4gICAgICAgICAgICBsZXQgbGluZVhPZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IGp1c3RpZnlBZGp1c3QgPSAwO1xuICAgICAgICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoKSAvIDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICBsaW5lWE9mZnNldCA9IG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSAnanVzdGlmeScgJiYgbGluZS5pc1NvZnRXcmFwcGVkKSB7XG4gICAgICAgICAgICAgIC8vIGNvdW50IG5vbi10cmFpbGluZyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMsIGFuZCB3ZSdsbCBhZGp1c3QgdGhlIG9mZnNldHMgcGVyIGNoYXJhY3RlciBpbiB0aGUgbmV4dCBsb29wXG4gICAgICAgICAgICAgIGxldCB3aGl0ZXNwYWNlQ291bnQgPSAwO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbGluZUdseXBoQ291bnQgLSB0cmFpbGluZ1doaXRlc3BhY2VDb3VudDsgaS0tOykge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLmdseXBoQXQoaSkuZ2x5cGhPYmouaXNXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAganVzdGlmeUFkanVzdCA9IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGgpIC8gd2hpdGVzcGFjZUNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGp1c3RpZnlBZGp1c3QgfHwgbGluZVhPZmZzZXQpIHtcbiAgICAgICAgICAgICAgbGV0IGp1c3RpZnlPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVHbHlwaENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZ2x5cGhJbmZvID0gbGluZS5nbHlwaEF0KGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoT2JqID0gZ2x5cGhJbmZvLmdseXBoT2JqO1xuICAgICAgICAgICAgICAgIGdseXBoSW5mby54ICs9IGxpbmVYT2Zmc2V0ICsganVzdGlmeU9mZnNldDtcbiAgICAgICAgICAgICAgICAvLyBFeHBhbmQgbm9uLXRyYWlsaW5nIHdoaXRlc3BhY2VzIGZvciBqdXN0aWZ5IGFsaWdubWVudFxuICAgICAgICAgICAgICAgIGlmIChqdXN0aWZ5QWRqdXN0ICE9PSAwICYmIGdseXBoT2JqLmlzV2hpdGVzcGFjZSAmJiBpIDwgbGluZUdseXBoQ291bnQgLSB0cmFpbGluZ1doaXRlc3BhY2VDb3VudCkge1xuICAgICAgICAgICAgICAgICAganVzdGlmeU9mZnNldCArPSBqdXN0aWZ5QWRqdXN0O1xuICAgICAgICAgICAgICAgICAgZ2x5cGhJbmZvLndpZHRoICs9IGp1c3RpZnlBZGp1c3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFBlcmZvcm0gYmlkaSByYW5nZSBmbGlwcGluZ1xuICAgICAgICAgICAgY29uc3QgZmxpcHMgPSBiaWRpLmdldFJlb3JkZXJTZWdtZW50cyhcbiAgICAgICAgICAgICAgdGV4dCwgYmlkaUxldmVsc1Jlc3VsdCwgbGluZS5nbHlwaEF0KDApLmNoYXJJbmRleCwgbGluZS5nbHlwaEF0KGxpbmUuY291bnQgLSAxKS5jaGFySW5kZXhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmb3IgKGxldCBmaSA9IDA7IGZpIDwgZmxpcHMubGVuZ3RoOyBmaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IGZsaXBzW2ZpXTtcbiAgICAgICAgICAgICAgLy8gTWFwIHN0YXJ0L2VuZCBzdHJpbmcgaW5kaWNlcyB0byBpbmRpY2VzIGluIHRoZSBsaW5lXG4gICAgICAgICAgICAgIGxldCBsZWZ0ID0gSW5maW5pdHksIHJpZ2h0ID0gLUluZmluaXR5O1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVHbHlwaENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZS5nbHlwaEF0KGkpLmNoYXJJbmRleCA+PSBzdGFydCkgeyAvLyBndGUgdG8gaGFuZGxlIHJlbW92ZWQgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5MaW5lID0gaSwgZW5kSW5MaW5lID0gaTtcbiAgICAgICAgICAgICAgICAgIGZvciAoOyBlbmRJbkxpbmUgPCBsaW5lR2x5cGhDb3VudDsgZW5kSW5MaW5lKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZm8gPSBsaW5lLmdseXBoQXQoZW5kSW5MaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8uY2hhckluZGV4ID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSW5MaW5lIDwgbGluZUdseXBoQ291bnQgLSB0cmFpbGluZ1doaXRlc3BhY2VDb3VudCkgeyAvL2Rvbid0IGluY2x1ZGUgdHJhaWxpbmcgd3MgaW4gZmxpcCB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbihsZWZ0LCBpbmZvLngpO1xuICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5tYXgocmlnaHQsIGluZm8ueCArIGluZm8ud2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gc3RhcnRJbkxpbmU7IGogPCBlbmRJbkxpbmU7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnbHlwaEluZm8gPSBsaW5lLmdseXBoQXQoaik7XG4gICAgICAgICAgICAgICAgICAgIGdseXBoSW5mby54ID0gcmlnaHQgLSAoZ2x5cGhJbmZvLnggKyBnbHlwaEluZm8ud2lkdGggLSBsZWZ0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFzc2VtYmxlIGZpbmFsIGRhdGEgYXJyYXlzXG4gICAgICAgICAgICBsZXQgZ2x5cGhPYmo7XG4gICAgICAgICAgICBjb25zdCBzZXRHbHlwaE9iaiA9IGcgPT4gZ2x5cGhPYmogPSBnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lR2x5cGhDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGdseXBoSW5mbyA9IGxpbmUuZ2x5cGhBdChpKTtcbiAgICAgICAgICAgICAgZ2x5cGhPYmogPSBnbHlwaEluZm8uZ2x5cGhPYmo7XG4gICAgICAgICAgICAgIGNvbnN0IGdseXBoSWQgPSBnbHlwaE9iai5pbmRleDtcblxuICAgICAgICAgICAgICAvLyBSZXBsYWNlIG1pcnJvcmVkIGNoYXJhY3RlcnMgaW4gcnRsXG4gICAgICAgICAgICAgIGNvbnN0IHJ0bCA9IGJpZGlMZXZlbHNSZXN1bHQubGV2ZWxzW2dseXBoSW5mby5jaGFySW5kZXhdICYgMTsgLy9vZGQgbGV2ZWwgbWVhbnMgcnRsXG4gICAgICAgICAgICAgIGlmIChydGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaXJyb3JlZCA9IGJpZGkuZ2V0TWlycm9yZWRDaGFyYWN0ZXIodGV4dFtnbHlwaEluZm8uY2hhckluZGV4XSk7XG4gICAgICAgICAgICAgICAgaWYgKG1pcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgICBnbHlwaEluZm8uZm9udERhdGEuZm9udE9iai5mb3JFYWNoR2x5cGgobWlycm9yZWQsIDAsIDAsIHNldEdseXBoT2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBBZGQgY2FyZXQgcG9zaXRpb25zXG4gICAgICAgICAgICAgIGlmIChpbmNsdWRlQ2FyZXRQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7Y2hhckluZGV4LCBmb250RGF0YX0gPSBnbHlwaEluZm87XG4gICAgICAgICAgICAgICAgY29uc3QgY2FyZXRMZWZ0ID0gZ2x5cGhJbmZvLnggKyBhbmNob3JYT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhcmV0UmlnaHQgPSBnbHlwaEluZm8ueCArIGdseXBoSW5mby53aWR0aCArIGFuY2hvclhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogNF0gPSBydGwgPyBjYXJldFJpZ2h0IDogY2FyZXRMZWZ0OyAvL3N0YXJ0IGVkZ2UgeFxuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25zW2NoYXJJbmRleCAqIDQgKyAxXSA9IHJ0bCA/IGNhcmV0TGVmdCA6IGNhcmV0UmlnaHQ7IC8vZW5kIGVkZ2UgeFxuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25zW2NoYXJJbmRleCAqIDQgKyAyXSA9IGxpbmUuYmFzZWxpbmUgKyBmb250RGF0YS5jYXJldEJvdHRvbSArIGFuY2hvcllPZmZzZXQ7IC8vY29tbW9uIGJvdHRvbSB5XG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogNCArIDNdID0gbGluZS5iYXNlbGluZSArIGZvbnREYXRhLmNhcmV0VG9wICsgYW5jaG9yWU9mZnNldDsgLy9jb21tb24gdG9wIHlcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHNraXBwZWQgYW55IGNoYXJzIGZyb20gdGhlIHByZXZpb3VzIGdseXBoIChkdWUgdG8gbGlnYXR1cmUgc3VicyksIGZpbGwgaW4gY2FyZXRcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbnMgZm9yIHRob3NlIG1pc3NpbmcgY2hhciBpbmRpY2VzOyBjdXJyZW50bHkgdGhpcyB1c2VzIGEgYmVzdC1ndWVzcyBieSBkaXZpZGluZ1xuICAgICAgICAgICAgICAgIC8vIHRoZSBsaWdhdHVyZSdzIHdpZHRoIGV2ZW5seS4gSW4gdGhlIGZ1dHVyZSB3ZSBtYXkgdHJ5IHRvIHVzZSB0aGUgZm9udCdzIExpZ2F0dXJlQ2FyZXRMaXN0XG4gICAgICAgICAgICAgICAgLy8gdGFibGUgdG8gZ2V0IGJldHRlciBpbnRlcmlvciBjYXJldCBwb3NpdGlvbnMuXG4gICAgICAgICAgICAgICAgY29uc3QgbGlnQ291bnQgPSBjaGFySW5kZXggLSBwcmV2Q2hhckluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChsaWdDb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIGZpbGxMaWdhdHVyZUNhcmV0UG9zaXRpb25zKGNhcmV0UG9zaXRpb25zLCBwcmV2Q2hhckluZGV4LCBsaWdDb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZDaGFySW5kZXggPSBjaGFySW5kZXg7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBUcmFjayBjdXJyZW50IGNvbG9yIHJhbmdlXG4gICAgICAgICAgICAgIGlmIChjb2xvclJhbmdlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHtjaGFySW5kZXh9ID0gZ2x5cGhJbmZvO1xuICAgICAgICAgICAgICAgIHdoaWxlKGNoYXJJbmRleCA+IGNvbG9yQ2hhckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICBjb2xvckNoYXJJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yUmFuZ2VzLmhhc093blByb3BlcnR5KGNvbG9yQ2hhckluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29sb3IgPSBjb2xvclJhbmdlc1tjb2xvckNoYXJJbmRleF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gR2V0IGF0bGFzIGRhdGEgZm9yIHJlbmRlcmFibGUgZ2x5cGhzXG4gICAgICAgICAgICAgIGlmICghZ2x5cGhPYmouaXNXaGl0ZXNwYWNlICYmICFnbHlwaE9iai5pc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gcmVuZGVyYWJsZUdseXBoSW5kZXgrKztcbiAgICAgICAgICAgICAgICBjb25zdCB7Zm9udFNpemVNdWx0LCBzcmM6IGZvbnRTcmMsIGluZGV4OiBmb250SW5kZXh9ID0gZ2x5cGhJbmZvLmZvbnREYXRhO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoaXMgZ2x5cGgncyBwYXRoIGRhdGFcbiAgICAgICAgICAgICAgICBjb25zdCBmb250R2x5cGhEYXRhID0gZ2x5cGhEYXRhW2ZvbnRTcmNdIHx8IChnbHlwaERhdGFbZm9udFNyY10gPSB7fSk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb250R2x5cGhEYXRhW2dseXBoSWRdKSB7XG4gICAgICAgICAgICAgICAgICBmb250R2x5cGhEYXRhW2dseXBoSWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiBnbHlwaE9iai5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXRoQm91bmRzOiBbZ2x5cGhPYmoueE1pbiwgZ2x5cGhPYmoueU1pbiwgZ2x5cGhPYmoueE1heCwgZ2x5cGhPYmoueU1heF1cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGZpbmFsIGdseXBoIHBvc2l0aW9uIGFuZCBhZGQgdG8gZ2x5cGhQb3NpdGlvbnMgYXJyYXlcbiAgICAgICAgICAgICAgICBjb25zdCBnbHlwaFggPSBnbHlwaEluZm8ueCArIGFuY2hvclhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2x5cGhZID0gZ2x5cGhJbmZvLnkgKyBsaW5lLmJhc2VsaW5lICsgYW5jaG9yWU9mZnNldDtcbiAgICAgICAgICAgICAgICBnbHlwaFBvc2l0aW9uc1tpZHggKiAyXSA9IGdseXBoWDtcbiAgICAgICAgICAgICAgICBnbHlwaFBvc2l0aW9uc1tpZHggKiAyICsgMV0gPSBnbHlwaFk7XG5cbiAgICAgICAgICAgICAgICAvLyBUcmFjayB0b3RhbCB2aXNpYmxlIGJvdW5kc1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpc1gwID0gZ2x5cGhYICsgZ2x5cGhPYmoueE1pbiAqIGZvbnRTaXplTXVsdDtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXNZMCA9IGdseXBoWSArIGdseXBoT2JqLnlNaW4gKiBmb250U2l6ZU11bHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlzWDEgPSBnbHlwaFggKyBnbHlwaE9iai54TWF4ICogZm9udFNpemVNdWx0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpc1kxID0gZ2x5cGhZICsgZ2x5cGhPYmoueU1heCAqIGZvbnRTaXplTXVsdDtcbiAgICAgICAgICAgICAgICBpZiAodmlzWDAgPCB2aXNpYmxlQm91bmRzWzBdKSB2aXNpYmxlQm91bmRzWzBdID0gdmlzWDA7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1kwIDwgdmlzaWJsZUJvdW5kc1sxXSkgdmlzaWJsZUJvdW5kc1sxXSA9IHZpc1kwO1xuICAgICAgICAgICAgICAgIGlmICh2aXNYMSA+IHZpc2libGVCb3VuZHNbMl0pIHZpc2libGVCb3VuZHNbMl0gPSB2aXNYMTtcbiAgICAgICAgICAgICAgICBpZiAodmlzWTEgPiB2aXNpYmxlQm91bmRzWzNdKSB2aXNpYmxlQm91bmRzWzNdID0gdmlzWTE7XG5cbiAgICAgICAgICAgICAgICAvLyBUcmFjayBib3VuZGluZyByZWN0cyBmb3IgZWFjaCBjaHVuayBvZiBOIGdseXBoc1xuICAgICAgICAgICAgICAgIGlmIChpZHggJSBjaHVua2VkQm91bmRzU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgY2h1bmsgPSB7c3RhcnQ6IGlkeCwgZW5kOiBpZHgsIHJlY3Q6IFtJTkYsIElORiwgLUlORiwgLUlORl19O1xuICAgICAgICAgICAgICAgICAgY2h1bmtlZEJvdW5kcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2h1bmsuZW5kKys7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtSZWN0ID0gY2h1bmsucmVjdDtcbiAgICAgICAgICAgICAgICBpZiAodmlzWDAgPCBjaHVua1JlY3RbMF0pIGNodW5rUmVjdFswXSA9IHZpc1gwO1xuICAgICAgICAgICAgICAgIGlmICh2aXNZMCA8IGNodW5rUmVjdFsxXSkgY2h1bmtSZWN0WzFdID0gdmlzWTA7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1gxID4gY2h1bmtSZWN0WzJdKSBjaHVua1JlY3RbMl0gPSB2aXNYMTtcbiAgICAgICAgICAgICAgICBpZiAodmlzWTEgPiBjaHVua1JlY3RbM10pIGNodW5rUmVjdFszXSA9IHZpc1kxO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIGdseXBoIGlkcyBhbmQgZm9udCBpbmRpY2VzIGFycmF5c1xuICAgICAgICAgICAgICAgIGdseXBoSWRzW2lkeF0gPSBnbHlwaElkO1xuICAgICAgICAgICAgICAgIGdseXBoRm9udEluZGljZXNbaWR4XSA9IGZvbnRJbmRleDtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBjb2xvcnNcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JSYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaWR4ICogMztcbiAgICAgICAgICAgICAgICAgIGdseXBoQ29sb3JzW3N0YXJ0XSA9IGN1cnJlbnRDb2xvciA+PiAxNiAmIDI1NTtcbiAgICAgICAgICAgICAgICAgIGdseXBoQ29sb3JzW3N0YXJ0ICsgMV0gPSBjdXJyZW50Q29sb3IgPj4gOCAmIDI1NTtcbiAgICAgICAgICAgICAgICAgIGdseXBoQ29sb3JzW3N0YXJ0ICsgMl0gPSBjdXJyZW50Q29sb3IgJiAyNTU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGaWxsIGluIHJlbWFpbmluZyBjYXJldCBwb3NpdGlvbnMgaW4gY2FzZSB0aGUgZmluYWwgY2hhcmFjdGVyIHdhcyBhIGxpZ2F0dXJlXG4gICAgICAgIGlmIChjYXJldFBvc2l0aW9ucykge1xuICAgICAgICAgIGNvbnN0IGxpZ0NvdW50ID0gdGV4dC5sZW5ndGggLSBwcmV2Q2hhckluZGV4O1xuICAgICAgICAgIGlmIChsaWdDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIGZpbGxMaWdhdHVyZUNhcmV0UG9zaXRpb25zKGNhcmV0UG9zaXRpb25zLCBwcmV2Q2hhckluZGV4LCBsaWdDb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFzc2VtYmxlIGZpbmFsIGRhdGEgYWJvdXQgZWFjaCBmb250IHVzZWRcbiAgICAgIGNvbnN0IGZvbnREYXRhID0gW107XG4gICAgICBtZXRyaWNzQnlGb250LmZvckVhY2goKHtpbmRleCwgc3JjLCB1bml0c1BlckVtLCBhc2NlbmRlciwgZGVzY2VuZGVyLCBsaW5lSGVpZ2h0LCBjYXBIZWlnaHQsIHhIZWlnaHR9KSA9PiB7XG4gICAgICAgIGZvbnREYXRhW2luZGV4XSA9IHtzcmMsIHVuaXRzUGVyRW0sIGFzY2VuZGVyLCBkZXNjZW5kZXIsIGxpbmVIZWlnaHQsIGNhcEhlaWdodCwgeEhlaWdodH07XG4gICAgICB9KTtcblxuICAgICAgLy8gVGltaW5nIHN0YXRzXG4gICAgICB0aW1pbmdzLnR5cGVzZXR0aW5nID0gbm93KCkgLSB0eXBlc2V0U3RhcnQ7XG5cbiAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgZ2x5cGhJZHMsIC8vaWQgZm9yIGVhY2ggZ2x5cGgsIHNwZWNpZmljIHRvIHRoYXQgZ2x5cGgncyBmb250XG4gICAgICAgIGdseXBoRm9udEluZGljZXMsIC8vaW5kZXggaW50byBmb250RGF0YSBmb3IgZWFjaCBnbHlwaFxuICAgICAgICBnbHlwaFBvc2l0aW9ucywgLy94LHkgb2YgZWFjaCBnbHlwaCdzIG9yaWdpbiBpbiBsYXlvdXRcbiAgICAgICAgZ2x5cGhEYXRhLCAvL2RpY3QgaG9sZGluZyBkYXRhIGFib3V0IGVhY2ggZ2x5cGggYXBwZWFyaW5nIGluIHRoZSB0ZXh0XG4gICAgICAgIGZvbnREYXRhLCAvL2RhdGEgYWJvdXQgZWFjaCBmb250IHVzZWQgaW4gdGhlIHRleHRcbiAgICAgICAgY2FyZXRQb3NpdGlvbnMsIC8vc3RhcnRYLGVuZFgsYm90dG9tWSBjYXJldCBwb3NpdGlvbnMgZm9yIGVhY2ggY2hhclxuICAgICAgICAvLyBjYXJldEhlaWdodCwgLy9oZWlnaHQgb2YgY3Vyc29yIGZyb20gYm90dG9tIHRvIHRvcCAtIHRvZG8gcGVyIGdseXBoP1xuICAgICAgICBnbHlwaENvbG9ycywgLy9jb2xvciBmb3IgZWFjaCBnbHlwaCwgaWYgY29sb3IgcmFuZ2VzIHN1cHBsaWVkXG4gICAgICAgIGNodW5rZWRCb3VuZHMsIC8vdG90YWwgcmVjdHMgcGVyIChuPWNodW5rZWRCb3VuZHNTaXplKSBjb25zZWN1dGl2ZSBnbHlwaHNcbiAgICAgICAgZm9udFNpemUsIC8vY2FsY3VsYXRlZCBlbSBoZWlnaHRcbiAgICAgICAgdG9wQmFzZWxpbmU6IGFuY2hvcllPZmZzZXQgKyBsaW5lc1swXS5iYXNlbGluZSwgLy95IGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBsaW5lJ3MgYmFzZWxpbmVcbiAgICAgICAgYmxvY2tCb3VuZHM6IFsgLy9ib3VuZHMgZm9yIHRoZSB3aG9sZSBibG9jayBvZiB0ZXh0LCBpbmNsdWRpbmcgdmVydGljYWwgcGFkZGluZyBmb3IgbGluZUhlaWdodFxuICAgICAgICAgIGFuY2hvclhPZmZzZXQsXG4gICAgICAgICAgYW5jaG9yWU9mZnNldCAtIHRvdGFsSGVpZ2h0LFxuICAgICAgICAgIGFuY2hvclhPZmZzZXQgKyBtYXhMaW5lV2lkdGgsXG4gICAgICAgICAgYW5jaG9yWU9mZnNldFxuICAgICAgICBdLFxuICAgICAgICB2aXNpYmxlQm91bmRzLCAvL3RvdGFsIGJvdW5kcyBvZiB2aXNpYmxlIHRleHQgcGF0aHMsIG1heSBiZSBsYXJnZXIgb3Igc21hbGxlciB0aGFuIGJsb2NrQm91bmRzXG4gICAgICAgIHRpbWluZ3NcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cblxuICAvKipcbiAgICogRm9yIGEgZ2l2ZW4gdGV4dCBzdHJpbmcgYW5kIGZvbnQgcGFyYW1ldGVycywgZGV0ZXJtaW5lIHRoZSByZXN1bHRpbmcgYmxvY2sgZGltZW5zaW9uc1xuICAgKiBhZnRlciB3cmFwcGluZyBmb3IgdGhlIGdpdmVuIG1heFdpZHRoLlxuICAgKiBAcGFyYW0gYXJnc1xuICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICovXG4gIGZ1bmN0aW9uIG1lYXN1cmUoYXJncywgY2FsbGJhY2spIHtcbiAgICB0eXBlc2V0KHsuLi5hcmdzLCBtZXRyaWNzT25seTogdHJ1ZX0sIChyZXN1bHQpID0+IHtcbiAgICAgIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSByZXN1bHQuYmxvY2tCb3VuZHM7XG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIHdpZHRoOiB4MSAtIHgwLFxuICAgICAgICBoZWlnaHQ6IHkxIC0geTBcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQZXJjZW50KHN0cikge1xuICAgIGxldCBtYXRjaCA9IHN0ci5tYXRjaCgvXihbXFxkLl0rKSUkLyk7XG4gICAgbGV0IHBjdCA9IG1hdGNoID8gcGFyc2VGbG9hdChtYXRjaFsxXSkgOiBOYU47XG4gICAgcmV0dXJuIGlzTmFOKHBjdCkgPyAwIDogcGN0IC8gMTAwXG4gIH1cblxuICBmdW5jdGlvbiBmaWxsTGlnYXR1cmVDYXJldFBvc2l0aW9ucyhjYXJldFBvc2l0aW9ucywgbGlnU3RhcnRJbmRleCwgbGlnQ291bnQpIHtcbiAgICBjb25zdCBsaWdTdGFydFggPSBjYXJldFBvc2l0aW9uc1tsaWdTdGFydEluZGV4ICogNF07XG4gICAgY29uc3QgbGlnRW5kWCA9IGNhcmV0UG9zaXRpb25zW2xpZ1N0YXJ0SW5kZXggKiA0ICsgMV07XG4gICAgY29uc3QgbGlnQm90dG9tID0gY2FyZXRQb3NpdGlvbnNbbGlnU3RhcnRJbmRleCAqIDQgKyAyXTtcbiAgICBjb25zdCBsaWdUb3AgPSBjYXJldFBvc2l0aW9uc1tsaWdTdGFydEluZGV4ICogNCArIDNdO1xuICAgIGNvbnN0IGd1ZXNzZWRBZHZhbmNlWCA9IChsaWdFbmRYIC0gbGlnU3RhcnRYKSAvIGxpZ0NvdW50O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlnQ291bnQ7IGkrKykge1xuICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IChsaWdTdGFydEluZGV4ICsgaSkgKiA0O1xuICAgICAgY2FyZXRQb3NpdGlvbnNbc3RhcnRJbmRleF0gPSBsaWdTdGFydFggKyBndWVzc2VkQWR2YW5jZVggKiBpO1xuICAgICAgY2FyZXRQb3NpdGlvbnNbc3RhcnRJbmRleCArIDFdID0gbGlnU3RhcnRYICsgZ3Vlc3NlZEFkdmFuY2VYICogKGkgKyAxKTtcbiAgICAgIGNhcmV0UG9zaXRpb25zW3N0YXJ0SW5kZXggKyAyXSA9IGxpZ0JvdHRvbTtcbiAgICAgIGNhcmV0UG9zaXRpb25zW3N0YXJ0SW5kZXggKyAzXSA9IGxpZ1RvcDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuIChzZWxmLnBlcmZvcm1hbmNlIHx8IERhdGUpLm5vdygpXG4gIH1cblxuICAvLyBBcnJheS1iYWNrZWQgc3RydWN0dXJlIGZvciBhIHNpbmdsZSBsaW5lJ3MgZ2x5cGhzIGRhdGFcbiAgZnVuY3Rpb24gVGV4dExpbmUoKSB7XG4gICAgdGhpcy5kYXRhID0gW107XG4gIH1cbiAgY29uc3QgdGV4dExpbmVQcm9wcyA9IFsnZ2x5cGhPYmonLCAneCcsICd5JywgJ3dpZHRoJywgJ2NoYXJJbmRleCcsICdmb250RGF0YSddO1xuICBUZXh0TGluZS5wcm90b3R5cGUgPSB7XG4gICAgd2lkdGg6IDAsXG4gICAgbGluZUhlaWdodDogMCxcbiAgICBiYXNlbGluZTogMCxcbiAgICBjYXA6IDAsXG4gICAgZXg6IDAsXG4gICAgaXNTb2Z0V3JhcHBlZDogZmFsc2UsXG4gICAgZ2V0IGNvdW50KCkge1xuICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRhdGEubGVuZ3RoIC8gdGV4dExpbmVQcm9wcy5sZW5ndGgpXG4gICAgfSxcbiAgICBnbHlwaEF0KGkpIHtcbiAgICAgIGxldCBmbHkgPSBUZXh0TGluZS5mbHl3ZWlnaHQ7XG4gICAgICBmbHkuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIGZseS5pbmRleCA9IGk7XG4gICAgICByZXR1cm4gZmx5XG4gICAgfSxcbiAgICBzcGxpdEF0KGkpIHtcbiAgICAgIGxldCBuZXdMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICBuZXdMaW5lLmRhdGEgPSB0aGlzLmRhdGEuc3BsaWNlKGkgKiB0ZXh0TGluZVByb3BzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3TGluZVxuICAgIH1cbiAgfTtcbiAgVGV4dExpbmUuZmx5d2VpZ2h0ID0gdGV4dExpbmVQcm9wcy5yZWR1Y2UoKG9iaiwgcHJvcCwgaSwgYWxsKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMuaW5kZXggKiB0ZXh0TGluZVByb3BzLmxlbmd0aCArIGldXG4gICAgICB9LFxuICAgICAgc2V0KHZhbCkge1xuICAgICAgICB0aGlzLmRhdGFbdGhpcy5pbmRleCAqIHRleHRMaW5lUHJvcHMubGVuZ3RoICsgaV0gPSB2YWw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialxuICB9LCB7ZGF0YTogbnVsbCwgaW5kZXg6IDB9KTtcblxuXG4gIHJldHVybiB7XG4gICAgdHlwZXNldCxcbiAgICBtZWFzdXJlLFxuICB9XG59XG5cbmNvbnN0IG5vdyA9ICgpID0+IChzZWxmLnBlcmZvcm1hbmNlIHx8IERhdGUpLm5vdygpO1xuXG5jb25zdCBtYWluVGhyZWFkR2VuZXJhdG9yID0gLyojX19QVVJFX18qLyBjcmVhdGVTREZHZW5lcmF0b3IoKTtcblxubGV0IHdhcm5lZDtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBTREYgdGV4dHVyZSBpbWFnZSBmb3IgYSBzaW5nbGUgZ2x5cGggcGF0aCwgcGxhY2luZyB0aGUgcmVzdWx0IGludG8gYSB3ZWJnbCBjYW52YXMgYXQgYVxuICogZ2l2ZW4gbG9jYXRpb24gYW5kIGNoYW5uZWwuIFV0aWxpemVzIHRoZSB3ZWJnbC1zZGYtZ2VuZXJhdG9yIGV4dGVybmFsIHBhY2thZ2UgZm9yIEdQVS1hY2NlbGVyYXRlZCBTREZcbiAqIGdlbmVyYXRpb24gd2hlbiBzdXBwb3J0ZWQuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlU0RGKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsLCB1c2VXZWJHTCA9IHRydWUpIHtcbiAgLy8gQWxsb3cgb3B0LW91dFxuICBpZiAoIXVzZVdlYkdMKSB7XG4gICAgcmV0dXJuIGdlbmVyYXRlU0RGX0pTX1dvcmtlcih3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbClcbiAgfVxuXG4gIC8vIEF0dGVtcHQgR1BVLWFjY2VsZXJhdGVkIGdlbmVyYXRpb24gZmlyc3RcbiAgcmV0dXJuIGdlbmVyYXRlU0RGX0dMKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKS50aGVuKFxuICAgIG51bGwsXG4gICAgZXJyID0+IHtcbiAgICAgIC8vIFdlYkdMIGZhaWxlZCBlaXRoZXIgZHVlIHRvIGEgaGFyZCBlcnJvciBvciB1bmV4cGVjdGVkIHJlc3VsdHM7IGZhbGwgYmFjayB0byBKUyBpbiB3b3JrZXJzXG4gICAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFdlYkdMIFNERiBnZW5lcmF0aW9uIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIEpTYCwgZXJyKTtcbiAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZW5lcmF0ZVNERl9KU19Xb3JrZXIod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwpXG4gICAgfVxuICApXG59XG5cbmNvbnN0IHF1ZXVlID0gW107XG5jb25zdCBjaHVua1RpbWVCdWRnZXQgPSA1OyAvLyBtc1xubGV0IHRpbWVyID0gMDtcblxuZnVuY3Rpb24gbmV4dENodW5rKCkge1xuICBjb25zdCBzdGFydCA9IG5vdygpO1xuICB3aGlsZSAocXVldWUubGVuZ3RoICYmIG5vdygpIC0gc3RhcnQgPCBjaHVua1RpbWVCdWRnZXQpIHtcbiAgICBxdWV1ZS5zaGlmdCgpKCk7XG4gIH1cbiAgdGltZXIgPSBxdWV1ZS5sZW5ndGggPyBzZXRUaW1lb3V0KG5leHRDaHVuaywgMCkgOiAwO1xufVxuXG4vKipcbiAqIFdlYkdMLWJhc2VkIGltcGxlbWVudGF0aW9uIGV4ZWN1dGVkIG9uIHRoZSBtYWluIHRocmVhZC4gUmVxdWVzdHMgYXJlIGV4ZWN1dGVkIGluIHRpbWUtYm91bmRlZFxuICogbWFjcm90YXNrIGNodW5rcyB0byBhbGxvdyByZW5kZXIgZnJhbWVzIHRvIGV4ZWN1dGUgaW4gYmV0d2Vlbi5cbiAqL1xuY29uc3QgZ2VuZXJhdGVTREZfR0wgPSAoLi4uYXJncykgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHF1ZXVlLnB1c2goKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSBub3coKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1haW5UaHJlYWRHZW5lcmF0b3Iud2ViZ2wuZ2VuZXJhdGVJbnRvQ2FudmFzKC4uLmFyZ3MpO1xuICAgICAgICByZXNvbHZlKHsgdGltaW5nOiBub3coKSAtIHN0YXJ0IH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghdGltZXIpIHtcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dChuZXh0Q2h1bmssIDApO1xuICAgIH1cbiAgfSlcbn07XG5cbmNvbnN0IHRocmVhZENvdW50ID0gNDsgLy8gaG93IG1hbnkgd29ya2VycyB0byBzcGF3blxuY29uc3QgaWRsZVRpbWVvdXQgPSAyMDAwOyAvLyB3b3JrZXJzIHdpbGwgYmUgdGVybWluYXRlZCBhZnRlciBiZWluZyBpZGxlIHRoaXMgbWFueSBtaWxsaXNlY29uZHNcbmNvbnN0IHRocmVhZHMgPSB7fTtcbmxldCBjYWxsTnVtID0gMDtcblxuLyoqXG4gKiBGYWxsYmFjayBKUy1iYXNlZCBpbXBsZW1lbnRhdGlvbiwgZmFubmVkIG91dCB0byBhIG51bWJlciBvZiB3b3JrZXIgdGhyZWFkcyBmb3IgcGFyYWxsZWxpc21cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVTREZfSlNfV29ya2VyKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKSB7XG4gIGNvbnN0IHdvcmtlcklkID0gJ1Ryb2lrYVRleHRTREZHZW5lcmF0b3JfSlNfJyArICgoY2FsbE51bSsrKSAlIHRocmVhZENvdW50KTtcbiAgbGV0IHRocmVhZCA9IHRocmVhZHNbd29ya2VySWRdO1xuICBpZiAoIXRocmVhZCkge1xuICAgIHRocmVhZCA9IHRocmVhZHNbd29ya2VySWRdID0ge1xuICAgICAgd29ya2VyTW9kdWxlOiBkZWZpbmVXb3JrZXJNb2R1bGUoe1xuICAgICAgICBuYW1lOiB3b3JrZXJJZCxcbiAgICAgICAgd29ya2VySWQsXG4gICAgICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgICAgIGNyZWF0ZVNERkdlbmVyYXRvcixcbiAgICAgICAgICBub3dcbiAgICAgICAgXSxcbiAgICAgICAgaW5pdChfY3JlYXRlU0RGR2VuZXJhdG9yLCBub3cpIHtcbiAgICAgICAgICBjb25zdCBnZW5lcmF0ZSA9IF9jcmVhdGVTREZHZW5lcmF0b3IoKS5qYXZhc2NyaXB0LmdlbmVyYXRlO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBub3coKTtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmVEYXRhID0gZ2VuZXJhdGUoLi4uYXJncyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0ZXh0dXJlRGF0YSxcbiAgICAgICAgICAgICAgdGltaW5nOiBub3coKSAtIHN0YXJ0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRUcmFuc2ZlcmFibGVzKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiBbcmVzdWx0LnRleHR1cmVEYXRhLmJ1ZmZlcl1cbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICByZXF1ZXN0czogMCxcbiAgICAgIGlkbGVUaW1lcjogbnVsbFxuICAgIH07XG4gIH1cblxuICB0aHJlYWQucmVxdWVzdHMrKztcbiAgY2xlYXJUaW1lb3V0KHRocmVhZC5pZGxlVGltZXIpO1xuICByZXR1cm4gdGhyZWFkLndvcmtlck1vZHVsZSh3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQpXG4gICAgLnRoZW4oKHsgdGV4dHVyZURhdGEsIHRpbWluZyB9KSA9PiB7XG4gICAgICAvLyBjb3B5IHJlc3VsdCBkYXRhIGludG8gdGhlIGNhbnZhc1xuICAgICAgY29uc3Qgc3RhcnQgPSBub3coKTtcbiAgICAgIC8vIGV4cGFuZCBzaW5nbGUtY2hhbm5lbCBkYXRhIGludG8gcmdiYVxuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gbmV3IFVpbnQ4QXJyYXkodGV4dHVyZURhdGEubGVuZ3RoICogNCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHR1cmVEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGltYWdlRGF0YVtpICogNCArIGNoYW5uZWxdID0gdGV4dHVyZURhdGFbaV07XG4gICAgICB9XG4gICAgICBtYWluVGhyZWFkR2VuZXJhdG9yLndlYmdsVXRpbHMucmVuZGVySW1hZ2VEYXRhKGNhbnZhcywgaW1hZ2VEYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAxIDw8ICgzIC0gY2hhbm5lbCkpO1xuICAgICAgdGltaW5nICs9IG5vdygpIC0gc3RhcnQ7XG5cbiAgICAgIC8vIGNsZWFuIHVwIHdvcmtlcnMgYWZ0ZXIgYSB3aGlsZVxuICAgICAgaWYgKC0tdGhyZWFkLnJlcXVlc3RzID09PSAwKSB7XG4gICAgICAgIHRocmVhZC5pZGxlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHsgdGVybWluYXRlV29ya2VyKHdvcmtlcklkKTsgfSwgaWRsZVRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdGltaW5nIH1cbiAgICB9KVxufVxuXG5mdW5jdGlvbiB3YXJtVXBTREZDYW52YXMoY2FudmFzKSB7XG4gIGlmICghY2FudmFzLl93YXJtKSB7XG4gICAgbWFpblRocmVhZEdlbmVyYXRvci53ZWJnbC5pc1N1cHBvcnRlZChjYW52YXMpO1xuICAgIGNhbnZhcy5fd2FybSA9IHRydWU7XG4gIH1cbn1cblxuY29uc3QgcmVzaXplV2ViR0xDYW52YXNXaXRob3V0Q2xlYXJpbmcgPSBtYWluVGhyZWFkR2VuZXJhdG9yLndlYmdsVXRpbHMucmVzaXplV2ViR0xDYW52YXNXaXRob3V0Q2xlYXJpbmc7XG5cbmNvbnN0IENPTkZJRyA9IHtcbiAgZGVmYXVsdEZvbnRVUkw6IG51bGwsXG4gIHVuaWNvZGVGb250c1VSTDogbnVsbCxcbiAgc2RmR2x5cGhTaXplOiA2NCxcbiAgc2RmTWFyZ2luOiAxIC8gMTYsXG4gIHNkZkV4cG9uZW50OiA5LFxuICB0ZXh0dXJlV2lkdGg6IDIwNDgsXG59O1xuY29uc3QgdGVtcENvbG9yID0gLyojX19QVVJFX18qL25ldyBDb2xvcigpO1xubGV0IGhhc1JlcXVlc3RlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBub3ckMSgpIHtcbiAgcmV0dXJuIChzZWxmLnBlcmZvcm1hbmNlIHx8IERhdGUpLm5vdygpXG59XG5cbi8qKlxuICogQ3VzdG9taXplcyB0aGUgdGV4dCBidWlsZGVyIGNvbmZpZ3VyYXRpb24uIFRoaXMgbXVzdCBiZSBjYWxsZWQgcHJpb3IgdG8gdGhlIGZpcnN0IGZvbnQgcHJvY2Vzc2luZ1xuICogcmVxdWVzdCwgYW5kIGFwcGxpZXMgdG8gYWxsIGZvbnRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZGVmYXVsdEZvbnRVUkwgLSBUaGUgVVJMIG9mIHRoZSBkZWZhdWx0IGZvbnQgdG8gdXNlIGZvciB0ZXh0IHByb2Nlc3NpbmdcbiAqICAgICAgICAgICAgICAgICByZXF1ZXN0cywgaW4gY2FzZSBub25lIGlzIHNwZWNpZmllZCBvciB0aGUgc3BlY2lmaWVkZSBmb250IGZhaWxzIHRvIGxvYWQgb3IgcGFyc2UuXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gXCJSb2JvdG8gUmVndWxhclwiIGZyb20gR29vZ2xlIEZvbnRzLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy51bmljb2RlRm9udHNVUkwgLSBBIGN1c3RvbSBsb2NhdGlvbiBmb3IgdGhlIGZhbGxiYWNrIHVuaWNvZGUtZm9udC1yZXNvbHZlclxuICogICAgICAgICAgICAgICAgIGRhdGEgYW5kIGZvbnQgZmlsZXMsIGlmIHlvdSBkb24ndCB3YW50IHRvIHVzZSB0aGUgZGVmYXVsdCBDRE4uIFNlZVxuICogICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2pqaWMvdW5pY29kZS1mb250LXJlc29sdmVyIGZvciBkZXRhaWxzLiBJdCBjYW4gYWxzbyBiZVxuICogICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWQgcGVyIHRleHQgaW5zdGFuY2UsIGJ1dCB0aGlzIGxldHMgeW91IGRvIGl0IG9uY2UgZ2xvYmFsbHkuXG4gKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNkZkdseXBoU2l6ZSAtIFRoZSBkZWZhdWx0IHNpemUgb2YgZWFjaCBnbHlwaCdzIFNERiAoc2lnbmVkIGRpc3RhbmNlIGZpZWxkKVxuICogICAgICAgICAgICAgICAgIHRleHR1cmUgdXNlZCBmb3IgcmVuZGVyaW5nLiBNdXN0IGJlIGEgcG93ZXItb2YtdHdvIG51bWJlciwgYW5kIGFwcGxpZXMgdG8gYWxsIGZvbnRzLFxuICogICAgICAgICAgICAgICAgIGJ1dCBub3RlIHRoYXQgdGhpcyBjYW4gYWxzbyBiZSBvdmVycmlkZGVuIHBlciBjYWxsIHRvIGBnZXRUZXh0UmVuZGVySW5mbygpYC5cbiAqICAgICAgICAgICAgICAgICBMYXJnZXIgc2l6ZXMgY2FuIGltcHJvdmUgdGhlIHF1YWxpdHkgb2YgZ2x5cGggcmVuZGVyaW5nIGJ5IGluY3JlYXNpbmcgdGhlIHNoYXJwbmVzc1xuICogICAgICAgICAgICAgICAgIG9mIGNvcm5lcnMgYW5kIHByZXZlbnRpbmcgbG9zcyBvZiB2ZXJ5IHRoaW4gbGluZXMsIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeS4gRGVmYXVsdHNcbiAqICAgICAgICAgICAgICAgICB0byA2NCB3aGljaCBpcyBnZW5lcmFsbHkgYSBnb29kIGJhbGFuY2Ugb2Ygc2l6ZSBhbmQgcXVhbGl0eS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuc2RmRXhwb25lbnQgLSBUaGUgZXhwb25lbnQgdXNlZCB3aGVuIGVuY29kaW5nIHRoZSBTREYgdmFsdWVzLiBBIGhpZ2hlciBleHBvbmVudFxuICogICAgICAgICAgICAgICAgIHNoaWZ0cyB0aGUgZW5jb2RlZCA4LWJpdCB2YWx1ZXMgdG8gYWNoaWV2ZSBoaWdoZXIgcHJlY2lzaW9uL2FjY3VyYWN5IGF0IHRleGVscyBuZWFyZXJcbiAqICAgICAgICAgICAgICAgICB0aGUgZ2x5cGgncyBwYXRoLCB3aXRoIGxvd2VyIHByZWNpc2lvbiBmdXJ0aGVyIGF3YXkuIERlZmF1bHRzIHRvIDkuXG4gKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNkZk1hcmdpbiAtIEhvdyBtdWNoIHNwYWNlIHRvIHJlc2VydmUgaW4gdGhlIFNERiBhcyBtYXJnaW4gb3V0c2lkZSB0aGUgZ2x5cGgnc1xuICogICAgICAgICAgICAgICAgIHBhdGgsIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgU0RGIHdpZHRoLiBBIGxhcmdlciBtYXJnaW4gaW5jcmVhc2VzIHRoZSBxdWFsaXR5IG9mXG4gKiAgICAgICAgICAgICAgICAgZXh0cnVkZWQgZ2x5cGggb3V0bGluZXMsIGJ1dCBkZWNyZWFzZXMgdGhlIHByZWNpc2lvbiBhdmFpbGFibGUgZm9yIHRoZSBnbHlwaCBpdHNlbGYuXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gMS8xNnRoIG9mIHRoZSBnbHlwaCBzaXplLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy50ZXh0dXJlV2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIFNERiB0ZXh0dXJlOyBtdXN0IGJlIGEgcG93ZXIgb2YgMi4gRGVmYXVsdHMgdG9cbiAqICAgICAgICAgICAgICAgICAyMDQ4IHdoaWNoIGlzIGEgc2FmZSBtYXhpbXVtIHRleHR1cmUgZGltZW5zaW9uIGFjY29yZGluZyB0byB0aGUgc3RhdHMgYXRcbiAqICAgICAgICAgICAgICAgICBodHRwczovL3dlYmdsc3RhdHMuY29tL3dlYmdsL3BhcmFtZXRlci9NQVhfVEVYVFVSRV9TSVpFIGFuZCBzaG91bGQgYWxsb3cgZm9yIGFcbiAqICAgICAgICAgICAgICAgICByZWFzb25hYmx5IGxhcmdlIG51bWJlciBvZiBnbHlwaHMgKGRlZmF1bHQgZ2x5cGggc2l6ZSBvZiA2NF4yIGFuZCBzYWZlIHRleHR1cmUgc2l6ZSBvZlxuICogICAgICAgICAgICAgICAgIDIwNDheMiwgdGltZXMgNCBjaGFubmVscywgYWxsb3dzIGZvciA0MDk2IGdseXBocy4pIFRoaXMgY2FuIGJlIGluY3JlYXNlZCBpZiB5b3UgbmVlZCB0b1xuICogICAgICAgICAgICAgICAgIGluY3JlYXNlIHRoZSBnbHlwaCBzaXplIGFuZC9vciBoYXZlIGFuIGV4dHJhb3JkaW5hcnkgbnVtYmVyIG9mIGdseXBocy5cbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlVGV4dEJ1aWxkZXIoY29uZmlnKSB7XG4gIGlmIChoYXNSZXF1ZXN0ZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ2NvbmZpZ3VyZVRleHRCdWlsZGVyIGNhbGxlZCBhZnRlciBmaXJzdCBmb250IHJlcXVlc3Q7IHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgfSBlbHNlIHtcbiAgICBhc3NpZ24oQ09ORklHLCBjb25maWcpO1xuICB9XG59XG5cbi8qKlxuICogUmVwb3NpdG9yeSBmb3IgYWxsIGZvbnQgU0RGIGF0bGFzIHRleHR1cmVzIGFuZCB0aGVpciBnbHlwaCBtYXBwaW5ncy4gVGhlcmUgaXMgYSBzZXBhcmF0ZSBhdGxhcyBmb3JcbiAqIGVhY2ggc2RmR2x5cGhTaXplLiBFYWNoIGF0bGFzIGhhcyBhIHNpbmdsZSBUZXh0dXJlIHRoYXQgaG9sZHMgYWxsIGdseXBocyBmb3IgYWxsIGZvbnRzLlxuICpcbiAqICAge1xuICogICAgIFtzZGZHbHlwaFNpemVdOiB7XG4gKiAgICAgICBnbHlwaENvdW50OiBudW1iZXIsXG4gKiAgICAgICBzZGZHbHlwaFNpemU6IG51bWJlcixcbiAqICAgICAgIHNkZlRleHR1cmU6IFRleHR1cmUsXG4gKiAgICAgICBzZGZDYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuICogICAgICAgY29udGV4dExvc3Q6IGJvb2xlYW4sXG4gKiAgICAgICBnbHlwaHNCeUZvbnQ6IE1hcDxmb250VVJMLCBNYXA8Z2x5cGhJRCwge3BhdGgsIGF0bGFzSW5kZXgsIHNkZlZpZXdCb3h9Pj5cbiAqICAgICB9XG4gKiAgIH1cbiAqL1xuY29uc3QgYXRsYXNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gVHJvaWthVGV4dFJlbmRlckluZm8gLSBGb3JtYXQgb2YgdGhlIHJlc3VsdCBmcm9tIGBnZXRUZXh0UmVuZGVySW5mb2AuXG4gKiBAcHJvcGVydHkge1R5cGVzZXRQYXJhbXN9IHBhcmFtZXRlcnMgLSBUaGUgbm9ybWFsaXplZCBpbnB1dCBhcmd1bWVudHMgdG8gdGhlIHJlbmRlciBjYWxsLlxuICogQHByb3BlcnR5IHtUZXh0dXJlfSBzZGZUZXh0dXJlIC0gVGhlIFNERiBhdGxhcyB0ZXh0dXJlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNkZkdseXBoU2l6ZSAtIFRoZSBzaXplIG9mIGVhY2ggZ2x5cGgncyBTREY7IHNlZSBgY29uZmlndXJlVGV4dEJ1aWxkZXJgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNkZkV4cG9uZW50IC0gVGhlIGV4cG9uZW50IHVzZWQgaW4gZW5jb2RpbmcgdGhlIFNERidzIHZhbHVlczsgc2VlIGBjb25maWd1cmVUZXh0QnVpbGRlcmAuXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gZ2x5cGhCb3VuZHMgLSBMaXN0IG9mIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBxdWFkIGJvdW5kcyBmb3IgZWFjaCBnbHlwaC5cbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBnbHlwaEF0bGFzSW5kaWNlcyAtIExpc3QgaG9sZGluZyBlYWNoIGdseXBoJ3MgaW5kZXggaW4gdGhlIFNERiBhdGxhcy5cbiAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gW2dseXBoQ29sb3JzXSAtIExpc3QgaG9sZGluZyBlYWNoIGdseXBoJ3MgW3IsIGcsIGJdIGNvbG9yLCBpZiBgY29sb3JSYW5nZXNgIHdhcyBzdXBwbGllZC5cbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBbY2FyZXRQb3NpdGlvbnNdIC0gQSBsaXN0IG9mIGNhcmV0IHBvc2l0aW9ucyBmb3IgYWxsIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZzsgZWFjaCBpc1xuICogICAgICAgICAgIGZvdXIgZWxlbWVudHM6IHRoZSBzdGFydGluZyBYLCB0aGUgZW5kaW5nIFgsIHRoZSBib3R0b20gWSwgYW5kIHRoZSB0b3AgWSBmb3IgdGhlIGNhcmV0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYXJldEhlaWdodF0gLSBBbiBhcHByb3ByaWF0ZSBoZWlnaHQgZm9yIGFsbCBzZWxlY3Rpb24gY2FyZXRzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGFzY2VuZGVyIC0gVGhlIGZvbnQncyBhc2NlbmRlciBtZXRyaWMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGVzY2VuZGVyIC0gVGhlIGZvbnQncyBkZXNjZW5kZXIgbWV0cmljLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNhcEhlaWdodCAtIFRoZSBmb250J3MgY2FwIGhlaWdodCBtZXRyaWMsIGJhc2VkIG9uIHRoZSBoZWlnaHQgb2YgTGF0aW4gY2FwaXRhbCBsZXR0ZXJzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHhIZWlnaHQgLSBUaGUgZm9udCdzIHggaGVpZ2h0IG1ldHJpYywgYmFzZWQgb24gdGhlIGhlaWdodCBvZiBMYXRpbiBsb3dlcmNhc2UgbGV0dGVycy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lSGVpZ2h0IC0gVGhlIGZpbmFsIGNvbXB1dGVkIGxpbmVIZWlnaHQgbWVhc3VyZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdG9wQmFzZWxpbmUgLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgdG9wIGxpbmUncyBiYXNlbGluZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gYmxvY2tCb3VuZHMgLSBUaGUgdG90YWwgW21pblgsIG1pblksIG1heFgsIG1heFldIHJlY3Qgb2YgdGhlIHdob2xlIHRleHQgYmxvY2s7XG4gKiAgICAgICAgICAgdGhpcyBjYW4gaW5jbHVkZSBleHRyYSB2ZXJ0aWNhbCBzcGFjZSBiZXlvbmQgdGhlIHZpc2libGUgZ2x5cGhzIGR1ZSB0byBsaW5lSGVpZ2h0LCBhbmQgaXNcbiAqICAgICAgICAgICBlcXVpdmFsZW50IHRvIHRoZSBkaW1lbnNpb25zIG9mIGEgYmxvY2stbGV2ZWwgdGV4dCBlbGVtZW50IGluIENTUy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gdmlzaWJsZUJvdW5kcyAtIFRoZSB0b3RhbCBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gcmVjdCBvZiB0aGUgd2hvbGUgdGV4dCBibG9jaztcbiAqICAgICAgICAgICB1bmxpa2UgYGJsb2NrQm91bmRzYCB0aGlzIGlzIHRpZ2h0bHkgd3JhcHBlZCB0byB0aGUgdmlzaWJsZSBnbHlwaCBwYXRocy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8b2JqZWN0Pn0gY2h1bmtlZEJvdW5kcyAtIExpc3Qgb2YgYm91bmRpbmcgcmVjdHMgZm9yIGVhY2ggY29uc2VjdXRpdmUgc2V0IG9mIE4gZ2x5cGhzLFxuICogICAgICAgICAgIGluIHRoZSBmb3JtYXQgYHtzdGFydDpOLCBlbmQ6TiwgcmVjdDpbbWluWCwgbWluWSwgbWF4WCwgbWF4WV19YC5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB0aW1pbmdzIC0gVGltaW5nIGluZm8gZm9yIHZhcmlvdXMgcGFydHMgb2YgdGhlIHJlbmRlcmluZyBsb2dpYyBpbmNsdWRpbmcgU0RGXG4gKiAgICAgICAgICAgZ2VuZXJhdGlvbiwgdHlwZXNldHRpbmcsIGV0Yy5cbiAqIEBmcm96ZW5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBnZXRUZXh0UmVuZGVySW5mb35jYWxsYmFja1xuICogQHBhcmFtIHtUcm9pa2FUZXh0UmVuZGVySW5mb30gdGV4dFJlbmRlckluZm9cbiAqL1xuXG4vKipcbiAqIE1haW4gZW50cnkgcG9pbnQgZm9yIHJlcXVlc3RpbmcgdGhlIGRhdGEgbmVlZGVkIHRvIHJlbmRlciBhIHRleHQgc3RyaW5nIHdpdGggZ2l2ZW4gZm9udCBwYXJhbWV0ZXJzLlxuICogVGhpcyBpcyBhbiBhc3luY2hyb25vdXMgY2FsbCwgcGVyZm9ybWluZyBtb3N0IG9mIHRoZSBsb2dpYyBpbiBhIHdlYiB3b3JrZXIgdGhyZWFkLlxuICogQHBhcmFtIHtUeXBlc2V0UGFyYW1zfSBhcmdzXG4gKiBAcGFyYW0ge2dldFRleHRSZW5kZXJJbmZvfmNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBnZXRUZXh0UmVuZGVySW5mbyhhcmdzLCBjYWxsYmFjaykge1xuICBoYXNSZXF1ZXN0ZWQgPSB0cnVlO1xuICBhcmdzID0gYXNzaWduKHt9LCBhcmdzKTtcbiAgY29uc3QgdG90YWxTdGFydCA9IG5vdyQxKCk7XG5cbiAgLy8gQ29udmVydCByZWxhdGl2ZSBVUkwgdG8gYWJzb2x1dGUgc28gaXQgY2FuIGJlIHJlc29sdmVkIGluIHRoZSB3b3JrZXIsIGFuZCBhZGQgZmFsbGJhY2tzLlxuICAvLyBJbiB0aGUgZnV0dXJlIHdlJ2xsIGFsbG93IGFyZ3MuZm9udCB0byBiZSBhIGxpc3Qgd2l0aCB1bmljb2RlIHJhbmdlcyB0b28uXG4gIGNvbnN0IHsgZGVmYXVsdEZvbnRVUkwgfSA9IENPTkZJRztcbiAgY29uc3QgZm9udHMgPSBbXTtcbiAgaWYgKGRlZmF1bHRGb250VVJMKSB7XG4gICAgZm9udHMucHVzaCh7bGFiZWw6ICdkZWZhdWx0Jywgc3JjOiB0b0Fic29sdXRlVVJMKGRlZmF1bHRGb250VVJMKX0pO1xuICB9XG4gIGlmIChhcmdzLmZvbnQpIHtcbiAgICBmb250cy5wdXNoKHtsYWJlbDogJ3VzZXInLCBzcmM6IHRvQWJzb2x1dGVVUkwoYXJncy5mb250KX0pO1xuICB9XG4gIGFyZ3MuZm9udCA9IGZvbnRzO1xuXG4gIC8vIE5vcm1hbGl6ZSB0ZXh0IHRvIGEgc3RyaW5nXG4gIGFyZ3MudGV4dCA9ICcnICsgYXJncy50ZXh0O1xuXG4gIGFyZ3Muc2RmR2x5cGhTaXplID0gYXJncy5zZGZHbHlwaFNpemUgfHwgQ09ORklHLnNkZkdseXBoU2l6ZTtcbiAgYXJncy51bmljb2RlRm9udHNVUkwgPSBhcmdzLnVuaWNvZGVGb250c1VSTCB8fCBDT05GSUcudW5pY29kZUZvbnRzVVJMO1xuXG4gIC8vIE5vcm1hbGl6ZSBjb2xvcnNcbiAgaWYgKGFyZ3MuY29sb3JSYW5nZXMgIT0gbnVsbCkge1xuICAgIGxldCBjb2xvcnMgPSB7fTtcbiAgICBmb3IgKGxldCBrZXkgaW4gYXJncy5jb2xvclJhbmdlcykge1xuICAgICAgaWYgKGFyZ3MuY29sb3JSYW5nZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBsZXQgdmFsID0gYXJncy5jb2xvclJhbmdlc1trZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB2YWwgPSB0ZW1wQ29sb3Iuc2V0KHZhbCkuZ2V0SGV4KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29sb3JzW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICAgIGFyZ3MuY29sb3JSYW5nZXMgPSBjb2xvcnM7XG4gIH1cblxuICBPYmplY3QuZnJlZXplKGFyZ3MpO1xuXG4gIC8vIEluaXQgdGhlIGF0bGFzIGlmIG5lZWRlZFxuICBjb25zdCB7dGV4dHVyZVdpZHRoLCBzZGZFeHBvbmVudH0gPSBDT05GSUc7XG4gIGNvbnN0IHtzZGZHbHlwaFNpemV9ID0gYXJncztcbiAgY29uc3QgZ2x5cGhzUGVyUm93ID0gKHRleHR1cmVXaWR0aCAvIHNkZkdseXBoU2l6ZSAqIDQpO1xuICBsZXQgYXRsYXMgPSBhdGxhc2VzW3NkZkdseXBoU2l6ZV07XG4gIGlmICghYXRsYXMpIHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSB0ZXh0dXJlV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHNkZkdseXBoU2l6ZSAqIDI1NiAvIGdseXBoc1BlclJvdzsgLy8gc3RhcnQgdGFsbCBlbm91Z2ggdG8gZml0IDI1NiBnbHlwaHNcbiAgICBhdGxhcyA9IGF0bGFzZXNbc2RmR2x5cGhTaXplXSA9IHtcbiAgICAgIGdseXBoQ291bnQ6IDAsXG4gICAgICBzZGZHbHlwaFNpemUsXG4gICAgICBzZGZDYW52YXM6IGNhbnZhcyxcbiAgICAgIHNkZlRleHR1cmU6IG5ldyBUZXh0dXJlKFxuICAgICAgICBjYW52YXMsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIExpbmVhckZpbHRlcixcbiAgICAgICAgTGluZWFyRmlsdGVyXG4gICAgICApLFxuICAgICAgY29udGV4dExvc3Q6IGZhbHNlLFxuICAgICAgZ2x5cGhzQnlGb250OiBuZXcgTWFwKClcbiAgICB9O1xuICAgIGF0bGFzLnNkZlRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgaW5pdENvbnRleHRMb3NzSGFuZGxpbmcoYXRsYXMpO1xuICB9XG5cbiAgY29uc3Qge3NkZlRleHR1cmUsIHNkZkNhbnZhc30gPSBhdGxhcztcblxuICAvLyBJc3N1ZSByZXF1ZXN0IHRvIHRoZSB0eXBlc2V0dGluZyBlbmdpbmUgaW4gdGhlIHdvcmtlclxuICB0eXBlc2V0SW5Xb3JrZXIoYXJncykudGhlbihyZXN1bHQgPT4ge1xuICAgIGNvbnN0IHtnbHlwaElkcywgZ2x5cGhGb250SW5kaWNlcywgZm9udERhdGEsIGdseXBoUG9zaXRpb25zLCBmb250U2l6ZSwgdGltaW5nc30gPSByZXN1bHQ7XG4gICAgY29uc3QgbmVlZGVkU0RGcyA9IFtdO1xuICAgIGNvbnN0IGdseXBoQm91bmRzID0gbmV3IEZsb2F0MzJBcnJheShnbHlwaElkcy5sZW5ndGggKiA0KTtcbiAgICBsZXQgYm91bmRzSWR4ID0gMDtcbiAgICBsZXQgcG9zaXRpb25zSWR4ID0gMDtcbiAgICBjb25zdCBxdWFkc1N0YXJ0ID0gbm93JDEoKTtcblxuICAgIGNvbnN0IGZvbnRHbHlwaE1hcHMgPSBmb250RGF0YS5tYXAoZm9udCA9PiB7XG4gICAgICBsZXQgbWFwID0gYXRsYXMuZ2x5cGhzQnlGb250LmdldChmb250LnNyYyk7XG4gICAgICBpZiAoIW1hcCkge1xuICAgICAgICBhdGxhcy5nbHlwaHNCeUZvbnQuc2V0KGZvbnQuc3JjLCBtYXAgPSBuZXcgTWFwKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcFxuICAgIH0pO1xuXG4gICAgZ2x5cGhJZHMuZm9yRWFjaCgoZ2x5cGhJZCwgaSkgPT4ge1xuICAgICAgY29uc3QgZm9udEluZGV4ID0gZ2x5cGhGb250SW5kaWNlc1tpXTtcbiAgICAgIGNvbnN0IHtzcmM6IGZvbnRTcmMsIHVuaXRzUGVyRW19ID0gZm9udERhdGFbZm9udEluZGV4XTtcbiAgICAgIGxldCBnbHlwaEluZm8gPSBmb250R2x5cGhNYXBzW2ZvbnRJbmRleF0uZ2V0KGdseXBoSWQpO1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgZ2x5cGhJZCBub3Qgc2VlbiBiZWZvcmUsIGFkZCBpdCB0byB0aGUgYXRsYXNcbiAgICAgIGlmICghZ2x5cGhJbmZvKSB7XG4gICAgICAgIGNvbnN0IHtwYXRoLCBwYXRoQm91bmRzfSA9IHJlc3VsdC5nbHlwaERhdGFbZm9udFNyY11bZ2x5cGhJZF07XG5cbiAgICAgICAgLy8gTWFyZ2luIGFyb3VuZCBwYXRoIGVkZ2VzIGluIFNERiwgYmFzZWQgb24gYSBwZXJjZW50YWdlIG9mIHRoZSBnbHlwaCdzIG1heCBkaW1lbnNpb24uXG4gICAgICAgIC8vIE5vdGUgd2UgYWRkIGFuIGV4dHJhIDAuNSBweCBvdmVyIHRoZSBjb25maWd1cmVkIHZhbHVlIGJlY2F1c2UgdGhlIG91dGVyIDAuNSBkb2Vzbid0IGNvbnRhaW5cbiAgICAgICAgLy8gdXNlZnVsIGludGVycG9sYXRlZCB2YWx1ZXMgYW5kIHdpbGwgYmUgaWdub3JlZCBhbnl3YXkuXG4gICAgICAgIGNvbnN0IGZvbnRVbml0c01hcmdpbiA9IE1hdGgubWF4KHBhdGhCb3VuZHNbMl0gLSBwYXRoQm91bmRzWzBdLCBwYXRoQm91bmRzWzNdIC0gcGF0aEJvdW5kc1sxXSlcbiAgICAgICAgICAvIHNkZkdseXBoU2l6ZSAqIChDT05GSUcuc2RmTWFyZ2luICogc2RmR2x5cGhTaXplICsgMC41KTtcblxuICAgICAgICBjb25zdCBhdGxhc0luZGV4ID0gYXRsYXMuZ2x5cGhDb3VudCsrO1xuICAgICAgICBjb25zdCBzZGZWaWV3Qm94ID0gW1xuICAgICAgICAgIHBhdGhCb3VuZHNbMF0gLSBmb250VW5pdHNNYXJnaW4sXG4gICAgICAgICAgcGF0aEJvdW5kc1sxXSAtIGZvbnRVbml0c01hcmdpbixcbiAgICAgICAgICBwYXRoQm91bmRzWzJdICsgZm9udFVuaXRzTWFyZ2luLFxuICAgICAgICAgIHBhdGhCb3VuZHNbM10gKyBmb250VW5pdHNNYXJnaW4sXG4gICAgICAgIF07XG4gICAgICAgIGZvbnRHbHlwaE1hcHNbZm9udEluZGV4XS5zZXQoZ2x5cGhJZCwgKGdseXBoSW5mbyA9IHsgcGF0aCwgYXRsYXNJbmRleCwgc2RmVmlld0JveCB9KSk7XG5cbiAgICAgICAgLy8gQ29sbGVjdCB0aG9zZSB0aGF0IG5lZWQgU0RGIGdlbmVyYXRpb25cbiAgICAgICAgbmVlZGVkU0RGcy5wdXNoKGdseXBoSW5mbyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBib3VuZHMgZm9yIHJlbmRlcmFibGUgcXVhZHNcbiAgICAgIC8vIFRPRE8gY2FuIHdlIGdldCB0aGlzIGJhY2sgb2ZmIHRoZSBtYWluIHRocmVhZD9cbiAgICAgIGNvbnN0IHtzZGZWaWV3Qm94fSA9IGdseXBoSW5mbztcbiAgICAgIGNvbnN0IHBvc1ggPSBnbHlwaFBvc2l0aW9uc1twb3NpdGlvbnNJZHgrK107XG4gICAgICBjb25zdCBwb3NZID0gZ2x5cGhQb3NpdGlvbnNbcG9zaXRpb25zSWR4KytdO1xuICAgICAgY29uc3QgZm9udFNpemVNdWx0ID0gZm9udFNpemUgLyB1bml0c1BlckVtO1xuICAgICAgZ2x5cGhCb3VuZHNbYm91bmRzSWR4KytdID0gcG9zWCArIHNkZlZpZXdCb3hbMF0gKiBmb250U2l6ZU11bHQ7XG4gICAgICBnbHlwaEJvdW5kc1tib3VuZHNJZHgrK10gPSBwb3NZICsgc2RmVmlld0JveFsxXSAqIGZvbnRTaXplTXVsdDtcbiAgICAgIGdseXBoQm91bmRzW2JvdW5kc0lkeCsrXSA9IHBvc1ggKyBzZGZWaWV3Qm94WzJdICogZm9udFNpemVNdWx0O1xuICAgICAgZ2x5cGhCb3VuZHNbYm91bmRzSWR4KytdID0gcG9zWSArIHNkZlZpZXdCb3hbM10gKiBmb250U2l6ZU11bHQ7XG5cbiAgICAgIC8vIENvbnZlcnQgZ2x5cGhJZCB0byBTREYgaW5kZXggZm9yIHRoZSBzaGFkZXJcbiAgICAgIGdseXBoSWRzW2ldID0gZ2x5cGhJbmZvLmF0bGFzSW5kZXg7XG4gICAgfSk7XG4gICAgdGltaW5ncy5xdWFkcyA9ICh0aW1pbmdzLnF1YWRzIHx8IDApICsgKG5vdyQxKCkgLSBxdWFkc1N0YXJ0KTtcblxuICAgIGNvbnN0IHNkZlN0YXJ0ID0gbm93JDEoKTtcbiAgICB0aW1pbmdzLnNkZiA9IHt9O1xuXG4gICAgLy8gR3JvdyB0aGUgdGV4dHVyZSBoZWlnaHQgYnkgcG93ZXIgb2YgMiBpZiBuZWVkZWRcbiAgICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gc2RmQ2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBuZWVkZWRSb3dzID0gTWF0aC5jZWlsKGF0bGFzLmdseXBoQ291bnQgLyBnbHlwaHNQZXJSb3cpO1xuICAgIGNvbnN0IG5lZWRlZEhlaWdodCA9IE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIobmVlZGVkUm93cyAqIHNkZkdseXBoU2l6ZSkpKTtcbiAgICBpZiAobmVlZGVkSGVpZ2h0ID4gY3VycmVudEhlaWdodCkge1xuICAgICAgLy8gU2luY2UgcmVzaXppbmcgdGhlIGNhbnZhcyBjbGVhcnMgaXRzIHJlbmRlciBidWZmZXIsIGl0IG5lZWRzIHNwZWNpYWwgaGFuZGxpbmcgdG8gY29weSB0aGUgb2xkIGNvbnRlbnRzIG92ZXJcbiAgICAgIGNvbnNvbGUuaW5mbyhgSW5jcmVhc2luZyBTREYgdGV4dHVyZSBzaXplICR7Y3VycmVudEhlaWdodH0tPiR7bmVlZGVkSGVpZ2h0fWApO1xuICAgICAgcmVzaXplV2ViR0xDYW52YXNXaXRob3V0Q2xlYXJpbmcoc2RmQ2FudmFzLCB0ZXh0dXJlV2lkdGgsIG5lZWRlZEhlaWdodCk7XG4gICAgICAvLyBBcyBvZiBUaHJlZSByMTM2IHRleHR1cmVzIGNhbm5vdCBiZSByZXNpemVkIG9uY2UgdGhleSdyZSBhbGxvY2F0ZWQgb24gdGhlIEdQVSwgd2UgbXVzdCBkaXNwb3NlIHRvIHJlYWxsb2NhdGUgaXRcbiAgICAgIHNkZlRleHR1cmUuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIFByb21pc2UuYWxsKG5lZWRlZFNERnMubWFwKGdseXBoSW5mbyA9PlxuICAgICAgZ2VuZXJhdGVHbHlwaFNERihnbHlwaEluZm8sIGF0bGFzLCBhcmdzLmdwdUFjY2VsZXJhdGVTREYpLnRoZW4oKHt0aW1pbmd9KSA9PiB7XG4gICAgICAgIHRpbWluZ3Muc2RmW2dseXBoSW5mby5hdGxhc0luZGV4XSA9IHRpbWluZztcbiAgICAgIH0pXG4gICAgKSkudGhlbigoKSA9PiB7XG4gICAgICBpZiAobmVlZGVkU0RGcy5sZW5ndGggJiYgIWF0bGFzLmNvbnRleHRMb3N0KSB7XG4gICAgICAgIHNhZmFyaVByZTE1V29ya2Fyb3VuZChhdGxhcyk7XG4gICAgICAgIHNkZlRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGltaW5ncy5zZGZUb3RhbCA9IG5vdyQxKCkgLSBzZGZTdGFydDtcbiAgICAgIHRpbWluZ3MudG90YWwgPSBub3ckMSgpIC0gdG90YWxTdGFydDtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBTREYgLSAke3RpbWluZ3Muc2RmVG90YWx9LCBUb3RhbCAtICR7dGltaW5ncy50b3RhbCAtIHRpbWluZ3MuZm9udExvYWR9YClcblxuICAgICAgLy8gSW52b2tlIGNhbGxiYWNrIHdpdGggdGhlIHRleHQgbGF5b3V0IGFycmF5cyBhbmQgdXBkYXRlZCB0ZXh0dXJlXG4gICAgICBjYWxsYmFjayhPYmplY3QuZnJlZXplKHtcbiAgICAgICAgcGFyYW1ldGVyczogYXJncyxcbiAgICAgICAgc2RmVGV4dHVyZSxcbiAgICAgICAgc2RmR2x5cGhTaXplLFxuICAgICAgICBzZGZFeHBvbmVudCxcbiAgICAgICAgZ2x5cGhCb3VuZHMsXG4gICAgICAgIGdseXBoQXRsYXNJbmRpY2VzOiBnbHlwaElkcyxcbiAgICAgICAgZ2x5cGhDb2xvcnM6IHJlc3VsdC5nbHlwaENvbG9ycyxcbiAgICAgICAgY2FyZXRQb3NpdGlvbnM6IHJlc3VsdC5jYXJldFBvc2l0aW9ucyxcbiAgICAgICAgY2h1bmtlZEJvdW5kczogcmVzdWx0LmNodW5rZWRCb3VuZHMsXG4gICAgICAgIGFzY2VuZGVyOiByZXN1bHQuYXNjZW5kZXIsXG4gICAgICAgIGRlc2NlbmRlcjogcmVzdWx0LmRlc2NlbmRlcixcbiAgICAgICAgbGluZUhlaWdodDogcmVzdWx0LmxpbmVIZWlnaHQsXG4gICAgICAgIGNhcEhlaWdodDogcmVzdWx0LmNhcEhlaWdodCxcbiAgICAgICAgeEhlaWdodDogcmVzdWx0LnhIZWlnaHQsXG4gICAgICAgIHRvcEJhc2VsaW5lOiByZXN1bHQudG9wQmFzZWxpbmUsXG4gICAgICAgIGJsb2NrQm91bmRzOiByZXN1bHQuYmxvY2tCb3VuZHMsXG4gICAgICAgIHZpc2libGVCb3VuZHM6IHJlc3VsdC52aXNpYmxlQm91bmRzLFxuICAgICAgICB0aW1pbmdzOiByZXN1bHQudGltaW5ncyxcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gV2hpbGUgdGhlIHR5cGVzZXR0aW5nIHJlcXVlc3QgaXMgYmVpbmcgaGFuZGxlZCwgZ28gYWhlYWQgYW5kIG1ha2Ugc3VyZSB0aGUgYXRsYXMgY2FudmFzIGNvbnRleHQgaXNcbiAgLy8gXCJ3YXJtZWQgdXBcIjsgdGhlIGZpcnN0IHJlcXVlc3Qgd2lsbCBiZSB0aGUgbG9uZ2VzdCBkdWUgdG8gc2hhZGVyIHByb2dyYW0gY29tcGlsYXRpb24gc28gdGhpcyBnZXRzXG4gIC8vIGEgaGVhZCBzdGFydCBvbiB0aGF0IHByb2Nlc3MgYmVmb3JlIFNERnMgYWN0dWFsbHkgc3RhcnQgZ2V0dGluZyBwcm9jZXNzZWQuXG4gIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIGlmICghYXRsYXMuY29udGV4dExvc3QpIHtcbiAgICAgIHdhcm1VcFNERkNhbnZhcyhzZGZDYW52YXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlR2x5cGhTREYoe3BhdGgsIGF0bGFzSW5kZXgsIHNkZlZpZXdCb3h9LCB7c2RmR2x5cGhTaXplLCBzZGZDYW52YXMsIGNvbnRleHRMb3N0fSwgdXNlR1BVKSB7XG4gIGlmIChjb250ZXh0TG9zdCkge1xuICAgIC8vIElmIHRoZSBjb250ZXh0IGlzIGxvc3QgdGhlcmUncyBub3RoaW5nIHdlIGNhbiBkbywganVzdCBxdWl0IHNpbGVudGx5IGFuZCBsZXQgaXRcbiAgICAvLyBnZXQgcmVnZW5lcmF0ZWQgd2hlbiB0aGUgY29udGV4dCBpcyByZXN0b3JlZFxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe3RpbWluZzogLTF9KVxuICB9XG4gIGNvbnN0IHt0ZXh0dXJlV2lkdGgsIHNkZkV4cG9uZW50fSA9IENPTkZJRztcbiAgY29uc3QgbWF4RGlzdCA9IE1hdGgubWF4KHNkZlZpZXdCb3hbMl0gLSBzZGZWaWV3Qm94WzBdLCBzZGZWaWV3Qm94WzNdIC0gc2RmVmlld0JveFsxXSk7XG4gIGNvbnN0IHNxdWFyZUluZGV4ID0gTWF0aC5mbG9vcihhdGxhc0luZGV4IC8gNCk7XG4gIGNvbnN0IHggPSBzcXVhcmVJbmRleCAlICh0ZXh0dXJlV2lkdGggLyBzZGZHbHlwaFNpemUpICogc2RmR2x5cGhTaXplO1xuICBjb25zdCB5ID0gTWF0aC5mbG9vcihzcXVhcmVJbmRleCAvICh0ZXh0dXJlV2lkdGggLyBzZGZHbHlwaFNpemUpKSAqIHNkZkdseXBoU2l6ZTtcbiAgY29uc3QgY2hhbm5lbCA9IGF0bGFzSW5kZXggJSA0O1xuICByZXR1cm4gZ2VuZXJhdGVTREYoc2RmR2x5cGhTaXplLCBzZGZHbHlwaFNpemUsIHBhdGgsIHNkZlZpZXdCb3gsIG1heERpc3QsIHNkZkV4cG9uZW50LCBzZGZDYW52YXMsIHgsIHksIGNoYW5uZWwsIHVzZUdQVSlcbn1cblxuZnVuY3Rpb24gaW5pdENvbnRleHRMb3NzSGFuZGxpbmcoYXRsYXMpIHtcbiAgY29uc3QgY2FudmFzID0gYXRsYXMuc2RmQ2FudmFzO1xuXG4gIC8qXG4gIC8vIEJlZ2luIGNvbnRleHQgbG9zcyBzaW11bGF0aW9uXG4gIGlmICghd2luZG93LldlYkdMRGVidWdVdGlscykge1xuICAgIGxldCBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2ViR0xEZWJ1Z1V0aWxzU2NyaXB0JylcbiAgICBpZiAoIXNjcmlwdCkge1xuICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICAgIHNjcmlwdC5pZCA9ICdXZWJHTERlYnVnVXRpbHMnXG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdClcbiAgICAgIHNjcmlwdC5zcmMgPSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0tocm9ub3NHcm91cC9XZWJHTERldmVsb3BlclRvb2xzQGI0MmU3MDIvc3JjL2RlYnVnL3dlYmdsLWRlYnVnLmpzJ1xuICAgIH1cbiAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgIGluaXRDb250ZXh0TG9zc0hhbmRsaW5nKGF0bGFzKVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cbiAgd2luZG93LldlYkdMRGVidWdVdGlscy5tYWtlTG9zdENvbnRleHRTaW11bGF0aW5nQ2FudmFzKGNhbnZhcylcbiAgY2FudmFzLmxvc2VDb250ZXh0SW5OQ2FsbHMoNTAwKVxuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCAoZXZlbnQpID0+IHtcbiAgICBjYW52YXMubG9zZUNvbnRleHRJbk5DYWxscyg1MDAwKVxuICB9KVxuICAvLyBFbmQgY29udGV4dCBsb3NzIHNpbXVsYXRpb25cbiAgKi9cblxuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIChldmVudCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdDb250ZXh0IExvc3QnLCBldmVudCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBhdGxhcy5jb250ZXh0TG9zdCA9IHRydWU7XG4gIH0pO1xuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCAoZXZlbnQpID0+IHtcbiAgICBjb25zb2xlLmxvZygnQ29udGV4dCBSZXN0b3JlZCcsIGV2ZW50KTtcbiAgICBhdGxhcy5jb250ZXh0TG9zdCA9IGZhbHNlO1xuICAgIC8vIFJlZ2VuZXJhdGUgYWxsIGdseXBocyBpbnRvIHRoZSByZXN0b3JlZCBjYW52YXM6XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBhdGxhcy5nbHlwaHNCeUZvbnQuZm9yRWFjaChnbHlwaE1hcCA9PiB7XG4gICAgICBnbHlwaE1hcC5mb3JFYWNoKGdseXBoID0+IHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChnZW5lcmF0ZUdseXBoU0RGKGdseXBoLCBhdGxhcywgdHJ1ZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgc2FmYXJpUHJlMTVXb3JrYXJvdW5kKGF0bGFzKTtcbiAgICAgIGF0bGFzLnNkZlRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQcmVsb2FkIGEgZ2l2ZW4gZm9udCBhbmQgb3B0aW9uYWxseSBwcmUtZ2VuZXJhdGUgZ2x5cGggU0RGcyBmb3Igb25lIG9yIG1vcmUgY2hhcmFjdGVyIHNlcXVlbmNlcy5cbiAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBhdm9pZCBsb25nIHBhdXNlcyB3aGVuIGZpcnN0IHNob3dpbmcgdGV4dCBpbiBhIHNjZW5lLCBieSBwcmVsb2FkaW5nIHRoZVxuICogbmVlZGVkIGZvbnRzIGFuZCBnbHlwaHMgdXAgZnJvbnQgYWxvbmcgd2l0aCBvdGhlciBhc3NldHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmZvbnQgLSBVUkwgb2YgdGhlIGZvbnQgZmlsZSB0byBwcmVsb2FkLiBJZiBub3QgZ2l2ZW4sIHRoZSBkZWZhdWx0IGZvbnQgd2lsbFxuICogICAgICAgIGJlIGxvYWRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBvcHRpb25zLmNoYXJhY3RlcnMgLSBPbmUgb3IgbW9yZSBjaGFyYWN0ZXIgc2VxdWVuY2VzIGZvciB3aGljaCB0byBwcmUtXG4gKiAgICAgICAgZ2VuZXJhdGUgZ2x5cGggU0RGcy4gTm90ZSB0aGF0IHRoaXMgd2lsbCBob25vciBsaWdhdHVyZSBzdWJzdGl0dXRpb24sIHNvIHlvdSBtYXkgbmVlZFxuICogICAgICAgIHRvIHNwZWNpZnkgbGlnYXR1cmUgc2VxdWVuY2VzIGluIGFkZGl0aW9uIHRvIHRoZWlyIGluZGl2aWR1YWwgY2hhcmFjdGVycyB0byBnZXQgYWxsXG4gKiAgICAgICAgcG9zc2libGUgZ2x5cGhzLCBlLmcuIGBbXCJ0XCIsIFwiaFwiLCBcInRoXCJdYCB0byBnZXQgdGhlIFwidFwiIGFuZCBcImhcIiBnbHlwaHMgcGx1cyB0aGUgXCJ0aFwiIGxpZ2F0dXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuc2RmR2x5cGhTaXplIC0gVGhlIHNpemUgYXQgd2hpY2ggdG8gcHJlcmVuZGVyIHRoZSBTREYgdGV4dHVyZXMgZm9yIHRoZVxuICogICAgICAgIHNwZWNpZmllZCBgY2hhcmFjdGVyc2AuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBwcmVsb2FkaW5nIGlzIGNvbXBsZXRlLlxuICovXG5mdW5jdGlvbiBwcmVsb2FkRm9udCh7Zm9udCwgY2hhcmFjdGVycywgc2RmR2x5cGhTaXplfSwgY2FsbGJhY2spIHtcbiAgbGV0IHRleHQgPSBBcnJheS5pc0FycmF5KGNoYXJhY3RlcnMpID8gY2hhcmFjdGVycy5qb2luKCdcXG4nKSA6ICcnICsgY2hhcmFjdGVycztcbiAgZ2V0VGV4dFJlbmRlckluZm8oeyBmb250LCBzZGZHbHlwaFNpemUsIHRleHQgfSwgY2FsbGJhY2spO1xufVxuXG5cbi8vIExvY2FsIGFzc2lnbiBpbXBsIHNvIHdlIGRvbid0IGhhdmUgdG8gaW1wb3J0IHRyb2lrYS1jb3JlXG5mdW5jdGlvbiBhc3NpZ24odG9PYmosIGZyb21PYmopIHtcbiAgZm9yIChsZXQga2V5IGluIGZyb21PYmopIHtcbiAgICBpZiAoZnJvbU9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB0b09ialtrZXldID0gZnJvbU9ialtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9PYmpcbn1cblxuLy8gVXRpbGl0eSBmb3IgbWFraW5nIFVSTHMgYWJzb2x1dGVcbmxldCBsaW5rRWw7XG5mdW5jdGlvbiB0b0Fic29sdXRlVVJMKHBhdGgpIHtcbiAgaWYgKCFsaW5rRWwpIHtcbiAgICBsaW5rRWwgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8ge30gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIH1cbiAgbGlua0VsLmhyZWYgPSBwYXRoO1xuICByZXR1cm4gbGlua0VsLmhyZWZcbn1cblxuLyoqXG4gKiBTYWZhcmkgPCB2MTUgc2VlbXMgdW5hYmxlIHRvIHVzZSB0aGUgU0RGIHdlYmdsIGNhbnZhcyBhcyBhIHRleHR1cmUuIFRoaXMgYXBwbGllcyBhIHdvcmthcm91bmRcbiAqIHdoZXJlIGl0IHJlYWRzIHRoZSBwaXhlbHMgb3V0IG9mIHRoYXQgY2FudmFzIGFuZCB1cGxvYWRzIHRoZW0gYXMgYSBkYXRhIHRleHR1cmUgaW5zdGVhZCwgYXRcbiAqIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGNvc3QuXG4gKi9cbmZ1bmN0aW9uIHNhZmFyaVByZTE1V29ya2Fyb3VuZChhdGxhcykge1xuICAvLyBVc2UgY3JlYXRlSW1hZ2VCaXRtYXAgc3VwcG9ydCBhcyBhIHByb3h5IGZvciBTYWZhcmk8MTUsIGFsbCBvdGhlciBtYWluc3RyZWFtIGJyb3dzZXJzXG4gIC8vIGhhdmUgc3VwcG9ydGVkIGl0IGZvciBhIGxvbmcgd2hpbGUgc28gYW55IGZhbHNlIHBvc2l0aXZlcyBzaG91bGQgYmUgbWluaW1hbC5cbiAgaWYgKHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuaW5mbygnU2FmYXJpPDE1OiBhcHBseWluZyBTREYgY2FudmFzIHdvcmthcm91bmQnKTtcbiAgICBjb25zdCB7c2RmQ2FudmFzLCBzZGZUZXh0dXJlfSA9IGF0bGFzO1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHNkZkNhbnZhcztcbiAgICBjb25zdCBnbCA9IGF0bGFzLnNkZkNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpO1xuICAgIGxldCBwaXhlbHMgPSBzZGZUZXh0dXJlLmltYWdlLmRhdGE7XG4gICAgaWYgKCFwaXhlbHMgfHwgcGl4ZWxzLmxlbmd0aCAhPT0gd2lkdGggKiBoZWlnaHQgKiA0KSB7XG4gICAgICBwaXhlbHMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgc2RmVGV4dHVyZS5pbWFnZSA9IHt3aWR0aCwgaGVpZ2h0LCBkYXRhOiBwaXhlbHN9O1xuICAgICAgc2RmVGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuICAgICAgc2RmVGV4dHVyZS5pc0RhdGFUZXh0dXJlID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBwaXhlbHMpO1xuICB9XG59XG5cbmNvbnN0IHR5cGVzZXR0ZXJXb3JrZXJNb2R1bGUgPSAvKiNfX1BVUkVfXyovZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgbmFtZTogJ1R5cGVzZXR0ZXInLFxuICBkZXBlbmRlbmNpZXM6IFtcbiAgICBjcmVhdGVUeXBlc2V0dGVyLFxuICAgIGZvbnRSZXNvbHZlcldvcmtlck1vZHVsZSxcbiAgICBiaWRpRmFjdG9yeSxcbiAgXSxcbiAgaW5pdChjcmVhdGVUeXBlc2V0dGVyLCBmb250UmVzb2x2ZXIsIGJpZGlGYWN0b3J5KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVR5cGVzZXR0ZXIoZm9udFJlc29sdmVyLCBiaWRpRmFjdG9yeSgpKVxuICB9XG59KTtcblxuY29uc3QgdHlwZXNldEluV29ya2VyID0gLyojX19QVVJFX18qL2RlZmluZVdvcmtlck1vZHVsZSh7XG4gIG5hbWU6ICdUeXBlc2V0dGVyJyxcbiAgZGVwZW5kZW5jaWVzOiBbXG4gICAgdHlwZXNldHRlcldvcmtlck1vZHVsZSxcbiAgXSxcbiAgaW5pdCh0eXBlc2V0dGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdHlwZXNldHRlci50eXBlc2V0KGFyZ3MsIHJlc29sdmUpO1xuICAgICAgfSlcbiAgICB9XG4gIH0sXG4gIGdldFRyYW5zZmVyYWJsZXMocmVzdWx0KSB7XG4gICAgLy8gTWFyayBhcnJheSBidWZmZXJzIGFzIHRyYW5zZmVyYWJsZSB0byBhdm9pZCBjbG9uaW5nIGR1cmluZyBwb3N0TWVzc2FnZVxuICAgIGNvbnN0IHRyYW5zZmVyYWJsZXMgPSBbXTtcbiAgICBmb3IgKGxldCBwIGluIHJlc3VsdCkge1xuICAgICAgaWYgKHJlc3VsdFtwXSAmJiByZXN1bHRbcF0uYnVmZmVyKSB7XG4gICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChyZXN1bHRbcF0uYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZmVyYWJsZXNcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGR1bXBTREZUZXh0dXJlcygpIHtcbiAgT2JqZWN0LmtleXMoYXRsYXNlcykuZm9yRWFjaChzaXplID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBhdGxhc2VzW3NpemVdLnNkZkNhbnZhcztcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBjYW52YXM7XG4gICAgY29uc29sZS5sb2coXCIlYy5cIiwgYFxuICAgICAgYmFja2dyb3VuZDogdXJsKCR7Y2FudmFzLnRvRGF0YVVSTCgpfSk7XG4gICAgICBiYWNrZ3JvdW5kLXNpemU6ICR7d2lkdGh9cHggJHtoZWlnaHR9cHg7XG4gICAgICBjb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICBmb250LXNpemU6IDA7XG4gICAgICBsaW5lLWhlaWdodDogJHtoZWlnaHR9cHg7XG4gICAgICBwYWRkaW5nLWxlZnQ6ICR7d2lkdGh9cHg7XG4gICAgYCk7XG4gIH0pO1xufVxuXG5jb25zdCB0ZW1wbGF0ZUdlb21ldHJpZXMgPSB7fTtcblxuZnVuY3Rpb24gZ2V0VGVtcGxhdGVHZW9tZXRyeShkZXRhaWwpIHtcbiAgbGV0IGdlb20gPSB0ZW1wbGF0ZUdlb21ldHJpZXNbZGV0YWlsXTtcbiAgaWYgKCFnZW9tKSB7XG4gICAgLy8gR2VvbWV0cnkgaXMgdHdvIHBsYW5lcyBiYWNrLXRvLWJhY2ssIHdoaWNoIHdpbGwgYWx3YXlzIGJlIHJlbmRlcmVkIEZyb250U2lkZSBvbmx5IGJ1dFxuICAgIC8vIGFwcGVhciBhcyBEb3VibGVTaWRlIGJ5IGRlZmF1bHQuIEZyb250U2lkZS9CYWNrU2lkZSBhcmUgZW11bGF0ZWQgdXNpbmcgZHJhd1JhbmdlLlxuICAgIC8vIFdlIGRvIGl0IHRoaXMgd2F5IHRvIGF2b2lkIHRoZSBwZXJmb3JtYW5jZSBoaXQgb2YgdHdvIGRyYXcgY2FsbHMgZm9yIERvdWJsZVNpZGUgbWF0ZXJpYWxzXG4gICAgLy8gaW50cm9kdWNlZCBieSBUaHJlZS5qcyBpbiByMTMwIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yMTk2N1xuICAgIGNvbnN0IGZyb250ID0gbmV3IFBsYW5lR2VvbWV0cnkoMSwgMSwgZGV0YWlsLCBkZXRhaWwpO1xuICAgIGNvbnN0IGJhY2sgPSBmcm9udC5jbG9uZSgpO1xuICAgIGNvbnN0IGZyb250QXR0cnMgPSBmcm9udC5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IGJhY2tBdHRycyA9IGJhY2suYXR0cmlidXRlcztcbiAgICBjb25zdCBjb21iaW5lZCA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIGNvbnN0IHZlcnRDb3VudCA9IGZyb250QXR0cnMudXYuY291bnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0Q291bnQ7IGkrKykge1xuICAgICAgYmFja0F0dHJzLnBvc2l0aW9uLmFycmF5W2kgKiAzXSAqPSAtMTsgLy8gZmxpcCBwb3NpdGlvbiB4XG4gICAgICBiYWNrQXR0cnMubm9ybWFsLmFycmF5W2kgKiAzICsgMl0gKj0gLTE7IC8vIGZsaXAgbm9ybWFsIHpcbiAgICB9XG4gICAgWydwb3NpdGlvbicsICdub3JtYWwnLCAndXYnXS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgY29tYmluZWQuc2V0QXR0cmlidXRlKG5hbWUsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKFxuICAgICAgICBbLi4uZnJvbnRBdHRyc1tuYW1lXS5hcnJheSwgLi4uYmFja0F0dHJzW25hbWVdLmFycmF5XSxcbiAgICAgICAgZnJvbnRBdHRyc1tuYW1lXS5pdGVtU2l6ZSlcbiAgICAgICk7XG4gICAgfSk7XG4gICAgY29tYmluZWQuc2V0SW5kZXgoWy4uLmZyb250LmluZGV4LmFycmF5LCAuLi5iYWNrLmluZGV4LmFycmF5Lm1hcChuID0+IG4gKyB2ZXJ0Q291bnQpXSk7XG4gICAgY29tYmluZWQudHJhbnNsYXRlKDAuNSwgMC41LCAwKTtcbiAgICBnZW9tID0gdGVtcGxhdGVHZW9tZXRyaWVzW2RldGFpbF0gPSBjb21iaW5lZDtcbiAgfVxuICByZXR1cm4gZ2VvbVxufVxuXG5jb25zdCBnbHlwaEJvdW5kc0F0dHJOYW1lID0gJ2FUcm9pa2FHbHlwaEJvdW5kcyc7XG5jb25zdCBnbHlwaEluZGV4QXR0ck5hbWUgPSAnYVRyb2lrYUdseXBoSW5kZXgnO1xuY29uc3QgZ2x5cGhDb2xvckF0dHJOYW1lID0gJ2FUcm9pa2FHbHlwaENvbG9yJztcblxuLyoqXG5AY2xhc3MgR2x5cGhzR2VvbWV0cnlcblxuQSBzcGVjaWFsaXplZCBHZW9tZXRyeSBmb3IgcmVuZGVyaW5nIGEgc2V0IG9mIHRleHQgZ2x5cGhzLiBVc2VzIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IHRvXG5yZW5kZXIgdGhlIGdseXBocyB1c2luZyBHUFUgaW5zdGFuY2luZyBvZiBhIHNpbmdsZSBxdWFkLCByYXRoZXIgdGhhbiBjb25zdHJ1Y3RpbmcgYSB3aG9sZVxuZ2VvbWV0cnkgd2l0aCB2ZXJ0aWNlcywgZm9yIG11Y2ggc21hbGxlciBhdHRyaWJ1dGUgYXJyYXlidWZmZXJzIGFjY29yZGluZyB0byB0aGlzIG1hdGg6XG5cbiAgV2hlcmUgTiA9IG51bWJlciBvZiBnbHlwaHMuLi5cblxuICBJbnN0YW5jZWQ6XG4gIC0gcG9zaXRpb246IDQgKiAzXG4gIC0gaW5kZXg6IDIgKiAzXG4gIC0gbm9ybWFsOiA0ICogM1xuICAtIHV2OiA0ICogMlxuICAtIGdseXBoIHgveSBib3VuZHM6IE4gKiA0XG4gIC0gZ2x5cGggaW5kaWNlczogTiAqIDFcbiAgPSA1TiArIDM4XG5cbiAgTm9uLWluc3RhbmNlZDpcbiAgLSBwb3NpdGlvbjogTiAqIDQgKiAzXG4gIC0gaW5kZXg6IE4gKiAyICogM1xuICAtIG5vcm1hbDogTiAqIDQgKiAzXG4gIC0gdXY6IE4gKiA0ICogMlxuICAtIGdseXBoIGluZGljZXM6IE4gKiAxXG4gID0gMzlOXG5cbkEgZG93bnNpZGUgb2YgdGhpcyBpcyB0aGUgcmFyZS1idXQtcG9zc2libGUgbGFjayBvZiB0aGUgaW5zdGFuY2VkIGFycmF5cyBleHRlbnNpb24sXG53aGljaCB3ZSBjb3VsZCBwb3RlbnRpYWxseSB3b3JrIGFyb3VuZCB3aXRoIGEgZmFsbGJhY2sgbm9uLWluc3RhbmNlZCBpbXBsZW1lbnRhdGlvbi5cblxuKi9cbmNsYXNzIEdseXBoc0dlb21ldHJ5IGV4dGVuZHMgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5kZXRhaWwgPSAxO1xuICAgIHRoaXMuY3VydmVSYWRpdXMgPSAwO1xuXG4gICAgLy8gRGVmaW5lIGdyb3VwcyBmb3IgcmVuZGVyaW5nIHRleHQgb3V0bGluZSBhcyBhIHNlcGFyYXRlIHBhc3M7IHRoZXNlIHdpbGwgb25seVxuICAgIC8vIGJlIHVzZWQgd2hlbiB0aGUgYG1hdGVyaWFsYCBnZXR0ZXIgcmV0dXJucyBhbiBhcnJheSwgaS5lLiBvdXRsaW5lV2lkdGggPiAwLlxuICAgIHRoaXMuZ3JvdXBzID0gW1xuICAgICAge3N0YXJ0OiAwLCBjb3VudDogSW5maW5pdHksIG1hdGVyaWFsSW5kZXg6IDB9LFxuICAgICAge3N0YXJ0OiAwLCBjb3VudDogSW5maW5pdHksIG1hdGVyaWFsSW5kZXg6IDF9XG4gICAgXTtcblxuICAgIC8vIFByZWFsbG9jYXRlIGVtcHR5IGJvdW5kaW5nIG9iamVjdHNcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuICAgIHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xuICB9XG5cbiAgY29tcHV0ZUJvdW5kaW5nU3BoZXJlICgpIHtcbiAgICAvLyBOby1vcDsgd2UnbGwgc3luYyB0aGUgYm91bmRpbmdTcGhlcmUgcHJvYWN0aXZlbHkgd2hlbiBuZWVkZWQuXG4gIH1cblxuICBjb21wdXRlQm91bmRpbmdCb3goKSB7XG4gICAgLy8gTm8tb3A7IHdlJ2xsIHN5bmMgdGhlIGJvdW5kaW5nQm94IHByb2FjdGl2ZWx5IHdoZW4gbmVlZGVkLlxuICB9XG5cbiAgLy8gU2luY2Ugb3VyIGJhc2UgZ2VvbWV0cnkgY29udGFpbnMgdHJpYW5nbGVzIGZvciBib3RoIGZyb250IGFuZCBiYWNrIHNpZGVzLCB3ZSBjYW4gZW11bGF0ZVxuICAvLyB0aGUgXCJzaWRlXCIgYnkgcmVzdHJpY3RpbmcgdGhlIGRyYXcgcmFuZ2UuXG4gIHNldFNpZGUoc2lkZSkge1xuICAgIGNvbnN0IHZlcnRzID0gdGhpcy5nZXRJbmRleCgpLmNvdW50O1xuICAgIHRoaXMuc2V0RHJhd1JhbmdlKHNpZGUgPT09IEJhY2tTaWRlID8gdmVydHMgLyAyIDogMCwgc2lkZSA9PT0gRG91YmxlU2lkZSA/IHZlcnRzIDogdmVydHMgLyAyKTtcbiAgfVxuXG4gIHNldCBkZXRhaWwoZGV0YWlsKSB7XG4gICAgaWYgKGRldGFpbCAhPT0gdGhpcy5fZGV0YWlsKSB7XG4gICAgICB0aGlzLl9kZXRhaWwgPSBkZXRhaWw7XG4gICAgICBpZiAodHlwZW9mIGRldGFpbCAhPT0gJ251bWJlcicgfHwgZGV0YWlsIDwgMSkge1xuICAgICAgICBkZXRhaWwgPSAxO1xuICAgICAgfVxuICAgICAgbGV0IHRwbCA9IGdldFRlbXBsYXRlR2VvbWV0cnkoZGV0YWlsKVxuICAgICAgO1sncG9zaXRpb24nLCAnbm9ybWFsJywgJ3V2J10uZm9yRWFjaChhdHRyID0+IHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJdID0gdHBsLmF0dHJpYnV0ZXNbYXR0cl0uY2xvbmUoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRJbmRleCh0cGwuZ2V0SW5kZXgoKS5jbG9uZSgpKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGRldGFpbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGV0YWlsXG4gIH1cblxuICBzZXQgY3VydmVSYWRpdXMocikge1xuICAgIGlmIChyICE9PSB0aGlzLl9jdXJ2ZVJhZGl1cykge1xuICAgICAgdGhpcy5fY3VydmVSYWRpdXMgPSByO1xuICAgICAgdGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gICAgfVxuICB9XG4gIGdldCBjdXJ2ZVJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VydmVSYWRpdXNcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGdlb21ldHJ5IGZvciBhIG5ldyBzZXQgb2YgZ2x5cGhzLlxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZ2x5cGhCb3VuZHMgLSBBbiBhcnJheSBob2xkaW5nIHRoZSBwbGFuYXIgYm91bmRzIGZvciBhbGwgZ2x5cGhzXG4gICAqICAgICAgICB0byBiZSByZW5kZXJlZCwgNCBlbnRyaWVzIGZvciBlYWNoIGdseXBoOiB4MSx4Mix5MSx5MVxuICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gZ2x5cGhBdGxhc0luZGljZXMgLSBBbiBhcnJheSBob2xkaW5nIHRoZSBpbmRleCBvZiBlYWNoIGdseXBoIHdpdGhpblxuICAgKiAgICAgICAgdGhlIFNERiBhdGxhcyB0ZXh0dXJlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBibG9ja0JvdW5kcyAtIEFuIGFycmF5IGhvbGRpbmcgdGhlIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBhY3Jvc3MgYWxsIGdseXBoc1xuICAgKiBAcGFyYW0ge0FycmF5fSBbY2h1bmtlZEJvdW5kc10gLSBBbiBhcnJheSBvZiBvYmplY3RzIGRlc2NyaWJpbmcgYm91bmRzIGZvciBlYWNoIGNodW5rIG9mIE5cbiAgICogICAgICAgIGNvbnNlY3V0aXZlIGdseXBoczogYHtzdGFydDpOLCBlbmQ6TiwgcmVjdDpbbWluWCwgbWluWSwgbWF4WCwgbWF4WV19YC4gVGhpcyBjYW4gYmVcbiAgICogICAgICAgIHVzZWQgd2l0aCBgYXBwbHlDbGlwUmVjdGAgdG8gY2hvb3NlIGFuIG9wdGltaXplZCBgaW5zdGFuY2VDb3VudGAuXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gW2dseXBoQ29sb3JzXSAtIEFuIGFycmF5IGhvbGRpbmcgcixnLGIgdmFsdWVzIGZvciBlYWNoIGdseXBoLlxuICAgKi9cbiAgdXBkYXRlR2x5cGhzKGdseXBoQm91bmRzLCBnbHlwaEF0bGFzSW5kaWNlcywgYmxvY2tCb3VuZHMsIGNodW5rZWRCb3VuZHMsIGdseXBoQ29sb3JzKSB7XG4gICAgLy8gVXBkYXRlIHRoZSBpbnN0YW5jZSBhdHRyaWJ1dGVzXG4gICAgdXBkYXRlQnVmZmVyQXR0cih0aGlzLCBnbHlwaEJvdW5kc0F0dHJOYW1lLCBnbHlwaEJvdW5kcywgNCk7XG4gICAgdXBkYXRlQnVmZmVyQXR0cih0aGlzLCBnbHlwaEluZGV4QXR0ck5hbWUsIGdseXBoQXRsYXNJbmRpY2VzLCAxKTtcbiAgICB1cGRhdGVCdWZmZXJBdHRyKHRoaXMsIGdseXBoQ29sb3JBdHRyTmFtZSwgZ2x5cGhDb2xvcnMsIDMpO1xuICAgIHRoaXMuX2Jsb2NrQm91bmRzID0gYmxvY2tCb3VuZHM7XG4gICAgdGhpcy5fY2h1bmtlZEJvdW5kcyA9IGNodW5rZWRCb3VuZHM7XG4gICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gZ2x5cGhBdGxhc0luZGljZXMubGVuZ3RoO1xuICAgIHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuICB9XG5cbiAgX3VwZGF0ZUJvdW5kcygpIHtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9ibG9ja0JvdW5kcztcbiAgICBpZiAoYm91bmRzKSB7XG4gICAgICBjb25zdCB7IGN1cnZlUmFkaXVzLCBib3VuZGluZ0JveDogYmJveCB9ID0gdGhpcztcbiAgICAgIGlmIChjdXJ2ZVJhZGl1cykge1xuICAgICAgICBjb25zdCB7IFBJLCBmbG9vciwgbWluLCBtYXgsIHNpbiwgY29zIH0gPSBNYXRoO1xuICAgICAgICBjb25zdCBoYWxmUGkgPSBQSSAvIDI7XG4gICAgICAgIGNvbnN0IHR3b1BpID0gUEkgKiAyO1xuICAgICAgICBjb25zdCBhYnNSID0gTWF0aC5hYnMoY3VydmVSYWRpdXMpO1xuICAgICAgICBjb25zdCBsZWZ0QW5nbGUgPSBib3VuZHNbMF0gLyBhYnNSO1xuICAgICAgICBjb25zdCByaWdodEFuZ2xlID0gYm91bmRzWzJdIC8gYWJzUjtcbiAgICAgICAgY29uc3QgbWluWCA9IGZsb29yKChsZWZ0QW5nbGUgKyBoYWxmUGkpIC8gdHdvUGkpICE9PSBmbG9vcigocmlnaHRBbmdsZSArIGhhbGZQaSkgLyB0d29QaSlcbiAgICAgICAgICA/IC1hYnNSIDogbWluKHNpbihsZWZ0QW5nbGUpICogYWJzUiwgc2luKHJpZ2h0QW5nbGUpICogYWJzUik7XG4gICAgICAgIGNvbnN0IG1heFggPSBmbG9vcigobGVmdEFuZ2xlIC0gaGFsZlBpKSAvIHR3b1BpKSAhPT0gZmxvb3IoKHJpZ2h0QW5nbGUgLSBoYWxmUGkpIC8gdHdvUGkpXG4gICAgICAgICAgPyBhYnNSIDogbWF4KHNpbihsZWZ0QW5nbGUpICogYWJzUiwgc2luKHJpZ2h0QW5nbGUpICogYWJzUik7XG4gICAgICAgIGNvbnN0IG1heFogPSBmbG9vcigobGVmdEFuZ2xlICsgUEkpIC8gdHdvUGkpICE9PSBmbG9vcigocmlnaHRBbmdsZSArIFBJKSAvIHR3b1BpKVxuICAgICAgICAgID8gYWJzUiAqIDIgOiBtYXgoYWJzUiAtIGNvcyhsZWZ0QW5nbGUpICogYWJzUiwgYWJzUiAtIGNvcyhyaWdodEFuZ2xlKSAqIGFic1IpO1xuICAgICAgICBiYm94Lm1pbi5zZXQobWluWCwgYm91bmRzWzFdLCBjdXJ2ZVJhZGl1cyA8IDAgPyAtbWF4WiA6IDApO1xuICAgICAgICBiYm94Lm1heC5zZXQobWF4WCwgYm91bmRzWzNdLCBjdXJ2ZVJhZGl1cyA8IDAgPyAwIDogbWF4Wik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYm94Lm1pbi5zZXQoYm91bmRzWzBdLCBib3VuZHNbMV0sIDApO1xuICAgICAgICBiYm94Lm1heC5zZXQoYm91bmRzWzJdLCBib3VuZHNbM10sIDApO1xuICAgICAgfVxuICAgICAgYmJveC5nZXRCb3VuZGluZ1NwaGVyZSh0aGlzLmJvdW5kaW5nU3BoZXJlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBjbGlwcGluZyByZWN0LCBhbmQgdGhlIGNodW5rZWRCb3VuZHMgZnJvbSB0aGUgbGFzdCB1cGRhdGVHbHlwaHMgY2FsbCwgY2hvb3NlIHRoZSBsb3dlc3RcbiAgICogYGluc3RhbmNlQ291bnRgIHRoYXQgd2lsbCBzaG93IGFsbCBnbHlwaHMgd2l0aGluIHRoZSBjbGlwcGVkIHZpZXcuIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uXG4gICAqIGZvciBsb25nIGJsb2NrcyBvZiB0ZXh0IHRoYXQgYXJlIGNsaXBwZWQsIHRvIHNraXAgdmVydGV4IHNoYWRlciBldmFsdWF0aW9uIGZvciBnbHlwaHMgdGhhdCB3b3VsZFxuICAgKiBiZSBjbGlwcGVkIGFueXdheS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHNpbmNlIGBkcmF3RWxlbWVudHNJbnN0YW5jZWRbQU5HTEVdYCBvbmx5IGFjY2VwdHMgYW4gaW5zdGFuY2UgY291bnQgYW5kIG5vdCBhIHN0YXJ0aW5nXG4gICAqIG9mZnNldCwgdGhpcyBvcHRpbWl6YXRpb24gYmVjb21lcyBsZXNzIGVmZmVjdGl2ZSBhcyB0aGUgY2xpcFJlY3QgbW92ZXMgY2xvc2VyIHRvIHRoZSBlbmQgb2YgdGhlXG4gICAqIHRleHQgYmxvY2suIFdlIGNvdWxkIGZpeCB0aGF0IGJ5IHN3aXRjaGluZyBmcm9tIGluc3RhbmNpbmcgdG8gYSBmdWxsIGdlb21ldHJ5IHdpdGggYSBkcmF3UmFuZ2UsXG4gICAqIGJ1dCBhdCB0aGUgZXhwZW5zZSBvZiBtdWNoIGxhcmdlciBhdHRyaWJ1dGUgYnVmZmVycyAoc2VlIGNsYXNzZG9jIGFib3ZlLilcbiAgICpcbiAgICogQHBhcmFtIHtWZWN0b3I0fSBjbGlwUmVjdFxuICAgKi9cbiAgYXBwbHlDbGlwUmVjdChjbGlwUmVjdCkge1xuICAgIGxldCBjb3VudCA9IHRoaXMuZ2V0QXR0cmlidXRlKGdseXBoSW5kZXhBdHRyTmFtZSkuY291bnQ7XG4gICAgbGV0IGNodW5rcyA9IHRoaXMuX2NodW5rZWRCb3VuZHM7XG4gICAgaWYgKGNodW5rcykge1xuICAgICAgZm9yIChsZXQgaSA9IGNodW5rcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgY291bnQgPSBjaHVua3NbaV0uZW5kO1xuICAgICAgICBsZXQgcmVjdCA9IGNodW5rc1tpXS5yZWN0O1xuICAgICAgICAvLyBub3RlOiBib3RoIHJlY3RzIGFyZSBsLWItci10XG4gICAgICAgIGlmIChyZWN0WzFdIDwgY2xpcFJlY3QudyAmJiByZWN0WzNdID4gY2xpcFJlY3QueSAmJiByZWN0WzBdIDwgY2xpcFJlY3QueiAmJiByZWN0WzJdID4gY2xpcFJlY3QueCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gY291bnQ7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiB1cGRhdGVCdWZmZXJBdHRyKGdlb20sIGF0dHJOYW1lLCBuZXdBcnJheSwgaXRlbVNpemUpIHtcbiAgY29uc3QgYXR0ciA9IGdlb20uZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgaWYgKG5ld0FycmF5KSB7XG4gICAgLy8gSWYgbGVuZ3RoIGlzbid0IGNoYW5naW5nLCBqdXN0IHVwZGF0ZSB0aGUgYXR0cmlidXRlJ3MgYXJyYXkgZGF0YVxuICAgIGlmIChhdHRyICYmIGF0dHIuYXJyYXkubGVuZ3RoID09PSBuZXdBcnJheS5sZW5ndGgpIHtcbiAgICAgIGF0dHIuYXJyYXkuc2V0KG5ld0FycmF5KTtcbiAgICAgIGF0dHIubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW9tLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZShuZXdBcnJheSwgaXRlbVNpemUpKTtcbiAgICAgIC8vIElmIHRoZSBuZXcgYXR0cmlidXRlIGhhcyBhIGRpZmZlcmVudCBzaXplLCB3ZSBhbHNvIGhhdmUgdG8gKGFzIG9mIHIxMTcpIG1hbnVhbGx5IGNsZWFyIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY2FjaGVkIG1heCBpbnN0YW5jZSBjb3VudC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzE5NzA2XG4gICAgICAvLyBJdCdzIHVuY2xlYXIgaWYgdGhpcyBpcyBhIHRocmVlanMgYnVnIG9yIGEgdHJ1bHkgdW5zdXBwb3J0ZWQgc2NlbmFyaW87IGRpc2N1c3Npb24gaW5cbiAgICAgIC8vIHRoYXQgdGlja2V0IGlzIGFtYmlndW91cyBhcyB0byB3aGV0aGVyIHJlcGxhY2luZyBhIEJ1ZmZlckF0dHJpYnV0ZSB3aXRoIG9uZSBvZiBhXG4gICAgICAvLyBkaWZmZXJlbnQgc2l6ZSBpcyBzdXBwb3J0ZWQsIGJ1dCBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMTc0MTggc3Ryb25nbHlcbiAgICAgIC8vIGltcGxpZXMgaXQgc2hvdWxkIGJlIHN1cHBvcnRlZC4gSXQncyBwb3NzaWJsZSB3ZSBuZWVkIHRvXG4gICAgICBkZWxldGUgZ2VvbS5fbWF4SW5zdGFuY2VDb3VudDsgLy9mb3IgcjExNyssIGNvdWxkIGJlIGZyYWdpbGVcbiAgICAgIGdlb20uZGlzcG9zZSgpOyAvL2ZvciByMTE4KywgbW9yZSByb2J1c3QgZmVlbGluZywgYnV0IG1vcmUgaGVhdnktaGFuZGVkIHRoYW4gSSdkIGxpa2VcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXR0cikge1xuICAgIGdlb20uZGVsZXRlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgfVxufVxuXG4vLyBsYW5ndWFnZT1HTFNMXG5jb25zdCBWRVJURVhfREVGUyA9IGBcbnVuaWZvcm0gdmVjMiB1VHJvaWthU0RGVGV4dHVyZVNpemU7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTREZHbHlwaFNpemU7XG51bmlmb3JtIHZlYzQgdVRyb2lrYVRvdGFsQm91bmRzO1xudW5pZm9ybSB2ZWM0IHVUcm9pa2FDbGlwUmVjdDtcbnVuaWZvcm0gbWF0MyB1VHJvaWthT3JpZW50O1xudW5pZm9ybSBib29sIHVUcm9pa2FVc2VHbHlwaENvbG9ycztcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYURpc3RhbmNlT2Zmc2V0O1xudW5pZm9ybSBmbG9hdCB1VHJvaWthQmx1clJhZGl1cztcbnVuaWZvcm0gdmVjMiB1VHJvaWthUG9zaXRpb25PZmZzZXQ7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FDdXJ2ZVJhZGl1cztcbmF0dHJpYnV0ZSB2ZWM0IGFUcm9pa2FHbHlwaEJvdW5kcztcbmF0dHJpYnV0ZSBmbG9hdCBhVHJvaWthR2x5cGhJbmRleDtcbmF0dHJpYnV0ZSB2ZWMzIGFUcm9pa2FHbHlwaENvbG9yO1xudmFyeWluZyB2ZWMyIHZUcm9pa2FHbHlwaFVWO1xudmFyeWluZyB2ZWM0IHZUcm9pa2FUZXh0dXJlVVZCb3VuZHM7XG52YXJ5aW5nIGZsb2F0IHZUcm9pa2FUZXh0dXJlQ2hhbm5lbDtcbnZhcnlpbmcgdmVjMyB2VHJvaWthR2x5cGhDb2xvcjtcbnZhcnlpbmcgdmVjMiB2VHJvaWthR2x5cGhEaW1lbnNpb25zO1xuYDtcblxuLy8gbGFuZ3VhZ2U9R0xTTCBwcmVmaXg9XCJ2b2lkIG1haW4oKSB7XCIgc3VmZml4PVwifVwiXG5jb25zdCBWRVJURVhfVFJBTlNGT1JNID0gYFxudmVjNCBib3VuZHMgPSBhVHJvaWthR2x5cGhCb3VuZHM7XG5ib3VuZHMueHogKz0gdVRyb2lrYVBvc2l0aW9uT2Zmc2V0Lng7XG5ib3VuZHMueXcgLT0gdVRyb2lrYVBvc2l0aW9uT2Zmc2V0Lnk7XG5cbnZlYzQgb3V0bGluZUJvdW5kcyA9IHZlYzQoXG4gIGJvdW5kcy54eSAtIHVUcm9pa2FEaXN0YW5jZU9mZnNldCAtIHVUcm9pa2FCbHVyUmFkaXVzLFxuICBib3VuZHMuencgKyB1VHJvaWthRGlzdGFuY2VPZmZzZXQgKyB1VHJvaWthQmx1clJhZGl1c1xuKTtcbnZlYzQgY2xpcHBlZEJvdW5kcyA9IHZlYzQoXG4gIGNsYW1wKG91dGxpbmVCb3VuZHMueHksIHVUcm9pa2FDbGlwUmVjdC54eSwgdVRyb2lrYUNsaXBSZWN0Lnp3KSxcbiAgY2xhbXAob3V0bGluZUJvdW5kcy56dywgdVRyb2lrYUNsaXBSZWN0Lnh5LCB1VHJvaWthQ2xpcFJlY3QuencpXG4pO1xuXG52ZWMyIGNsaXBwZWRYWSA9IChtaXgoY2xpcHBlZEJvdW5kcy54eSwgY2xpcHBlZEJvdW5kcy56dywgcG9zaXRpb24ueHkpIC0gYm91bmRzLnh5KSAvIChib3VuZHMuencgLSBib3VuZHMueHkpO1xuXG5wb3NpdGlvbi54eSA9IG1peChib3VuZHMueHksIGJvdW5kcy56dywgY2xpcHBlZFhZKTtcblxudXYgPSAocG9zaXRpb24ueHkgLSB1VHJvaWthVG90YWxCb3VuZHMueHkpIC8gKHVUcm9pa2FUb3RhbEJvdW5kcy56dyAtIHVUcm9pa2FUb3RhbEJvdW5kcy54eSk7XG5cbmZsb2F0IHJhZCA9IHVUcm9pa2FDdXJ2ZVJhZGl1cztcbmlmIChyYWQgIT0gMC4wKSB7XG4gIGZsb2F0IGFuZ2xlID0gcG9zaXRpb24ueCAvIHJhZDtcbiAgcG9zaXRpb24ueHogPSB2ZWMyKHNpbihhbmdsZSkgKiByYWQsIHJhZCAtIGNvcyhhbmdsZSkgKiByYWQpO1xuICBub3JtYWwueHogPSB2ZWMyKHNpbihhbmdsZSksIGNvcyhhbmdsZSkpO1xufVxuICBcbnBvc2l0aW9uID0gdVRyb2lrYU9yaWVudCAqIHBvc2l0aW9uO1xubm9ybWFsID0gdVRyb2lrYU9yaWVudCAqIG5vcm1hbDtcblxudlRyb2lrYUdseXBoVVYgPSBjbGlwcGVkWFkueHk7XG52VHJvaWthR2x5cGhEaW1lbnNpb25zID0gdmVjMihib3VuZHNbMl0gLSBib3VuZHNbMF0sIGJvdW5kc1szXSAtIGJvdW5kc1sxXSk7XG5cbiR7JycvKiBOT1RFOiBpdCBzZWVtcyBpbXBvcnRhbnQgdG8gY2FsY3VsYXRlIHRoZSBnbHlwaCdzIGJvdW5kaW5nIHRleHR1cmUgVVZzIGhlcmUgaW4gdGhlXG4gIHZlcnRleCBzaGFkZXIsIHJhdGhlciB0aGFuIGluIHRoZSBmcmFnbWVudCBzaGFkZXIsIGFzIHRoZSBsYXR0ZXIgZ2l2ZXMgc3RyYW5nZSBhcnRpZmFjdHNcbiAgb24gc29tZSBnbHlwaHMgKHRob3NlIGluIHRoZSBsZWZ0bW9zdCB0ZXh0dXJlIGNvbHVtbikgb24gc29tZSBzeXN0ZW1zLiBUaGUgZXhhY3QgcmVhc29uXG4gIGlzbid0IHVuZGVyc3Rvb2QgYnV0IGRvaW5nIHRoaXMgaGVyZSwgdGhlbiBtaXgoKS1pbmcgaW4gdGhlIGZyYWdtZW50IHNoYWRlciwgc2VlbXMgdG8gd29yay4gKi99XG5mbG9hdCB0eENvbHMgPSB1VHJvaWthU0RGVGV4dHVyZVNpemUueCAvIHVUcm9pa2FTREZHbHlwaFNpemU7XG52ZWMyIHR4VXZQZXJTcXVhcmUgPSB1VHJvaWthU0RGR2x5cGhTaXplIC8gdVRyb2lrYVNERlRleHR1cmVTaXplO1xudmVjMiB0eFN0YXJ0VVYgPSB0eFV2UGVyU3F1YXJlICogdmVjMihcbiAgbW9kKGZsb29yKGFUcm9pa2FHbHlwaEluZGV4IC8gNC4wKSwgdHhDb2xzKSxcbiAgZmxvb3IoZmxvb3IoYVRyb2lrYUdseXBoSW5kZXggLyA0LjApIC8gdHhDb2xzKVxuKTtcbnZUcm9pa2FUZXh0dXJlVVZCb3VuZHMgPSB2ZWM0KHR4U3RhcnRVViwgdmVjMih0eFN0YXJ0VVYpICsgdHhVdlBlclNxdWFyZSk7XG52VHJvaWthVGV4dHVyZUNoYW5uZWwgPSBtb2QoYVRyb2lrYUdseXBoSW5kZXgsIDQuMCk7XG5gO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG5jb25zdCBGUkFHTUVOVF9ERUZTID0gYFxudW5pZm9ybSBzYW1wbGVyMkQgdVRyb2lrYVNERlRleHR1cmU7XG51bmlmb3JtIHZlYzIgdVRyb2lrYVNERlRleHR1cmVTaXplO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU0RGR2x5cGhTaXplO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU0RGRXhwb25lbnQ7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FEaXN0YW5jZU9mZnNldDtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUZpbGxPcGFjaXR5O1xudW5pZm9ybSBmbG9hdCB1VHJvaWthT3V0bGluZU9wYWNpdHk7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FCbHVyUmFkaXVzO1xudW5pZm9ybSB2ZWMzIHVUcm9pa2FTdHJva2VDb2xvcjtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYVN0cm9rZVdpZHRoO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU3Ryb2tlT3BhY2l0eTtcbnVuaWZvcm0gYm9vbCB1VHJvaWthU0RGRGVidWc7XG52YXJ5aW5nIHZlYzIgdlRyb2lrYUdseXBoVVY7XG52YXJ5aW5nIHZlYzQgdlRyb2lrYVRleHR1cmVVVkJvdW5kcztcbnZhcnlpbmcgZmxvYXQgdlRyb2lrYVRleHR1cmVDaGFubmVsO1xudmFyeWluZyB2ZWMyIHZUcm9pa2FHbHlwaERpbWVuc2lvbnM7XG5cbmZsb2F0IHRyb2lrYVNkZlZhbHVlVG9TaWduZWREaXN0YW5jZShmbG9hdCBhbHBoYSkge1xuICAvLyBJbnZlcnNlIG9mIGV4cG9uZW50aWFsIGVuY29kaW5nIGluIHdlYmdsLXNkZi1nZW5lcmF0b3JcbiAgJHsnJy8qIFRPRE8gLSB0aGVyZSdzIHNvbWUgc2xpZ2h0IGluYWNjdXJhY3kgaGVyZSB3aGVuIGRlYWxpbmcgd2l0aCBpbnRlcnBvbGF0ZWQgYWxwaGEgdmFsdWVzOyB0aG9zZVxuICAgIGFyZSBsaW5lYXJseSBpbnRlcnBvbGF0ZWQgd2hlcmUgdGhlIGVuY29kaW5nIGlzIGV4cG9uZW50aWFsLiBMb29rIGludG8gaW1wcm92aW5nIHRoaXMgYnkgcm91bmRpbmdcbiAgICB0byBuZWFyZXN0IDIgd2hvbGUgdGV4ZWxzLCBkZWNvZGluZyB0aG9zZSBleHBvbmVudGlhbCB2YWx1ZXMsIGFuZCBsaW5lYXJseSBpbnRlcnBvbGF0aW5nIHRoZSByZXN1bHQuXG4gICovfVxuICBmbG9hdCBtYXhEaW1lbnNpb24gPSBtYXgodlRyb2lrYUdseXBoRGltZW5zaW9ucy54LCB2VHJvaWthR2x5cGhEaW1lbnNpb25zLnkpO1xuICBmbG9hdCBhYnNEaXN0ID0gKDEuMCAtIHBvdygyLjAgKiAoYWxwaGEgPiAwLjUgPyAxLjAgLSBhbHBoYSA6IGFscGhhKSwgMS4wIC8gdVRyb2lrYVNERkV4cG9uZW50KSkgKiBtYXhEaW1lbnNpb247XG4gIGZsb2F0IHNpZ25lZERpc3QgPSBhYnNEaXN0ICogKGFscGhhID4gMC41ID8gLTEuMCA6IDEuMCk7XG4gIHJldHVybiBzaWduZWREaXN0O1xufVxuXG5mbG9hdCB0cm9pa2FHbHlwaFV2VG9TZGZWYWx1ZSh2ZWMyIGdseXBoVVYpIHtcbiAgdmVjMiB0ZXh0dXJlVVYgPSBtaXgodlRyb2lrYVRleHR1cmVVVkJvdW5kcy54eSwgdlRyb2lrYVRleHR1cmVVVkJvdW5kcy56dywgZ2x5cGhVVik7XG4gIHZlYzQgcmdiYSA9IHRleHR1cmUyRCh1VHJvaWthU0RGVGV4dHVyZSwgdGV4dHVyZVVWKTtcbiAgZmxvYXQgY2ggPSBmbG9vcih2VHJvaWthVGV4dHVyZUNoYW5uZWwgKyAwLjUpOyAvL05PVEU6IGNhbid0IHVzZSByb3VuZCgpIGluIFdlYkdMMVxuICByZXR1cm4gY2ggPT0gMC4wID8gcmdiYS5yIDogY2ggPT0gMS4wID8gcmdiYS5nIDogY2ggPT0gMi4wID8gcmdiYS5iIDogcmdiYS5hO1xufVxuXG5mbG9hdCB0cm9pa2FHbHlwaFV2VG9EaXN0YW5jZSh2ZWMyIHV2KSB7XG4gIHJldHVybiB0cm9pa2FTZGZWYWx1ZVRvU2lnbmVkRGlzdGFuY2UodHJvaWthR2x5cGhVdlRvU2RmVmFsdWUodXYpKTtcbn1cblxuZmxvYXQgdHJvaWthR2V0QUFEaXN0KCkge1xuICAkeycnLypcbiAgICBXaGVuIHRoZSBzdGFuZGFyZCBkZXJpdmF0aXZlcyBleHRlbnNpb24gaXMgYXZhaWxhYmxlLCB3ZSBjaG9vc2UgYW4gYW50aWFsaWFzaW5nIGFscGhhIHRocmVzaG9sZCBiYXNlZFxuICAgIG9uIHRoZSBwb3RlbnRpYWwgY2hhbmdlIGluIHRoZSBTREYncyBhbHBoYSBmcm9tIHRoaXMgZnJhZ21lbnQgdG8gaXRzIG5laWdoYm9yLiBUaGlzIHN0cmF0ZWd5IG1heGltaXplcyBcbiAgICByZWFkYWJpbGl0eSBhbmQgZWRnZSBjcmlzcG5lc3MgYXQgYWxsIHNpemVzIGFuZCBzY3JlZW4gcmVzb2x1dGlvbnMuXG4gICovfVxuICAjaWYgZGVmaW5lZChHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMpIHx8IF9fVkVSU0lPTl9fID49IDMwMFxuICByZXR1cm4gbGVuZ3RoKGZ3aWR0aCh2VHJvaWthR2x5cGhVViAqIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMpKSAqIDAuNTtcbiAgI2Vsc2VcbiAgcmV0dXJuIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMueCAvIDY0LjA7XG4gICNlbmRpZlxufVxuXG5mbG9hdCB0cm9pa2FHZXRGcmFnRGlzdFZhbHVlKCkge1xuICB2ZWMyIGNsYW1wZWRHbHlwaFVWID0gY2xhbXAodlRyb2lrYUdseXBoVVYsIDAuNSAvIHVUcm9pa2FTREZHbHlwaFNpemUsIDEuMCAtIDAuNSAvIHVUcm9pa2FTREZHbHlwaFNpemUpO1xuICBmbG9hdCBkaXN0YW5jZSA9IHRyb2lrYUdseXBoVXZUb0Rpc3RhbmNlKGNsYW1wZWRHbHlwaFVWKTtcbiBcbiAgLy8gRXh0cmFwb2xhdGUgZGlzdGFuY2Ugd2hlbiBvdXRzaWRlIGJvdW5kczpcbiAgZGlzdGFuY2UgKz0gY2xhbXBlZEdseXBoVVYgPT0gdlRyb2lrYUdseXBoVVYgPyAwLjAgOiBcbiAgICBsZW5ndGgoKHZUcm9pa2FHbHlwaFVWIC0gY2xhbXBlZEdseXBoVVYpICogdlRyb2lrYUdseXBoRGltZW5zaW9ucyk7XG5cbiAgJHsnJy8qIFxuICAvLyBUT0RPIG1vcmUgcmVmaW5lZCBleHRyYXBvbGF0ZWQgZGlzdGFuY2UgYnkgYWRqdXN0aW5nIGZvciBhbmdsZSBvZiBncmFkaWVudCBhdCBlZGdlLi4uXG4gIC8vIFRoaXMgaGFzIHBvdGVudGlhbCBidXQgY3VycmVudGx5IGdpdmVzIHZlcnkgamFnZ2VkIGV4dGVuc2lvbnMsIG1heWJlIGR1ZSB0byBwcmVjaXNpb24gaXNzdWVzP1xuICBmbG9hdCB1dlN0ZXAgPSAxLjAgLyB1VHJvaWthU0RGR2x5cGhTaXplO1xuICB2ZWMyIG5laWdoYm9yMVVWID0gY2xhbXBlZEdseXBoVVYgKyAoXG4gICAgdlRyb2lrYUdseXBoVVYueCAhPSBjbGFtcGVkR2x5cGhVVi54ID8gdmVjMigwLjAsIHV2U3RlcCAqIHNpZ24oMC41IC0gdlRyb2lrYUdseXBoVVYueSkpIDpcbiAgICB2VHJvaWthR2x5cGhVVi55ICE9IGNsYW1wZWRHbHlwaFVWLnkgPyB2ZWMyKHV2U3RlcCAqIHNpZ24oMC41IC0gdlRyb2lrYUdseXBoVVYueCksIDAuMCkgOlxuICAgIHZlYzIoMC4wKVxuICApO1xuICB2ZWMyIG5laWdoYm9yMlVWID0gY2xhbXBlZEdseXBoVVYgKyAoXG4gICAgdlRyb2lrYUdseXBoVVYueCAhPSBjbGFtcGVkR2x5cGhVVi54ID8gdmVjMigwLjAsIHV2U3RlcCAqIC1zaWduKDAuNSAtIHZUcm9pa2FHbHlwaFVWLnkpKSA6XG4gICAgdlRyb2lrYUdseXBoVVYueSAhPSBjbGFtcGVkR2x5cGhVVi55ID8gdmVjMih1dlN0ZXAgKiAtc2lnbigwLjUgLSB2VHJvaWthR2x5cGhVVi54KSwgMC4wKSA6XG4gICAgdmVjMigwLjApXG4gICk7XG4gIGZsb2F0IG5laWdoYm9yMURpc3RhbmNlID0gdHJvaWthR2x5cGhVdlRvRGlzdGFuY2UobmVpZ2hib3IxVVYpO1xuICBmbG9hdCBuZWlnaGJvcjJEaXN0YW5jZSA9IHRyb2lrYUdseXBoVXZUb0Rpc3RhbmNlKG5laWdoYm9yMlVWKTtcbiAgZmxvYXQgZGlzdFRvVW5jbGFtcGVkID0gbGVuZ3RoKCh2VHJvaWthR2x5cGhVViAtIGNsYW1wZWRHbHlwaFVWKSAqIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMpO1xuICBmbG9hdCBkaXN0VG9OZWlnaGJvciA9IGxlbmd0aCgoY2xhbXBlZEdseXBoVVYgLSBuZWlnaGJvcjFVVikgKiB2VHJvaWthR2x5cGhEaW1lbnNpb25zKTtcbiAgZmxvYXQgZ3JhZGllbnRBbmdsZTEgPSBtaW4oYXNpbihhYnMobmVpZ2hib3IxRGlzdGFuY2UgLSBkaXN0YW5jZSkgLyBkaXN0VG9OZWlnaGJvciksIFBJIC8gMi4wKTtcbiAgZmxvYXQgZ3JhZGllbnRBbmdsZTIgPSBtaW4oYXNpbihhYnMobmVpZ2hib3IyRGlzdGFuY2UgLSBkaXN0YW5jZSkgLyBkaXN0VG9OZWlnaGJvciksIFBJIC8gMi4wKTtcbiAgZGlzdGFuY2UgKz0gKGNvcyhncmFkaWVudEFuZ2xlMSkgKyBjb3MoZ3JhZGllbnRBbmdsZTIpKSAvIDIuMCAqIGRpc3RUb1VuY2xhbXBlZDtcbiAgKi99XG5cbiAgcmV0dXJuIGRpc3RhbmNlO1xufVxuXG5mbG9hdCB0cm9pa2FHZXRFZGdlQWxwaGEoZmxvYXQgZGlzdGFuY2UsIGZsb2F0IGRpc3RhbmNlT2Zmc2V0LCBmbG9hdCBhYURpc3QpIHtcbiAgI2lmIGRlZmluZWQoSVNfREVQVEhfTUFURVJJQUwpIHx8IGRlZmluZWQoSVNfRElTVEFOQ0VfTUFURVJJQUwpXG4gIGZsb2F0IGFscGhhID0gc3RlcCgtZGlzdGFuY2VPZmZzZXQsIC1kaXN0YW5jZSk7XG4gICNlbHNlXG5cbiAgZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKFxuICAgIGRpc3RhbmNlT2Zmc2V0ICsgYWFEaXN0LFxuICAgIGRpc3RhbmNlT2Zmc2V0IC0gYWFEaXN0LFxuICAgIGRpc3RhbmNlXG4gICk7XG4gICNlbmRpZlxuXG4gIHJldHVybiBhbHBoYTtcbn1cbmA7XG5cbi8vIGxhbmd1YWdlPUdMU0wgcHJlZml4PVwidm9pZCBtYWluKCkge1wiIHN1ZmZpeD1cIn1cIlxuY29uc3QgRlJBR01FTlRfVFJBTlNGT1JNID0gYFxuZmxvYXQgYWFEaXN0ID0gdHJvaWthR2V0QUFEaXN0KCk7XG5mbG9hdCBmcmFnRGlzdGFuY2UgPSB0cm9pa2FHZXRGcmFnRGlzdFZhbHVlKCk7XG5mbG9hdCBlZGdlQWxwaGEgPSB1VHJvaWthU0RGRGVidWcgP1xuICB0cm9pa2FHbHlwaFV2VG9TZGZWYWx1ZSh2VHJvaWthR2x5cGhVVikgOlxuICB0cm9pa2FHZXRFZGdlQWxwaGEoZnJhZ0Rpc3RhbmNlLCB1VHJvaWthRGlzdGFuY2VPZmZzZXQsIG1heChhYURpc3QsIHVUcm9pa2FCbHVyUmFkaXVzKSk7XG5cbiNpZiAhZGVmaW5lZChJU19ERVBUSF9NQVRFUklBTCkgJiYgIWRlZmluZWQoSVNfRElTVEFOQ0VfTUFURVJJQUwpXG52ZWM0IGZpbGxSR0JBID0gZ2xfRnJhZ0NvbG9yO1xuZmlsbFJHQkEuYSAqPSB1VHJvaWthRmlsbE9wYWNpdHk7XG52ZWM0IHN0cm9rZVJHQkEgPSB1VHJvaWthU3Ryb2tlV2lkdGggPT0gMC4wID8gZmlsbFJHQkEgOiB2ZWM0KHVUcm9pa2FTdHJva2VDb2xvciwgdVRyb2lrYVN0cm9rZU9wYWNpdHkpO1xuaWYgKGZpbGxSR0JBLmEgPT0gMC4wKSBmaWxsUkdCQS5yZ2IgPSBzdHJva2VSR0JBLnJnYjtcbmdsX0ZyYWdDb2xvciA9IG1peChmaWxsUkdCQSwgc3Ryb2tlUkdCQSwgc21vb3Roc3RlcChcbiAgLXVUcm9pa2FTdHJva2VXaWR0aCAtIGFhRGlzdCxcbiAgLXVUcm9pa2FTdHJva2VXaWR0aCArIGFhRGlzdCxcbiAgZnJhZ0Rpc3RhbmNlXG4pKTtcbmdsX0ZyYWdDb2xvci5hICo9IGVkZ2VBbHBoYTtcbiNlbmRpZlxuXG5pZiAoZWRnZUFscGhhID09IDAuMCkge1xuICBkaXNjYXJkO1xufVxuYDtcblxuXG4vKipcbiAqIENyZWF0ZSBhIG1hdGVyaWFsIGZvciByZW5kZXJpbmcgdGV4dCwgZGVyaXZlZCBmcm9tIGEgYmFzZU1hdGVyaWFsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRleHREZXJpdmVkTWF0ZXJpYWwoYmFzZU1hdGVyaWFsKSB7XG4gIGNvbnN0IHRleHRNYXRlcmlhbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwsIHtcbiAgICBjaGFpbmVkOiB0cnVlLFxuICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgIGRlcml2YXRpdmVzOiB0cnVlXG4gICAgfSxcbiAgICB1bmlmb3Jtczoge1xuICAgICAgdVRyb2lrYVNERlRleHR1cmU6IHt2YWx1ZTogbnVsbH0sXG4gICAgICB1VHJvaWthU0RGVGV4dHVyZVNpemU6IHt2YWx1ZTogbmV3IFZlY3RvcjIoKX0sXG4gICAgICB1VHJvaWthU0RGR2x5cGhTaXplOiB7dmFsdWU6IDB9LFxuICAgICAgdVRyb2lrYVNERkV4cG9uZW50OiB7dmFsdWU6IDB9LFxuICAgICAgdVRyb2lrYVRvdGFsQm91bmRzOiB7dmFsdWU6IG5ldyBWZWN0b3I0KDAsMCwwLDApfSxcbiAgICAgIHVUcm9pa2FDbGlwUmVjdDoge3ZhbHVlOiBuZXcgVmVjdG9yNCgwLDAsMCwwKX0sXG4gICAgICB1VHJvaWthRGlzdGFuY2VPZmZzZXQ6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthT3V0bGluZU9wYWNpdHk6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthRmlsbE9wYWNpdHk6IHt2YWx1ZTogMX0sXG4gICAgICB1VHJvaWthUG9zaXRpb25PZmZzZXQ6IHt2YWx1ZTogbmV3IFZlY3RvcjIoKX0sXG4gICAgICB1VHJvaWthQ3VydmVSYWRpdXM6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthQmx1clJhZGl1czoge3ZhbHVlOiAwfSxcbiAgICAgIHVUcm9pa2FTdHJva2VXaWR0aDoge3ZhbHVlOiAwfSxcbiAgICAgIHVUcm9pa2FTdHJva2VDb2xvcjoge3ZhbHVlOiBuZXcgQ29sb3IoKX0sXG4gICAgICB1VHJvaWthU3Ryb2tlT3BhY2l0eToge3ZhbHVlOiAxfSxcbiAgICAgIHVUcm9pa2FPcmllbnQ6IHt2YWx1ZTogbmV3IE1hdHJpeDMoKX0sXG4gICAgICB1VHJvaWthVXNlR2x5cGhDb2xvcnM6IHt2YWx1ZTogdHJ1ZX0sXG4gICAgICB1VHJvaWthU0RGRGVidWc6IHt2YWx1ZTogZmFsc2V9XG4gICAgfSxcbiAgICB2ZXJ0ZXhEZWZzOiBWRVJURVhfREVGUyxcbiAgICB2ZXJ0ZXhUcmFuc2Zvcm06IFZFUlRFWF9UUkFOU0ZPUk0sXG4gICAgZnJhZ21lbnREZWZzOiBGUkFHTUVOVF9ERUZTLFxuICAgIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm06IEZSQUdNRU5UX1RSQU5TRk9STSxcbiAgICBjdXN0b21SZXdyaXRlcih7dmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcn0pIHtcbiAgICAgIGxldCB1RGlmZnVzZVJFID0gL1xcYnVuaWZvcm1cXHMrdmVjM1xccytkaWZmdXNlXFxiLztcbiAgICAgIGlmICh1RGlmZnVzZVJFLnRlc3QoZnJhZ21lbnRTaGFkZXIpKSB7XG4gICAgICAgIC8vIFJlcGxhY2UgYWxsIGluc3RhbmNlcyBvZiBgZGlmZnVzZWAgd2l0aCBvdXIgdmFyeWluZ1xuICAgICAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyXG4gICAgICAgICAgLnJlcGxhY2UodURpZmZ1c2VSRSwgJ3ZhcnlpbmcgdmVjMyB2VHJvaWthR2x5cGhDb2xvcicpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcYmRpZmZ1c2VcXGIvZywgJ3ZUcm9pa2FHbHlwaENvbG9yJyk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmVydGV4IHNoYWRlciBkZWNsYXJlcyB0aGUgdW5pZm9ybSBzbyB3ZSBjYW4gZ3JhYiBpdCBhcyBhIGZhbGxiYWNrXG4gICAgICAgIGlmICghdURpZmZ1c2VSRS50ZXN0KHZlcnRleFNoYWRlcikpIHtcbiAgICAgICAgICB2ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXIucmVwbGFjZShcbiAgICAgICAgICAgIHZvaWRNYWluUmVnRXhwLFxuICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbiQmXFxudlRyb2lrYUdseXBoQ29sb3IgPSB1VHJvaWthVXNlR2x5cGhDb2xvcnMgPyBhVHJvaWthR2x5cGhDb2xvciAvIDI1NS4wIDogZGlmZnVzZTtcXG4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlciB9XG4gICAgfVxuICB9KTtcblxuICAvLyBGb3JjZSB0cmFuc3BhcmVuY3kgLSBUT0RPIGlzIHRoaXMgcmVhc29uYWJsZT9cbiAgdGV4dE1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0ZXh0TWF0ZXJpYWwsIHtcbiAgICBpc1Ryb2lrYVRleHRNYXRlcmlhbDoge3ZhbHVlOiB0cnVlfSxcblxuICAgIC8vIFdlYkdMU2hhZG93TWFwIHJldmVyc2VzIHRoZSBzaWRlIG9mIHRoZSBzaGFkb3cgbWF0ZXJpYWwgYnkgZGVmYXVsdCwgd2hpY2ggZmFpbHNcbiAgICAvLyBmb3IgcGxhbmVzLCBzbyBoZXJlIHdlIGZvcmNlIHRoZSBgc2hhZG93U2lkZWAgdG8gYWx3YXlzIG1hdGNoIHRoZSBtYWluIHNpZGUuXG4gICAgc2hhZG93U2lkZToge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWRlXG4gICAgICB9LFxuICAgICAgc2V0KCkge1xuICAgICAgICAvL25vLW9wXG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGV4dE1hdGVyaWFsXG59XG5cbmNvbnN0IGRlZmF1bHRNYXRlcmlhbCA9IC8qI19fUFVSRV9fKi8gbmV3IE1lc2hCYXNpY01hdGVyaWFsKHtcbiAgY29sb3I6IDB4ZmZmZmZmLFxuICBzaWRlOiBEb3VibGVTaWRlLFxuICB0cmFuc3BhcmVudDogdHJ1ZVxufSk7XG5jb25zdCBkZWZhdWx0U3Ryb2tlQ29sb3IgPSAweDgwODA4MDtcblxuY29uc3QgdGVtcE1hdDQgPSAvKiNfX1BVUkVfXyovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCB0ZW1wVmVjM2EgPSAvKiNfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCB0ZW1wVmVjM2IgPSAvKiNfX1BVUkVfXyovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCB0ZW1wQXJyYXkgPSBbXTtcbmNvbnN0IG9yaWdpbiA9IC8qI19fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IGRlZmF1bHRPcmllbnQgPSAnK3greSc7XG5cbmZ1bmN0aW9uIGZpcnN0KG8pIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobykgPyBvWzBdIDogb1xufVxuXG5sZXQgZ2V0RmxhdFJheWNhc3RNZXNoID0gKCkgPT4ge1xuICBjb25zdCBtZXNoID0gbmV3IE1lc2goXG4gICAgbmV3IFBsYW5lR2VvbWV0cnkoMSwgMSksXG4gICAgZGVmYXVsdE1hdGVyaWFsXG4gICk7XG4gIGdldEZsYXRSYXljYXN0TWVzaCA9ICgpID0+IG1lc2g7XG4gIHJldHVybiBtZXNoXG59O1xubGV0IGdldEN1cnZlZFJheWNhc3RNZXNoID0gKCkgPT4ge1xuICBjb25zdCBtZXNoID0gbmV3IE1lc2goXG4gICAgbmV3IFBsYW5lR2VvbWV0cnkoMSwgMSwgMzIsIDEpLFxuICAgIGRlZmF1bHRNYXRlcmlhbFxuICApO1xuICBnZXRDdXJ2ZWRSYXljYXN0TWVzaCA9ICgpID0+IG1lc2g7XG4gIHJldHVybiBtZXNoXG59O1xuXG5jb25zdCBzeW5jU3RhcnRFdmVudCA9IHsgdHlwZTogJ3N5bmNzdGFydCcgfTtcbmNvbnN0IHN5bmNDb21wbGV0ZUV2ZW50ID0geyB0eXBlOiAnc3luY2NvbXBsZXRlJyB9O1xuXG5jb25zdCBTWU5DQUJMRV9QUk9QUyA9IFtcbiAgJ2ZvbnQnLFxuICAnZm9udFNpemUnLFxuICAnZm9udFN0eWxlJyxcbiAgJ2ZvbnRXZWlnaHQnLFxuICAnbGFuZycsXG4gICdsZXR0ZXJTcGFjaW5nJyxcbiAgJ2xpbmVIZWlnaHQnLFxuICAnbWF4V2lkdGgnLFxuICAnb3ZlcmZsb3dXcmFwJyxcbiAgJ3RleHQnLFxuICAnZGlyZWN0aW9uJyxcbiAgJ3RleHRBbGlnbicsXG4gICd0ZXh0SW5kZW50JyxcbiAgJ3doaXRlU3BhY2UnLFxuICAnYW5jaG9yWCcsXG4gICdhbmNob3JZJyxcbiAgJ2NvbG9yUmFuZ2VzJyxcbiAgJ3NkZkdseXBoU2l6ZSdcbl07XG5cbmNvbnN0IENPUFlBQkxFX1BST1BTID0gU1lOQ0FCTEVfUFJPUFMuY29uY2F0KFxuICAnbWF0ZXJpYWwnLFxuICAnY29sb3InLFxuICAnZGVwdGhPZmZzZXQnLFxuICAnY2xpcFJlY3QnLFxuICAnY3VydmVSYWRpdXMnLFxuICAnb3JpZW50YXRpb24nLFxuICAnZ2x5cGhHZW9tZXRyeURldGFpbCdcbik7XG5cbi8qKlxuICogQGNsYXNzIFRleHRcbiAqXG4gKiBBIFRocmVlSlMgTWVzaCB0aGF0IHJlbmRlcnMgYSBzdHJpbmcgb2YgdGV4dCBvbiBhIHBsYW5lIGluIDNEIHNwYWNlIHVzaW5nIHNpZ25lZCBkaXN0YW5jZVxuICogZmllbGRzIChTREYpLlxuICovXG5jbGFzcyBUZXh0IGV4dGVuZHMgTWVzaCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEdseXBoc0dlb21ldHJ5KCk7XG4gICAgc3VwZXIoZ2VvbWV0cnksIG51bGwpO1xuXG4gICAgLy8gPT09IFRleHQgbGF5b3V0IHByb3BlcnRpZXM6ID09PSAvL1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZXh0XG4gICAgICogVGhlIHN0cmluZyBvZiB0ZXh0IHRvIGJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHRoaXMudGV4dCA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gYW5jaG9yWFxuICAgICAqIERlZmluZXMgdGhlIGhvcml6b250YWwgcG9zaXRpb24gaW4gdGhlIHRleHQgYmxvY2sgdGhhdCBzaG91bGQgbGluZSB1cCB3aXRoIHRoZSBsb2NhbCBvcmlnaW4uXG4gICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBhIG51bWVyaWMgeCBwb3NpdGlvbiBpbiBsb2NhbCB1bml0cywgYSBzdHJpbmcgcGVyY2VudGFnZSBvZiB0aGUgdG90YWxcbiAgICAgKiB0ZXh0IGJsb2NrIHdpZHRoIGUuZy4gYCcyNSUnYCwgb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcga2V5d29yZCBzdHJpbmdzOiAnbGVmdCcsICdjZW50ZXInLFxuICAgICAqIG9yICdyaWdodCcuXG4gICAgICovXG4gICAgdGhpcy5hbmNob3JYID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IGFuY2hvcllcbiAgICAgKiBEZWZpbmVzIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiBpbiB0aGUgdGV4dCBibG9jayB0aGF0IHNob3VsZCBsaW5lIHVwIHdpdGggdGhlIGxvY2FsIG9yaWdpbi5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGEgbnVtZXJpYyB5IHBvc2l0aW9uIGluIGxvY2FsIHVuaXRzIChub3RlOiBkb3duIGlzIG5lZ2F0aXZlIHkpLCBhIHN0cmluZ1xuICAgICAqIHBlcmNlbnRhZ2Ugb2YgdGhlIHRvdGFsIHRleHQgYmxvY2sgaGVpZ2h0IGUuZy4gYCcyNSUnYCwgb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcga2V5d29yZCBzdHJpbmdzOlxuICAgICAqICd0b3AnLCAndG9wLWJhc2VsaW5lJywgJ3RvcC1jYXAnLCAndG9wLWV4JywgJ21pZGRsZScsICdib3R0b20tYmFzZWxpbmUnLCBvciAnYm90dG9tJy5cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvclkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBjdXJ2ZVJhZGl1c1xuICAgICAqIERlZmluZXMgYSBjeWxpbmRyaWNhbCByYWRpdXMgYWxvbmcgd2hpY2ggdGhlIHRleHQncyBwbGFuZSB3aWxsIGJlIGN1cnZlZC4gUG9zaXRpdmUgbnVtYmVycyBwdXRcbiAgICAgKiB0aGUgY3lsaW5kZXIncyBjZW50ZXJsaW5lIChvcmllbnRlZCB2ZXJ0aWNhbGx5KSB0aGF0IGRpc3RhbmNlIGluIGZyb250IG9mIHRoZSB0ZXh0LCBmb3IgYSBjb25jYXZlXG4gICAgICogY3VydmF0dXJlLCB3aGlsZSBuZWdhdGl2ZSBudW1iZXJzIHB1dCBpdCBiZWhpbmQgdGhlIHRleHQgZm9yIGEgY29udmV4IGN1cnZhdHVyZS4gVGhlIGNlbnRlcmxpbmVcbiAgICAgKiB3aWxsIGJlIGFsaWduZWQgd2l0aCB0aGUgdGV4dCdzIGxvY2FsIG9yaWdpbjsgeW91IGNhbiB1c2UgYGFuY2hvclhgIHRvIG9mZnNldCBpdC5cbiAgICAgKlxuICAgICAqIFNpbmNlIGVhY2ggZ2x5cGggaXMgYnkgZGVmYXVsdCByZW5kZXJlZCB3aXRoIGEgc2ltcGxlIHF1YWQsIGVhY2ggZ2x5cGggcmVtYWlucyBhIGZsYXQgcGxhbmVcbiAgICAgKiBpbnRlcm5hbGx5LiBZb3UgY2FuIHVzZSBgZ2x5cGhHZW9tZXRyeURldGFpbGAgdG8gYWRkIG1vcmUgdmVydGljZXMgZm9yIGN1cnZhdHVyZSBpbnNpZGUgZ2x5cGhzLlxuICAgICAqL1xuICAgIHRoaXMuY3VydmVSYWRpdXMgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBkaXJlY3Rpb25cbiAgICAgKiBTZXRzIHRoZSBiYXNlIGRpcmVjdGlvbiBmb3IgdGhlIHRleHQuIFRoZSBkZWZhdWx0IHZhbHVlIG9mIFwiYXV0b1wiIHdpbGwgY2hvb3NlIGEgZGlyZWN0aW9uIGJhc2VkXG4gICAgICogb24gdGhlIHRleHQncyBjb250ZW50IGFjY29yZGluZyB0byB0aGUgYmlkaSBzcGVjLiBBIHZhbHVlIG9mIFwibHRyXCIgb3IgXCJydGxcIiB3aWxsIGZvcmNlIHRoZSBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgdGhpcy5kaXJlY3Rpb24gPSAnYXV0byc7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVsbH0gZm9udFxuICAgICAqIFVSTCBvZiBhIGN1c3RvbSBmb250IHRvIGJlIHVzZWQuIEZvbnQgZmlsZXMgY2FuIGJlIGluIC50dGYsIC5vdGYsIG9yIC53b2ZmIChub3QgLndvZmYyKSBmb3JtYXRzLlxuICAgICAqIERlZmF1bHRzIHRvIE5vdG8gU2Fucy5cbiAgICAgKi9cbiAgICB0aGlzLmZvbnQgPSBudWxsOyAvL3dpbGwgdXNlIGRlZmF1bHQgZnJvbSBUZXh0QnVpbGRlclxuXG4gICAgdGhpcy51bmljb2RlRm9udHNVUkwgPSBudWxsOyAvL2RlZmF1bHRzIHRvIENETlxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBmb250U2l6ZVxuICAgICAqIFRoZSBzaXplIGF0IHdoaWNoIHRvIHJlbmRlciB0aGUgZm9udCBpbiBsb2NhbCB1bml0czsgY29ycmVzcG9uZHMgdG8gdGhlIGVtLWJveCBoZWlnaHRcbiAgICAgKiBvZiB0aGUgY2hvc2VuIGBmb250YC5cbiAgICAgKi9cbiAgICB0aGlzLmZvbnRTaXplID0gMC4xO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfCdub3JtYWwnfCdib2xkJ31cbiAgICAgKiBUaGUgd2VpZ2h0IG9mIHRoZSBmb250LiBDdXJyZW50bHkgb25seSB1c2VkIGZvciBmYWxsYmFjayBOb3RvIGZvbnRzLlxuICAgICAqL1xuICAgIHRoaXMuZm9udFdlaWdodCA9ICdub3JtYWwnO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7J25vcm1hbCd8J2l0YWxpYyd9XG4gICAgICogVGhlIHN0eWxlIG9mIHRoZSBmb250LiBDdXJyZW50bHkgb25seSB1c2VkIGZvciBmYWxsYmFjayBOb3RvIGZvbnRzLlxuICAgICAqL1xuICAgIHRoaXMuZm9udFN0eWxlID0gJ25vcm1hbCc7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVsbH0gbGFuZ1xuICAgICAqIFRoZSBsYW5ndWFnZSBjb2RlIG9mIHRoaXMgdGV4dDsgY2FuIGJlIHVzZWQgZm9yIGV4cGxpY2l0bHkgc2VsZWN0aW5nIGNlcnRhaW4gQ0pLIGZvbnRzLlxuICAgICAqL1xuICAgIHRoaXMubGFuZyA9IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gbGV0dGVyU3BhY2luZ1xuICAgICAqIFNldHMgYSB1bmlmb3JtIGFkanVzdG1lbnQgdG8gc3BhY2luZyBiZXR3ZWVuIGxldHRlcnMgYWZ0ZXIga2VybmluZyBpcyBhcHBsaWVkLiBQb3NpdGl2ZVxuICAgICAqIG51bWJlcnMgaW5jcmVhc2Ugc3BhY2luZyBhbmQgbmVnYXRpdmUgbnVtYmVycyBkZWNyZWFzZSBpdC5cbiAgICAgKi9cbiAgICB0aGlzLmxldHRlclNwYWNpbmcgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gbGluZUhlaWdodFxuICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiBlYWNoIGxpbmUgb2YgdGV4dCwgYXMgYSBtdWx0aXBsZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gJ25vcm1hbCdcbiAgICAgKiB3aGljaCBjaG9vc2VzIGEgcmVhc29uYWJsZSBoZWlnaHQgYmFzZWQgb24gdGhlIGNob3NlbiBmb250J3MgYXNjZW5kZXIvZGVzY2VuZGVyIG1ldHJpY3MuXG4gICAgICovXG4gICAgdGhpcy5saW5lSGVpZ2h0ID0gJ25vcm1hbCc7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IG1heFdpZHRoXG4gICAgICogVGhlIG1heGltdW0gd2lkdGggb2YgdGhlIHRleHQgYmxvY2ssIGFib3ZlIHdoaWNoIHRleHQgbWF5IHN0YXJ0IHdyYXBwaW5nIGFjY29yZGluZyB0byB0aGVcbiAgICAgKiBgd2hpdGVTcGFjZWAgYW5kIGBvdmVyZmxvd1dyYXBgIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgdGhpcy5tYXhXaWR0aCA9IEluZmluaXR5O1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBvdmVyZmxvd1dyYXBcbiAgICAgKiBEZWZpbmVzIGhvdyB0ZXh0IHdyYXBzIGlmIHRoZSBgd2hpdGVTcGFjZWAgcHJvcGVydHkgaXMgYG5vcm1hbGAuIENhbiBiZSBlaXRoZXIgYCdub3JtYWwnYFxuICAgICAqIHRvIGJyZWFrIGF0IHdoaXRlc3BhY2UgY2hhcmFjdGVycywgb3IgYCdicmVhay13b3JkJ2AgdG8gYWxsb3cgYnJlYWtpbmcgd2l0aGluIHdvcmRzLlxuICAgICAqIERlZmF1bHRzIHRvIGAnbm9ybWFsJ2AuXG4gICAgICovXG4gICAgdGhpcy5vdmVyZmxvd1dyYXAgPSAnbm9ybWFsJztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gdGV4dEFsaWduXG4gICAgICogVGhlIGhvcml6b250YWwgYWxpZ25tZW50IG9mIGVhY2ggbGluZSBvZiB0ZXh0IHdpdGhpbiB0aGUgb3ZlcmFsbCB0ZXh0IGJvdW5kaW5nIGJveC5cbiAgICAgKi9cbiAgICB0aGlzLnRleHRBbGlnbiA9ICdsZWZ0JztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gdGV4dEluZGVudFxuICAgICAqIEluZGVudGF0aW9uIGZvciB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgbGluZTsgc2VlIENTUyBgdGV4dC1pbmRlbnRgLlxuICAgICAqL1xuICAgIHRoaXMudGV4dEluZGVudCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHdoaXRlU3BhY2VcbiAgICAgKiBEZWZpbmVzIHdoZXRoZXIgdGV4dCBzaG91bGQgd3JhcCB3aGVuIGEgbGluZSByZWFjaGVzIHRoZSBgbWF4V2lkdGhgLiBDYW5cbiAgICAgKiBiZSBlaXRoZXIgYCdub3JtYWwnYCAodGhlIGRlZmF1bHQpLCB0byBhbGxvdyB3cmFwcGluZyBhY2NvcmRpbmcgdG8gdGhlIGBvdmVyZmxvd1dyYXBgIHByb3BlcnR5LFxuICAgICAqIG9yIGAnbm93cmFwJ2AgdG8gcHJldmVudCB3cmFwcGluZy4gTm90ZSB0aGF0IGAnbm9ybWFsJ2AgaGVyZSBob25vcnMgbmV3bGluZSBjaGFyYWN0ZXJzIHRvXG4gICAgICogbWFudWFsbHkgYnJlYWsgbGluZXMsIG1ha2luZyBpdCBiZWhhdmUgbW9yZSBsaWtlIGAncHJlLXdyYXAnYCBkb2VzIGluIENTUy5cbiAgICAgKi9cbiAgICB0aGlzLndoaXRlU3BhY2UgPSAnbm9ybWFsJztcblxuXG4gICAgLy8gPT09IFByZXNlbnRhdGlvbiBwcm9wZXJ0aWVzOiA9PT0gLy9cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge1RIUkVFLk1hdGVyaWFsfSBtYXRlcmlhbFxuICAgICAqIERlZmluZXMgYSBfYmFzZV8gbWF0ZXJpYWwgdG8gYmUgdXNlZCB3aGVuIHJlbmRlcmluZyB0aGUgdGV4dC4gVGhpcyBtYXRlcmlhbCB3aWxsIGJlXG4gICAgICogYXV0b21hdGljYWxseSByZXBsYWNlZCB3aXRoIGEgbWF0ZXJpYWwgZGVyaXZlZCBmcm9tIGl0LCB0aGF0IGFkZHMgc2hhZGVyIGNvZGUgdG9cbiAgICAgKiBkZWNyZWFzZSB0aGUgYWxwaGEgZm9yIGVhY2ggZnJhZ21lbnQgKHBpeGVsKSBvdXRzaWRlIHRoZSB0ZXh0IGdseXBocywgd2l0aCBhbnRpYWxpYXNpbmcuXG4gICAgICogQnkgZGVmYXVsdCBpdCB3aWxsIGRlcml2ZSBmcm9tIGEgc2ltcGxlIHdoaXRlIE1lc2hCYXNpY01hdGVyaWFsLCBidXQgeW91IGNhbiB1c2UgYW55XG4gICAgICogb2YgdGhlIG90aGVyIG1lc2ggbWF0ZXJpYWxzIHRvIGdhaW4gb3RoZXIgZmVhdHVyZXMgbGlrZSBsaWdodGluZywgdGV4dHVyZSBtYXBzLCBldGMuXG4gICAgICpcbiAgICAgKiBBbHNvIHNlZSB0aGUgYGNvbG9yYCBzaG9ydGN1dCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ3xudW1iZXJ8VEhSRUUuQ29sb3J9IGNvbG9yXG4gICAgICogVGhpcyBpcyBhIHNob3J0Y3V0IGZvciBzZXR0aW5nIHRoZSBgY29sb3JgIG9mIHRoZSB0ZXh0J3MgbWF0ZXJpYWwuIFlvdSBjYW4gdXNlIHRoaXNcbiAgICAgKiBpZiB5b3UgZG9uJ3Qgd2FudCB0byBzcGVjaWZ5IGEgd2hvbGUgY3VzdG9tIGBtYXRlcmlhbGAuIEFsc28sIGlmIHlvdSBkbyB1c2UgYSBjdXN0b21cbiAgICAgKiBgbWF0ZXJpYWxgLCB0aGlzIGNvbG9yIHdpbGwgb25seSBiZSB1c2VkIGZvciB0aGlzIHBhcnRpY3VhciBUZXh0IGluc3RhbmNlLCBldmVuIGlmXG4gICAgICogdGhhdCBzYW1lIG1hdGVyaWFsIGluc3RhbmNlIGlzIHNoYXJlZCBhY3Jvc3MgbXVsdGlwbGUgVGV4dCBvYmplY3RzLlxuICAgICAqL1xuICAgIHRoaXMuY29sb3IgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7b2JqZWN0fG51bGx9IGNvbG9yUmFuZ2VzXG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoaXMgYWxsb3dzIG1vcmUgZmluZS1ncmFpbmVkIGNvbnRyb2wgb2YgY29sb3JzIGZvciBpbmRpdmlkdWFsIG9yIHJhbmdlcyBvZiBjaGFyYWN0ZXJzLFxuICAgICAqIHRha2luZyBwcmVjZWRlbmNlIG92ZXIgdGhlIG1hdGVyaWFsJ3MgYGNvbG9yYC4gSXRzIGZvcm1hdCBpcyBhbiBPYmplY3Qgd2hvc2Uga2V5cyBlYWNoXG4gICAgICogZGVmaW5lIGEgc3RhcnRpbmcgY2hhcmFjdGVyIGluZGV4IGZvciBhIHJhbmdlLCBhbmQgd2hvc2UgdmFsdWVzIGFyZSB0aGUgY29sb3IgZm9yIGVhY2hcbiAgICAgKiByYW5nZS4gVGhlIGNvbG9yIHZhbHVlIGNhbiBiZSBhIG51bWVyaWMgaGV4IGNvbG9yIHZhbHVlLCBhIGBUSFJFRS5Db2xvcmAgb2JqZWN0LCBvclxuICAgICAqIGFueSBvZiB0aGUgc3RyaW5ncyBhY2NlcHRlZCBieSBgVEhSRUUuQ29sb3JgLlxuICAgICAqL1xuICAgIHRoaXMuY29sb3JSYW5nZXMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gb3V0bGluZVdpZHRoXG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoZSB3aWR0aCBvZiBhbiBvdXRsaW5lL2hhbG8gdG8gYmUgZHJhd24gYXJvdW5kIGVhY2ggdGV4dCBnbHlwaCB1c2luZyB0aGUgYG91dGxpbmVDb2xvcmAgYW5kIGBvdXRsaW5lT3BhY2l0eWAuXG4gICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYW4gYWJzb2x1dGUgbnVtYmVyIGluIGxvY2FsIHVuaXRzLCBvciBhcyBhIHBlcmNlbnRhZ2Ugc3RyaW5nIGUuZy5cbiAgICAgKiBgXCIxMiVcImAgd2hpY2ggaXMgdHJlYXRlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvIGAwYCwgd2hpY2ggbWVhbnNcbiAgICAgKiBubyBvdXRsaW5lIHdpbGwgYmUgZHJhd24gdW5sZXNzIGFuIGBvdXRsaW5lT2Zmc2V0WC9ZYCBvciBgb3V0bGluZUJsdXJgIGlzIHNldC5cbiAgICAgKi9cbiAgICB0aGlzLm91dGxpbmVXaWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVtYmVyfFRIUkVFLkNvbG9yfSBvdXRsaW5lQ29sb3JcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhlIGNvbG9yIG9mIHRoZSB0ZXh0IG91dGxpbmUsIGlmIGBvdXRsaW5lV2lkdGhgL2BvdXRsaW5lQmx1cmAvYG91dGxpbmVPZmZzZXRYL1lgIGFyZSBzZXQuXG4gICAgICogRGVmYXVsdHMgdG8gYmxhY2suXG4gICAgICovXG4gICAgdGhpcy5vdXRsaW5lQ29sb3IgPSAweDAwMDAwMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gb3V0bGluZU9wYWNpdHlcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIG91dGxpbmUsIGlmIGBvdXRsaW5lV2lkdGhgL2BvdXRsaW5lQmx1cmAvYG91dGxpbmVPZmZzZXRYL1lgIGFyZSBzZXQuXG4gICAgICogRGVmYXVsdHMgdG8gYDFgLlxuICAgICAqL1xuICAgIHRoaXMub3V0bGluZU9wYWNpdHkgPSAxO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gb3V0bGluZUJsdXJcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogQSBibHVyIHJhZGl1cyBhcHBsaWVkIHRvIHRoZSBvdXRlciBlZGdlIG9mIHRoZSB0ZXh0J3Mgb3V0bGluZS4gSWYgdGhlIGBvdXRsaW5lV2lkdGhgIGlzXG4gICAgICogemVybywgdGhlIGJsdXIgd2lsbCBiZSBhcHBsaWVkIGF0IHRoZSBnbHlwaCBlZGdlLCBsaWtlIENTUydzIGB0ZXh0LXNoYWRvd2AgYmx1ciByYWRpdXMuXG4gICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYW4gYWJzb2x1dGUgbnVtYmVyIGluIGxvY2FsIHVuaXRzLCBvciBhcyBhIHBlcmNlbnRhZ2Ugc3RyaW5nIGUuZy5cbiAgICAgKiBgXCIxMiVcImAgd2hpY2ggaXMgdHJlYXRlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvIGAwYC5cbiAgICAgKi9cbiAgICB0aGlzLm91dGxpbmVCbHVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IG91dGxpbmVPZmZzZXRYXG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIEEgaG9yaXpvbnRhbCBvZmZzZXQgZm9yIHRoZSB0ZXh0IG91dGxpbmUuXG4gICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYW4gYWJzb2x1dGUgbnVtYmVyIGluIGxvY2FsIHVuaXRzLCBvciBhcyBhIHBlcmNlbnRhZ2Ugc3RyaW5nIGUuZy4gYFwiMTIlXCJgXG4gICAgICogd2hpY2ggaXMgdHJlYXRlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvIGAwYC5cbiAgICAgKi9cbiAgICB0aGlzLm91dGxpbmVPZmZzZXRYID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IG91dGxpbmVPZmZzZXRZXG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIEEgdmVydGljYWwgb2Zmc2V0IGZvciB0aGUgdGV4dCBvdXRsaW5lLlxuICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgZWl0aGVyIGFuIGFic29sdXRlIG51bWJlciBpbiBsb2NhbCB1bml0cywgb3IgYXMgYSBwZXJjZW50YWdlIHN0cmluZyBlLmcuIGBcIjEyJVwiYFxuICAgICAqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICovXG4gICAgdGhpcy5vdXRsaW5lT2Zmc2V0WSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBzdHJva2VXaWR0aFxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGUgd2lkdGggb2YgYW4gaW5uZXIgc3Ryb2tlIGRyYXduIGluc2lkZSBlYWNoIHRleHQgZ2x5cGggdXNpbmcgdGhlIGBzdHJva2VDb2xvcmAgYW5kIGBzdHJva2VPcGFjaXR5YC5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLiBgXCIxMiVcImBcbiAgICAgKiB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLlxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfG51bWJlcnxUSFJFRS5Db2xvcn0gc3Ryb2tlQ29sb3JcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhlIGNvbG9yIG9mIHRoZSB0ZXh0IHN0cm9rZSwgaWYgYHN0cm9rZVdpZHRoYCBpcyBncmVhdGVyIHRoYW4gemVyby4gRGVmYXVsdHMgdG8gZ3JheS5cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZUNvbG9yID0gZGVmYXVsdFN0cm9rZUNvbG9yO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBzdHJva2VPcGFjaXR5XG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoZSBvcGFjaXR5IG9mIHRoZSBzdHJva2UsIGlmIGBzdHJva2VXaWR0aGAgaXMgZ3JlYXRlciB0aGFuIHplcm8uIERlZmF1bHRzIHRvIGAxYC5cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBmaWxsT3BhY2l0eVxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGUgb3BhY2l0eSBvZiB0aGUgZ2x5cGgncyBmaWxsIGZyb20gMCB0byAxLiBUaGlzIGJlaGF2ZXMgbGlrZSB0aGUgbWF0ZXJpYWwncyBgb3BhY2l0eWAgYnV0IGFsbG93c1xuICAgICAqIGdpdmluZyB0aGUgZmlsbCBhIGRpZmZlcmVudCBvcGFjaXR5IHRoYW4gdGhlIGBzdHJva2VPcGFjaXR5YC4gQSBmaWxsT3BhY2l0eSBvZiBgMGAgbWFrZXMgdGhlXG4gICAgICogaW50ZXJpb3Igb2YgdGhlIGdseXBoIGludmlzaWJsZSwgbGVhdmluZyBqdXN0IHRoZSBgc3Ryb2tlV2lkdGhgLiBEZWZhdWx0cyB0byBgMWAuXG4gICAgICovXG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGRlcHRoT2Zmc2V0XG4gICAgICogVGhpcyBpcyBhIHNob3J0Y3V0IGZvciBzZXR0aW5nIHRoZSBtYXRlcmlhbCdzIGBwb2x5Z29uT2Zmc2V0YCBhbmQgcmVsYXRlZCBwcm9wZXJ0aWVzLFxuICAgICAqIHdoaWNoIGNhbiBiZSB1c2VmdWwgaW4gcHJldmVudGluZyB6LWZpZ2h0aW5nIHdoZW4gdGhpcyB0ZXh0IGlzIGxhaWQgb24gdG9wIG9mIGFub3RoZXJcbiAgICAgKiBwbGFuZSBpbiB0aGUgc2NlbmUuIFBvc2l0aXZlIG51bWJlcnMgYXJlIGZ1cnRoZXIgZnJvbSB0aGUgY2FtZXJhLCBuZWdhdGl2ZXMgY2xvc2VyLlxuICAgICAqL1xuICAgIHRoaXMuZGVwdGhPZmZzZXQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7QXJyYXk8bnVtYmVyPn0gY2xpcFJlY3RcbiAgICAgKiBJZiBzcGVjaWZpZWQsIGRlZmluZXMgYSBgW21pblgsIG1pblksIG1heFgsIG1heFldYCBvZiBhIHJlY3RhbmdsZSBvdXRzaWRlIG9mIHdoaWNoIGFsbFxuICAgICAqIHBpeGVscyB3aWxsIGJlIGRpc2NhcmRlZC4gVGhpcyBjYW4gYmUgdXNlZCBmb3IgZXhhbXBsZSB0byBjbGlwIG92ZXJmbG93aW5nIHRleHQgd2hlblxuICAgICAqIGB3aGl0ZVNwYWNlPSdub3dyYXAnYC5cbiAgICAgKi9cbiAgICB0aGlzLmNsaXBSZWN0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gb3JpZW50YXRpb25cbiAgICAgKiBEZWZpbmVzIHRoZSBheGlzIHBsYW5lIG9uIHdoaWNoIHRoZSB0ZXh0IHNob3VsZCBiZSBsYWlkIG91dCB3aGVuIHRoZSBtZXNoIGhhcyBubyBleHRyYVxuICAgICAqIHJvdGF0aW9uIHRyYW5zZm9ybS4gSXQgaXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIHdpdGggdHdvIGF4ZXM6IHRoZSBob3Jpem9udGFsIGF4aXMgd2l0aFxuICAgICAqIHBvc2l0aXZlIHBvaW50aW5nIHJpZ2h0LCBhbmQgdGhlIHZlcnRpY2FsIGF4aXMgd2l0aCBwb3NpdGl2ZSBwb2ludGluZyB1cC4gQnkgZGVmYXVsdCB0aGlzXG4gICAgICogaXMgJyt4K3knLCBtZWFuaW5nIHRoZSB0ZXh0IHNpdHMgb24gdGhlIHh5IHBsYW5lIHdpdGggdGhlIHRleHQncyB0b3AgdG93YXJkIHBvc2l0aXZlIHlcbiAgICAgKiBhbmQgZmFjaW5nIHBvc2l0aXZlIHouIEEgdmFsdWUgb2YgJyt4LXonIHdvdWxkIHBsYWNlIGl0IG9uIHRoZSB4eiBwbGFuZSB3aXRoIHRoZSB0ZXh0J3NcbiAgICAgKiB0b3AgdG93YXJkIG5lZ2F0aXZlIHogYW5kIGZhY2luZyBwb3NpdGl2ZSB5LlxuICAgICAqL1xuICAgIHRoaXMub3JpZW50YXRpb24gPSBkZWZhdWx0T3JpZW50O1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBnbHlwaEdlb21ldHJ5RGV0YWlsXG4gICAgICogQ29udHJvbHMgbnVtYmVyIG9mIHZlcnRpY2FsL2hvcml6b250YWwgc2VnbWVudHMgdGhhdCBtYWtlIHVwIGVhY2ggZ2x5cGgncyByZWN0YW5ndWxhclxuICAgICAqIHBsYW5lLiBEZWZhdWx0cyB0byAxLiBUaGlzIGNhbiBiZSBpbmNyZWFzZWQgdG8gcHJvdmlkZSBtb3JlIGdlb21ldHJpY2FsIGRldGFpbCBmb3IgY3VzdG9tXG4gICAgICogdmVydGV4IHNoYWRlciBlZmZlY3RzLCBmb3IgZXhhbXBsZS5cbiAgICAgKi9cbiAgICB0aGlzLmdseXBoR2VvbWV0cnlEZXRhaWwgPSAxO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfG51bGx9IHNkZkdseXBoU2l6ZVxuICAgICAqIFRoZSBzaXplIG9mIGVhY2ggZ2x5cGgncyBTREYgKHNpZ25lZCBkaXN0YW5jZSBmaWVsZCkgdXNlZCBmb3IgcmVuZGVyaW5nLiBUaGlzIG11c3QgYmUgYVxuICAgICAqIHBvd2VyLW9mLXR3byBudW1iZXIuIERlZmF1bHRzIHRvIDY0IHdoaWNoIGlzIGdlbmVyYWxseSBhIGdvb2QgYmFsYW5jZSBvZiBzaXplIGFuZCBxdWFsaXR5XG4gICAgICogZm9yIG1vc3QgZm9udHMuIExhcmdlciBzaXplcyBjYW4gaW1wcm92ZSB0aGUgcXVhbGl0eSBvZiBnbHlwaCByZW5kZXJpbmcgYnkgaW5jcmVhc2luZ1xuICAgICAqIHRoZSBzaGFycG5lc3Mgb2YgY29ybmVycyBhbmQgcHJldmVudGluZyBsb3NzIG9mIHZlcnkgdGhpbiBsaW5lcywgYXQgdGhlIGV4cGVuc2Ugb2ZcbiAgICAgKiBpbmNyZWFzZWQgbWVtb3J5IGZvb3RwcmludCBhbmQgbG9uZ2VyIFNERiBnZW5lcmF0aW9uIHRpbWUuXG4gICAgICovXG4gICAgdGhpcy5zZGZHbHlwaFNpemUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gZ3B1QWNjZWxlcmF0ZVNERlxuICAgICAqIFdoZW4gYHRydWVgLCB0aGUgU0RGIGdlbmVyYXRpb24gcHJvY2VzcyB3aWxsIGJlIEdQVS1hY2NlbGVyYXRlZCB3aXRoIFdlYkdMIHdoZW4gcG9zc2libGUsXG4gICAgICogbWFraW5nIGl0IG11Y2ggZmFzdGVyIGVzcGVjaWFsbHkgZm9yIGNvbXBsZXggZ2x5cGhzLCBhbmQgZmFsbGluZyBiYWNrIHRvIGEgSmF2YVNjcmlwdCB2ZXJzaW9uXG4gICAgICogZXhlY3V0ZWQgaW4gd2ViIHdvcmtlcnMgd2hlbiBzdXBwb3J0IGlzbid0IGF2YWlsYWJsZS4gSXQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHN1cHBvcnQsXG4gICAgICogYnV0IGl0J3Mgc3RpbGwgc29tZXdoYXQgZXhwZXJpbWVudGFsLCBzbyB5b3UgY2FuIHNldCBpdCB0byBgZmFsc2VgIHRvIGZvcmNlIGl0IHRvIHVzZSB0aGUgSlNcbiAgICAgKiB2ZXJzaW9uIGlmIHlvdSBlbmNvdW50ZXIgaXNzdWVzIHdpdGggaXQuXG4gICAgICovXG4gICAgdGhpcy5ncHVBY2NlbGVyYXRlU0RGID0gdHJ1ZTtcblxuICAgIHRoaXMuZGVidWdTREYgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB0ZXh0IHJlbmRlcmluZyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgdGV4dC1yZWxhdGVkIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcy5cbiAgICogVGhpcyBpcyBhbiBhc3luYyBwcm9jZXNzLCBzbyB5b3UgY2FuIHBhc3MgaW4gYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCB3aGVuIGl0XG4gICAqIGZpbmlzaGVzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAqL1xuICBzeW5jKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX25lZWRzU3luYykge1xuICAgICAgdGhpcy5fbmVlZHNTeW5jID0gZmFsc2U7XG5cbiAgICAgIC8vIElmIHRoZXJlJ3MgYW5vdGhlciBzeW5jIHN0aWxsIGluIHByb2dyZXNzLCBxdWV1ZVxuICAgICAgaWYgKHRoaXMuX2lzU3luY2luZykge1xuICAgICAgICAodGhpcy5fcXVldWVkU3luY3MgfHwgKHRoaXMuX3F1ZXVlZFN5bmNzID0gW10pKS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lzU3luY2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChzeW5jU3RhcnRFdmVudCk7XG5cbiAgICAgICAgZ2V0VGV4dFJlbmRlckluZm8oe1xuICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCxcbiAgICAgICAgICBmb250OiB0aGlzLmZvbnQsXG4gICAgICAgICAgbGFuZzogdGhpcy5sYW5nLFxuICAgICAgICAgIGZvbnRTaXplOiB0aGlzLmZvbnRTaXplIHx8IDAuMSxcbiAgICAgICAgICBmb250V2VpZ2h0OiB0aGlzLmZvbnRXZWlnaHQgfHwgJ25vcm1hbCcsXG4gICAgICAgICAgZm9udFN0eWxlOiB0aGlzLmZvbnRTdHlsZSB8fCAnbm9ybWFsJyxcbiAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiB0aGlzLmxldHRlclNwYWNpbmcgfHwgMCxcbiAgICAgICAgICBsaW5lSGVpZ2h0OiB0aGlzLmxpbmVIZWlnaHQgfHwgJ25vcm1hbCcsXG4gICAgICAgICAgbWF4V2lkdGg6IHRoaXMubWF4V2lkdGgsXG4gICAgICAgICAgZGlyZWN0aW9uOiB0aGlzLmRpcmVjdGlvbiB8fCAnYXV0bycsXG4gICAgICAgICAgdGV4dEFsaWduOiB0aGlzLnRleHRBbGlnbixcbiAgICAgICAgICB0ZXh0SW5kZW50OiB0aGlzLnRleHRJbmRlbnQsXG4gICAgICAgICAgd2hpdGVTcGFjZTogdGhpcy53aGl0ZVNwYWNlLFxuICAgICAgICAgIG92ZXJmbG93V3JhcDogdGhpcy5vdmVyZmxvd1dyYXAsXG4gICAgICAgICAgYW5jaG9yWDogdGhpcy5hbmNob3JYLFxuICAgICAgICAgIGFuY2hvclk6IHRoaXMuYW5jaG9yWSxcbiAgICAgICAgICBjb2xvclJhbmdlczogdGhpcy5jb2xvclJhbmdlcyxcbiAgICAgICAgICBpbmNsdWRlQ2FyZXRQb3NpdGlvbnM6IHRydWUsIC8vVE9ETyBwYXJhbWV0ZXJpemVcbiAgICAgICAgICBzZGZHbHlwaFNpemU6IHRoaXMuc2RmR2x5cGhTaXplLFxuICAgICAgICAgIGdwdUFjY2VsZXJhdGVTREY6IHRoaXMuZ3B1QWNjZWxlcmF0ZVNERixcbiAgICAgICAgICB1bmljb2RlRm9udHNVUkw6IHRoaXMudW5pY29kZUZvbnRzVVJMLFxuICAgICAgICB9LCB0ZXh0UmVuZGVySW5mbyA9PiB7XG4gICAgICAgICAgdGhpcy5faXNTeW5jaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBTYXZlIHJlc3VsdCBmb3IgbGF0ZXIgdXNlIGluIG9uQmVmb3JlUmVuZGVyXG4gICAgICAgICAgdGhpcy5fdGV4dFJlbmRlckluZm8gPSB0ZXh0UmVuZGVySW5mbztcblxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZ2VvbWV0cnkgYXR0cmlidXRlc1xuICAgICAgICAgIHRoaXMuZ2VvbWV0cnkudXBkYXRlR2x5cGhzKFxuICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uZ2x5cGhCb3VuZHMsXG4gICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5nbHlwaEF0bGFzSW5kaWNlcyxcbiAgICAgICAgICAgIHRleHRSZW5kZXJJbmZvLmJsb2NrQm91bmRzLFxuICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uY2h1bmtlZEJvdW5kcyxcbiAgICAgICAgICAgIHRleHRSZW5kZXJJbmZvLmdseXBoQ29sb3JzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIElmIHdlIGhhZCBleHRyYSBzeW5jIHJlcXVlc3RzIHF1ZXVlZCB1cCwga2ljayBpdCBvZmZcbiAgICAgICAgICBjb25zdCBxdWV1ZWQgPSB0aGlzLl9xdWV1ZWRTeW5jcztcbiAgICAgICAgICBpZiAocXVldWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZWRTeW5jcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zeW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgcXVldWVkLmZvckVhY2goZm4gPT4gZm4gJiYgZm4oKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoc3luY0NvbXBsZXRlRXZlbnQpO1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZSBhIHN5bmMgaWYgbmVlZGVkIC0gbm90ZSBpdCB3b24ndCBjb21wbGV0ZSB1bnRpbCBuZXh0IGZyYW1lIGF0IHRoZVxuICAgKiBlYXJsaWVzdCBzbyBpZiBwb3NzaWJsZSBpdCdzIGEgZ29vZCBpZGVhIHRvIGNhbGwgc3luYygpIG1hbnVhbGx5IGFzIHNvb24gYXNcbiAgICogYWxsIHRoZSBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBzZXQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgb25CZWZvcmVSZW5kZXIocmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXApIHtcbiAgICB0aGlzLnN5bmMoKTtcblxuICAgIC8vIFRoaXMgbWF5IG5vdCBhbHdheXMgYmUgYSB0ZXh0IG1hdGVyaWFsLCBlLmcuIGlmIHRoZXJlJ3MgYSBzY2VuZS5vdmVycmlkZU1hdGVyaWFsIHByZXNlbnRcbiAgICBpZiAobWF0ZXJpYWwuaXNUcm9pa2FUZXh0TWF0ZXJpYWwpIHtcbiAgICAgIHRoaXMuX3ByZXBhcmVGb3JSZW5kZXIobWF0ZXJpYWwpO1xuICAgIH1cblxuICAgIC8vIFdlIG5lZWQgdG8gZm9yY2UgdGhlIG1hdGVyaWFsIHRvIEZyb250U2lkZSB0byBhdm9pZCB0aGUgZG91YmxlLWRyYXctY2FsbCBwZXJmb3JtYW5jZSBoaXRcbiAgICAvLyBpbnRyb2R1Y2VkIGluIFRocmVlLmpzIHIxMzA6IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yMTk2NyAtIFRoZSBzaWRlZG5lc3NcbiAgICAvLyBpcyBpbnN0ZWFkIGFwcGxpZWQgdmlhIGRyYXdSYW5nZSBpbiB0aGUgR2x5cGhzR2VvbWV0cnkuXG4gICAgbWF0ZXJpYWwuX2hhZE93blNpZGUgPSBtYXRlcmlhbC5oYXNPd25Qcm9wZXJ0eSgnc2lkZScpO1xuICAgIHRoaXMuZ2VvbWV0cnkuc2V0U2lkZShtYXRlcmlhbC5fYWN0dWFsU2lkZSA9IG1hdGVyaWFsLnNpZGUpO1xuICAgIG1hdGVyaWFsLnNpZGUgPSBGcm9udFNpZGU7XG4gIH1cblxuICBvbkFmdGVyUmVuZGVyKHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwKSB7XG4gICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBtYXRlcmlhbCBzaWRlXG4gICAgaWYgKG1hdGVyaWFsLl9oYWRPd25TaWRlKSB7XG4gICAgICBtYXRlcmlhbC5zaWRlID0gbWF0ZXJpYWwuX2FjdHVhbFNpZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBtYXRlcmlhbC5zaWRlOyAvLyBiYWNrIHRvIGluaGVyaXRpbmcgZnJvbSBiYXNlIG1hdGVyaWFsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3J0Y3V0IHRvIGRpc3Bvc2UgdGhlIGdlb21ldHJ5IHNwZWNpZmljIHRvIHRoaXMgaW5zdGFuY2UuXG4gICAqIE5vdGU6IHdlIGRvbid0IGFsc28gZGlzcG9zZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCBoZXJlIGJlY2F1c2UgaWYgYW55dGhpbmcgZWxzZSBpc1xuICAgKiBzaGFyaW5nIHRoZSBzYW1lIGJhc2UgbWF0ZXJpYWwgaXQgd2lsbCByZXN1bHQgaW4gYSBwYXVzZSBuZXh0IGZyYW1lIGFzIHRoZSBwcm9ncmFtXG4gICAqIGlzIHJlY29tcGlsZWQuIEluc3RlYWQgdXNlcnMgY2FuIGRpc3Bvc2UgdGhlIGJhc2UgbWF0ZXJpYWwgbWFudWFsbHksIGxpa2Ugbm9ybWFsLFxuICAgKiBhbmQgd2UnbGwgYWxzbyBkaXNwb3NlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIGF0IHRoYXQgdGltZS5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHtUcm9pa2FUZXh0UmVuZGVySW5mb3xudWxsfSB0ZXh0UmVuZGVySW5mb1xuICAgKiBAcmVhZG9ubHlcbiAgICogVGhlIGN1cnJlbnQgcHJvY2Vzc2VkIHJlbmRlcmluZyBkYXRhIGZvciB0aGlzIFRleHRNZXNoLCByZXR1cm5lZCBieSB0aGUgVGV4dEJ1aWxkZXIgYWZ0ZXJcbiAgICogYSBgc3luYygpYCBjYWxsLiBUaGlzIHdpbGwgYmUgYG51bGxgIGluaXRpYWxseSwgYW5kIG1heSBiZSBzdGFsZSBmb3IgYSBzaG9ydCBwZXJpb2QgdW50aWxcbiAgICogdGhlIGFzeW5jaHJvdXMgYHN5bmMoKWAgcHJvY2VzcyBjb21wbGV0ZXMuXG4gICAqL1xuICBnZXQgdGV4dFJlbmRlckluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHRSZW5kZXJJbmZvIHx8IG51bGxcbiAgfVxuXG4gIC8vIEhhbmRsZXIgZm9yIGF1dG9tYXRpY2FsbHkgd3JhcHBpbmcgdGhlIGJhc2UgbWF0ZXJpYWwgd2l0aCBvdXIgdXBncmFkZXMuIFdlIGRvIHRoZSB3cmFwcGluZ1xuICAvLyBsYXppbHkgb24gX3JlYWRfIHJhdGhlciB0aGFuIHdyaXRlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdyYXBwaW5nIG9uIHRyYW5zaWVudCB2YWx1ZXMuXG4gIGdldCBtYXRlcmlhbCgpIHtcbiAgICBsZXQgZGVyaXZlZE1hdGVyaWFsID0gdGhpcy5fZGVyaXZlZE1hdGVyaWFsO1xuICAgIGNvbnN0IGJhc2VNYXRlcmlhbCA9IHRoaXMuX2Jhc2VNYXRlcmlhbCB8fCB0aGlzLl9kZWZhdWx0TWF0ZXJpYWwgfHwgKHRoaXMuX2RlZmF1bHRNYXRlcmlhbCA9IGRlZmF1bHRNYXRlcmlhbC5jbG9uZSgpKTtcbiAgICBpZiAoIWRlcml2ZWRNYXRlcmlhbCB8fCBkZXJpdmVkTWF0ZXJpYWwuYmFzZU1hdGVyaWFsICE9PSBiYXNlTWF0ZXJpYWwpIHtcbiAgICAgIGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbCA9IGNyZWF0ZVRleHREZXJpdmVkTWF0ZXJpYWwoYmFzZU1hdGVyaWFsKTtcbiAgICAgIC8vIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgd2hlbiBpdHMgYmFzZSBtYXRlcmlhbCBpcyBkaXNwb3NlZDpcbiAgICAgIGJhc2VNYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgZnVuY3Rpb24gb25EaXNwb3NlKCkge1xuICAgICAgICBiYXNlTWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uRGlzcG9zZSk7XG4gICAgICAgIGRlcml2ZWRNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gSWYgdGV4dCBvdXRsaW5lIGlzIGNvbmZpZ3VyZWQsIHJlbmRlciBpdCBhcyBhIHByZWxpbWluYXJ5IGRyYXcgdXNpbmcgVGhyZWUncyBtdWx0aS1tYXRlcmlhbFxuICAgIC8vIGZlYXR1cmUgKHNlZSBHbHlwaHNHZW9tZXRyeSB3aGljaCBzZXRzIHVwIGBncm91cHNgIGZvciB0aGlzIHB1cnBvc2UpIERvaW5nIGl0IHdpdGggbXVsdGlcbiAgICAvLyBtYXRlcmlhbHMgZW5zdXJlcyB0aGUgbGF5ZXJzIGFyZSBhbHdheXMgcmVuZGVyZWQgY29uc2VjdXRpdmVseSBpbiBhIGNvbnNpc3RlbnQgb3JkZXIuXG4gICAgLy8gRWFjaCBsYXllciB3aWxsIHRyaWdnZXIgb25CZWZvcmVSZW5kZXIgd2l0aCB0aGUgYXBwcm9wcmlhdGUgbWF0ZXJpYWwuXG4gICAgaWYgKHRoaXMub3V0bGluZVdpZHRoIHx8IHRoaXMub3V0bGluZUJsdXIgfHwgdGhpcy5vdXRsaW5lT2Zmc2V0WCB8fCB0aGlzLm91dGxpbmVPZmZzZXRZKSB7XG4gICAgICBsZXQgb3V0bGluZU1hdGVyaWFsID0gZGVyaXZlZE1hdGVyaWFsLl9vdXRsaW5lTXRsO1xuICAgICAgaWYgKCFvdXRsaW5lTWF0ZXJpYWwpIHtcbiAgICAgICAgb3V0bGluZU1hdGVyaWFsID0gZGVyaXZlZE1hdGVyaWFsLl9vdXRsaW5lTXRsID0gT2JqZWN0LmNyZWF0ZShkZXJpdmVkTWF0ZXJpYWwsIHtcbiAgICAgICAgICBpZDoge3ZhbHVlOiBkZXJpdmVkTWF0ZXJpYWwuaWQgKyAwLjF9XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRsaW5lTWF0ZXJpYWwuaXNUZXh0T3V0bGluZU1hdGVyaWFsID0gdHJ1ZTtcbiAgICAgICAgb3V0bGluZU1hdGVyaWFsLmRlcHRoV3JpdGUgPSBmYWxzZTtcbiAgICAgICAgb3V0bGluZU1hdGVyaWFsLm1hcCA9IG51bGw7IC8vPz8/XG4gICAgICAgIGRlcml2ZWRNYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgZnVuY3Rpb24gb25EaXNwb3NlKCkge1xuICAgICAgICAgIGRlcml2ZWRNYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25EaXNwb3NlKTtcbiAgICAgICAgICBvdXRsaW5lTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgIG91dGxpbmVNYXRlcmlhbCxcbiAgICAgICAgZGVyaXZlZE1hdGVyaWFsXG4gICAgICBdXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkZXJpdmVkTWF0ZXJpYWxcbiAgICB9XG4gIH1cbiAgc2V0IG1hdGVyaWFsKGJhc2VNYXRlcmlhbCkge1xuICAgIGlmIChiYXNlTWF0ZXJpYWwgJiYgYmFzZU1hdGVyaWFsLmlzVHJvaWthVGV4dE1hdGVyaWFsKSB7IC8vcHJldmVudCBkb3VibGUtZGVyaXZhdGlvblxuICAgICAgdGhpcy5fZGVyaXZlZE1hdGVyaWFsID0gYmFzZU1hdGVyaWFsO1xuICAgICAgdGhpcy5fYmFzZU1hdGVyaWFsID0gYmFzZU1hdGVyaWFsLmJhc2VNYXRlcmlhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYmFzZU1hdGVyaWFsID0gYmFzZU1hdGVyaWFsO1xuICAgIH1cbiAgfVxuXG4gIGdldCBnbHlwaEdlb21ldHJ5RGV0YWlsKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmRldGFpbFxuICB9XG4gIHNldCBnbHlwaEdlb21ldHJ5RGV0YWlsKGRldGFpbCkge1xuICAgIHRoaXMuZ2VvbWV0cnkuZGV0YWlsID0gZGV0YWlsO1xuICB9XG5cbiAgZ2V0IGN1cnZlUmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmN1cnZlUmFkaXVzXG4gIH1cbiAgc2V0IGN1cnZlUmFkaXVzKHIpIHtcbiAgICB0aGlzLmdlb21ldHJ5LmN1cnZlUmFkaXVzID0gcjtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhbmQgdXBkYXRlIG1hdGVyaWFsIGZvciBzaGFkb3dzIHVwb24gcmVxdWVzdDpcbiAgZ2V0IGN1c3RvbURlcHRoTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIGZpcnN0KHRoaXMubWF0ZXJpYWwpLmdldERlcHRoTWF0ZXJpYWwoKVxuICB9XG4gIGdldCBjdXN0b21EaXN0YW5jZU1hdGVyaWFsKCkge1xuICAgIHJldHVybiBmaXJzdCh0aGlzLm1hdGVyaWFsKS5nZXREaXN0YW5jZU1hdGVyaWFsKClcbiAgfVxuXG4gIF9wcmVwYXJlRm9yUmVuZGVyKG1hdGVyaWFsKSB7XG4gICAgY29uc3QgaXNPdXRsaW5lID0gbWF0ZXJpYWwuaXNUZXh0T3V0bGluZU1hdGVyaWFsO1xuICAgIGNvbnN0IHVuaWZvcm1zID0gbWF0ZXJpYWwudW5pZm9ybXM7XG4gICAgY29uc3QgdGV4dEluZm8gPSB0aGlzLnRleHRSZW5kZXJJbmZvO1xuICAgIGlmICh0ZXh0SW5mbykge1xuICAgICAgY29uc3Qge3NkZlRleHR1cmUsIGJsb2NrQm91bmRzfSA9IHRleHRJbmZvO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVNERlRleHR1cmUudmFsdWUgPSBzZGZUZXh0dXJlO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVNERlRleHR1cmVTaXplLnZhbHVlLnNldChzZGZUZXh0dXJlLmltYWdlLndpZHRoLCBzZGZUZXh0dXJlLmltYWdlLmhlaWdodCk7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthU0RGR2x5cGhTaXplLnZhbHVlID0gdGV4dEluZm8uc2RmR2x5cGhTaXplO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVNERkV4cG9uZW50LnZhbHVlID0gdGV4dEluZm8uc2RmRXhwb25lbnQ7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthVG90YWxCb3VuZHMudmFsdWUuZnJvbUFycmF5KGJsb2NrQm91bmRzKTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FVc2VHbHlwaENvbG9ycy52YWx1ZSA9ICFpc091dGxpbmUgJiYgISF0ZXh0SW5mby5nbHlwaENvbG9ycztcblxuICAgICAgbGV0IGRpc3RhbmNlT2Zmc2V0ID0gMDtcbiAgICAgIGxldCBibHVyUmFkaXVzID0gMDtcbiAgICAgIGxldCBzdHJva2VXaWR0aCA9IDA7XG4gICAgICBsZXQgZmlsbE9wYWNpdHk7XG4gICAgICBsZXQgc3Ryb2tlT3BhY2l0eTtcbiAgICAgIGxldCBzdHJva2VDb2xvcjtcbiAgICAgIGxldCBvZmZzZXRYID0gMDtcbiAgICAgIGxldCBvZmZzZXRZID0gMDtcblxuICAgICAgaWYgKGlzT3V0bGluZSkge1xuICAgICAgICBsZXQge291dGxpbmVXaWR0aCwgb3V0bGluZU9mZnNldFgsIG91dGxpbmVPZmZzZXRZLCBvdXRsaW5lQmx1ciwgb3V0bGluZU9wYWNpdHl9ID0gdGhpcztcbiAgICAgICAgZGlzdGFuY2VPZmZzZXQgPSB0aGlzLl9wYXJzZVBlcmNlbnQob3V0bGluZVdpZHRoKSB8fCAwO1xuICAgICAgICBibHVyUmFkaXVzID0gTWF0aC5tYXgoMCwgdGhpcy5fcGFyc2VQZXJjZW50KG91dGxpbmVCbHVyKSB8fCAwKTtcbiAgICAgICAgZmlsbE9wYWNpdHkgPSBvdXRsaW5lT3BhY2l0eTtcbiAgICAgICAgb2Zmc2V0WCA9IHRoaXMuX3BhcnNlUGVyY2VudChvdXRsaW5lT2Zmc2V0WCkgfHwgMDtcbiAgICAgICAgb2Zmc2V0WSA9IHRoaXMuX3BhcnNlUGVyY2VudChvdXRsaW5lT2Zmc2V0WSkgfHwgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cm9rZVdpZHRoID0gTWF0aC5tYXgoMCwgdGhpcy5fcGFyc2VQZXJjZW50KHRoaXMuc3Ryb2tlV2lkdGgpIHx8IDApO1xuICAgICAgICBpZiAoc3Ryb2tlV2lkdGgpIHtcbiAgICAgICAgICBzdHJva2VDb2xvciA9IHRoaXMuc3Ryb2tlQ29sb3I7XG4gICAgICAgICAgdW5pZm9ybXMudVRyb2lrYVN0cm9rZUNvbG9yLnZhbHVlLnNldChzdHJva2VDb2xvciA9PSBudWxsID8gZGVmYXVsdFN0cm9rZUNvbG9yIDogc3Ryb2tlQ29sb3IpO1xuICAgICAgICAgIHN0cm9rZU9wYWNpdHkgPSB0aGlzLnN0cm9rZU9wYWNpdHk7XG4gICAgICAgICAgaWYgKHN0cm9rZU9wYWNpdHkgPT0gbnVsbCkgc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZmlsbE9wYWNpdHkgPSB0aGlzLmZpbGxPcGFjaXR5O1xuICAgICAgfVxuXG4gICAgICB1bmlmb3Jtcy51VHJvaWthRGlzdGFuY2VPZmZzZXQudmFsdWUgPSBkaXN0YW5jZU9mZnNldDtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FQb3NpdGlvbk9mZnNldC52YWx1ZS5zZXQob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthQmx1clJhZGl1cy52YWx1ZSA9IGJsdXJSYWRpdXM7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthU3Ryb2tlV2lkdGgudmFsdWUgPSBzdHJva2VXaWR0aDtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FTdHJva2VPcGFjaXR5LnZhbHVlID0gc3Ryb2tlT3BhY2l0eTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FGaWxsT3BhY2l0eS52YWx1ZSA9IGZpbGxPcGFjaXR5ID09IG51bGwgPyAxIDogZmlsbE9wYWNpdHk7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthQ3VydmVSYWRpdXMudmFsdWUgPSB0aGlzLmN1cnZlUmFkaXVzIHx8IDA7XG5cbiAgICAgIGxldCBjbGlwUmVjdCA9IHRoaXMuY2xpcFJlY3Q7XG4gICAgICBpZiAoY2xpcFJlY3QgJiYgQXJyYXkuaXNBcnJheShjbGlwUmVjdCkgJiYgY2xpcFJlY3QubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FDbGlwUmVjdC52YWx1ZS5mcm9tQXJyYXkoY2xpcFJlY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gY2xpcHBpbmcgLSBjaG9vc2UgYSBmaW5pdGUgcmVjdCB0aGF0IHNob3VsZG4ndCBldmVyIGJlIHJlYWNoZWQgYnkgb3ZlcmZsb3dpbmcgZ2x5cGhzIG9yIG91dGxpbmVzXG4gICAgICAgIGNvbnN0IHBhZCA9ICh0aGlzLmZvbnRTaXplIHx8IDAuMSkgKiAxMDA7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FDbGlwUmVjdC52YWx1ZS5zZXQoXG4gICAgICAgICAgYmxvY2tCb3VuZHNbMF0gLSBwYWQsXG4gICAgICAgICAgYmxvY2tCb3VuZHNbMV0gLSBwYWQsXG4gICAgICAgICAgYmxvY2tCb3VuZHNbMl0gKyBwYWQsXG4gICAgICAgICAgYmxvY2tCb3VuZHNbM10gKyBwYWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2VvbWV0cnkuYXBwbHlDbGlwUmVjdCh1bmlmb3Jtcy51VHJvaWthQ2xpcFJlY3QudmFsdWUpO1xuICAgIH1cbiAgICB1bmlmb3Jtcy51VHJvaWthU0RGRGVidWcudmFsdWUgPSAhIXRoaXMuZGVidWdTREY7XG4gICAgbWF0ZXJpYWwucG9seWdvbk9mZnNldCA9ICEhdGhpcy5kZXB0aE9mZnNldDtcbiAgICBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzID0gdGhpcy5kZXB0aE9mZnNldCB8fCAwO1xuXG4gICAgLy8gU2hvcnRjdXQgZm9yIHNldHRpbmcgbWF0ZXJpYWwgY29sb3IgdmlhIGBjb2xvcmAgcHJvcCBvbiB0aGUgbWVzaDsgdGhpcyBpc1xuICAgIC8vIGFwcGxpZWQgb25seSB0byB0aGUgZGVyaXZlZCBtYXRlcmlhbCB0byBhdm9pZCBtdXRhdGluZyBhIHNoYXJlZCBiYXNlIG1hdGVyaWFsLlxuICAgIGNvbnN0IGNvbG9yID0gaXNPdXRsaW5lID8gKHRoaXMub3V0bGluZUNvbG9yIHx8IDApIDogdGhpcy5jb2xvcjtcblxuICAgIGlmIChjb2xvciA9PSBudWxsKSB7XG4gICAgICBkZWxldGUgbWF0ZXJpYWwuY29sb3I7IC8vaW5oZXJpdCBmcm9tIGJhc2VcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29sb3JPYmogPSBtYXRlcmlhbC5oYXNPd25Qcm9wZXJ0eSgnY29sb3InKSA/IG1hdGVyaWFsLmNvbG9yIDogKG1hdGVyaWFsLmNvbG9yID0gbmV3IENvbG9yKCkpO1xuICAgICAgaWYgKGNvbG9yICE9PSBjb2xvck9iai5faW5wdXQgfHwgdHlwZW9mIGNvbG9yID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb2xvck9iai5zZXQoY29sb3JPYmouX2lucHV0ID0gY29sb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGJhc2Ugb3JpZW50YXRpb25cbiAgICBsZXQgb3JpZW50ID0gdGhpcy5vcmllbnRhdGlvbiB8fCBkZWZhdWx0T3JpZW50O1xuICAgIGlmIChvcmllbnQgIT09IG1hdGVyaWFsLl9vcmllbnRhdGlvbikge1xuICAgICAgbGV0IHJvdE1hdCA9IHVuaWZvcm1zLnVUcm9pa2FPcmllbnQudmFsdWU7XG4gICAgICBvcmllbnQgPSBvcmllbnQucmVwbGFjZSgvW14tK3h5el0vZywgJycpO1xuICAgICAgbGV0IG1hdGNoID0gb3JpZW50ICE9PSBkZWZhdWx0T3JpZW50ICYmIG9yaWVudC5tYXRjaCgvXihbLStdKShbeHl6XSkoWy0rXSkoW3h5el0pJC8pO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGxldCBbLCBoU2lnbiwgaEF4aXMsIHZTaWduLCB2QXhpc10gPSBtYXRjaDtcbiAgICAgICAgdGVtcFZlYzNhLnNldCgwLCAwLCAwKVtoQXhpc10gPSBoU2lnbiA9PT0gJy0nID8gMSA6IC0xO1xuICAgICAgICB0ZW1wVmVjM2Iuc2V0KDAsIDAsIDApW3ZBeGlzXSA9IHZTaWduID09PSAnLScgPyAtMSA6IDE7XG4gICAgICAgIHRlbXBNYXQ0Lmxvb2tBdChvcmlnaW4sIHRlbXBWZWMzYS5jcm9zcyh0ZW1wVmVjM2IpLCB0ZW1wVmVjM2IpO1xuICAgICAgICByb3RNYXQuc2V0RnJvbU1hdHJpeDQodGVtcE1hdDQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm90TWF0LmlkZW50aXR5KCk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbC5fb3JpZW50YXRpb24gPSBvcmllbnQ7XG4gICAgfVxuICB9XG5cbiAgX3BhcnNlUGVyY2VudCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXigtP1tcXGQuXSspJSQvKTtcbiAgICAgIGxldCBwY3QgPSBtYXRjaCA/IHBhcnNlRmxvYXQobWF0Y2hbMV0pIDogTmFOO1xuICAgICAgdmFsdWUgPSAoaXNOYU4ocGN0KSA/IDAgOiBwY3QgLyAxMDApICogdGhpcy5mb250U2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNsYXRlIGEgcG9pbnQgaW4gbG9jYWwgc3BhY2UgdG8gYW4geC95IGluIHRoZSB0ZXh0IHBsYW5lLlxuICAgKi9cbiAgbG9jYWxQb3NpdGlvblRvVGV4dENvb3Jkcyhwb3NpdGlvbiwgdGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSkge1xuICAgIHRhcmdldC5jb3B5KHBvc2l0aW9uKTsgLy9zaW1wbGUgbm9uLWN1cnZlZCBjYXNlIGlzIDE6MVxuICAgIGNvbnN0IHIgPSB0aGlzLmN1cnZlUmFkaXVzO1xuICAgIGlmIChyKSB7IC8vZmxhdHRlbiB0aGUgY3VydmVcbiAgICAgIHRhcmdldC54ID0gTWF0aC5hdGFuMihwb3NpdGlvbi54LCBNYXRoLmFicyhyKSAtIE1hdGguYWJzKHBvc2l0aW9uLnopKSAqIE1hdGguYWJzKHIpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNsYXRlIGEgcG9pbnQgaW4gd29ybGQgc3BhY2UgdG8gYW4geC95IGluIHRoZSB0ZXh0IHBsYW5lLlxuICAgKi9cbiAgd29ybGRQb3NpdGlvblRvVGV4dENvb3Jkcyhwb3NpdGlvbiwgdGFyZ2V0ID0gbmV3IFZlY3RvcjIoKSkge1xuICAgIHRlbXBWZWMzYS5jb3B5KHBvc2l0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5sb2NhbFBvc2l0aW9uVG9UZXh0Q29vcmRzKHRoaXMud29ybGRUb0xvY2FsKHRlbXBWZWMzYSksIHRhcmdldClcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGUgQ3VzdG9tIHJheWNhc3RpbmcgdG8gdGVzdCBhZ2FpbnN0IHRoZSB3aG9sZSB0ZXh0IGJsb2NrJ3MgbWF4IHJlY3Rhbmd1bGFyIGJvdW5kc1xuICAgKiBUT0RPIGlzIHRoZXJlIGFueSByZWFzb24gdG8gbWFrZSB0aGlzIG1vcmUgZ3JhbnVsYXIsIGxpa2Ugd2l0aGluIGluZGl2aWR1YWwgbGluZSBvciBnbHlwaCByZWN0cz9cbiAgICovXG4gIHJheWNhc3QocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG4gICAgY29uc3Qge3RleHRSZW5kZXJJbmZvLCBjdXJ2ZVJhZGl1c30gPSB0aGlzO1xuICAgIGlmICh0ZXh0UmVuZGVySW5mbykge1xuICAgICAgY29uc3QgYm91bmRzID0gdGV4dFJlbmRlckluZm8uYmxvY2tCb3VuZHM7XG4gICAgICBjb25zdCByYXljYXN0TWVzaCA9IGN1cnZlUmFkaXVzID8gZ2V0Q3VydmVkUmF5Y2FzdE1lc2goKSA6IGdldEZsYXRSYXljYXN0TWVzaCgpO1xuICAgICAgY29uc3QgZ2VvbSA9IHJheWNhc3RNZXNoLmdlb21ldHJ5O1xuICAgICAgY29uc3Qge3Bvc2l0aW9uLCB1dn0gPSBnZW9tLmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHV2LmNvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IHggPSBib3VuZHNbMF0gKyAodXYuZ2V0WChpKSAqIChib3VuZHNbMl0gLSBib3VuZHNbMF0pKTtcbiAgICAgICAgY29uc3QgeSA9IGJvdW5kc1sxXSArICh1di5nZXRZKGkpICogKGJvdW5kc1szXSAtIGJvdW5kc1sxXSkpO1xuICAgICAgICBsZXQgeiA9IDA7XG4gICAgICAgIGlmIChjdXJ2ZVJhZGl1cykge1xuICAgICAgICAgIHogPSBjdXJ2ZVJhZGl1cyAtIE1hdGguY29zKHggLyBjdXJ2ZVJhZGl1cykgKiBjdXJ2ZVJhZGl1cztcbiAgICAgICAgICB4ID0gTWF0aC5zaW4oeCAvIGN1cnZlUmFkaXVzKSAqIGN1cnZlUmFkaXVzO1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9uLnNldFhZWihpLCB4LCB5LCB6KTtcbiAgICAgIH1cbiAgICAgIGdlb20uYm91bmRpbmdTcGhlcmUgPSB0aGlzLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlO1xuICAgICAgZ2VvbS5ib3VuZGluZ0JveCA9IHRoaXMuZ2VvbWV0cnkuYm91bmRpbmdCb3g7XG4gICAgICByYXljYXN0TWVzaC5tYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG4gICAgICByYXljYXN0TWVzaC5tYXRlcmlhbC5zaWRlID0gdGhpcy5tYXRlcmlhbC5zaWRlO1xuICAgICAgdGVtcEFycmF5Lmxlbmd0aCA9IDA7XG4gICAgICByYXljYXN0TWVzaC5yYXljYXN0KHJheWNhc3RlciwgdGVtcEFycmF5KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRlbXBBcnJheVtpXS5vYmplY3QgPSB0aGlzO1xuICAgICAgICBpbnRlcnNlY3RzLnB1c2godGVtcEFycmF5W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb3B5KHNvdXJjZSkge1xuICAgIC8vIFByZXZlbnQgY29weWluZyB0aGUgZ2VvbWV0cnkgcmVmZXJlbmNlIHNvIHdlIGRvbid0IGVuZCB1cCBzaGFyaW5nIGF0dHJpYnV0ZXMgYmV0d2VlbiBpbnN0YW5jZXNcbiAgICBjb25zdCBnZW9tID0gdGhpcy5nZW9tZXRyeTtcbiAgICBzdXBlci5jb3B5KHNvdXJjZSk7XG4gICAgdGhpcy5nZW9tZXRyeSA9IGdlb207XG5cbiAgICBDT1BZQUJMRV9QUk9QUy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgdGhpc1twcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKVxuICB9XG59XG5cblxuLy8gQ3JlYXRlIHNldHRlcnMgZm9yIHByb3BlcnRpZXMgdGhhdCBhZmZlY3QgdGV4dCBsYXlvdXQ6XG5TWU5DQUJMRV9QUk9QUy5mb3JFYWNoKHByb3AgPT4ge1xuICBjb25zdCBwcml2YXRlS2V5ID0gJ19wcml2YXRlXycgKyBwcm9wO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dC5wcm90b3R5cGUsIHByb3AsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1twcml2YXRlS2V5XVxuICAgIH0sXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHRoaXNbcHJpdmF0ZUtleV0pIHtcbiAgICAgICAgdGhpc1twcml2YXRlS2V5XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9uZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59KTtcblxuLy89PT0gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBjYXJldHMgYW5kIHNlbGVjdGlvbiByYW5nZXMgPT09Ly9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUZXh0Q2FyZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IC0geCBwb3NpdGlvbiBvZiB0aGUgY2FyZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IC0geSBwb3NpdGlvbiBvZiB0aGUgY2FyZXQncyBib3R0b21cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBoZWlnaHQgb2YgdGhlIGNhcmV0XG4gKiBAcHJvcGVydHkge251bWJlcn0gY2hhckluZGV4IC0gdGhlIGluZGV4IGluIHRoZSBvcmlnaW5hbCBpbnB1dCBzdHJpbmcgb2YgdGhpcyBjYXJldCdzIHRhcmdldFxuICogICBjaGFyYWN0ZXI7IHRoZSBjYXJldCB3aWxsIGJlIGZvciB0aGUgcG9zaXRpb24gX2JlZm9yZV8gdGhhdCBjaGFyYWN0ZXIuXG4gKi9cblxuLyoqXG4gKiBHaXZlbiBhIGxvY2FsIHgveSBjb29yZGluYXRlIGluIHRoZSB0ZXh0IGJsb2NrIHBsYW5lLCBmaW5kIHRoZSBuZWFyZXN0IGNhcmV0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtUcm9pa2FUZXh0UmVuZGVySW5mb30gdGV4dFJlbmRlckluZm8gLSBhIHJlc3VsdCBvYmplY3QgZnJvbSBUZXh0QnVpbGRlciNnZXRUZXh0UmVuZGVySW5mb1xuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtUZXh0Q2FyZXQgfCBudWxsfVxuICovXG5mdW5jdGlvbiBnZXRDYXJldEF0UG9pbnQodGV4dFJlbmRlckluZm8sIHgsIHkpIHtcbiAgbGV0IGNsb3Nlc3RDYXJldCA9IG51bGw7XG4gIGNvbnN0IHJvd3MgPSBncm91cENhcmV0c0J5Um93KHRleHRSZW5kZXJJbmZvKTtcblxuICAvLyBGaW5kIG5lYXJlc3Qgcm93IGJ5IHkgZmlyc3RcbiAgbGV0IGNsb3Nlc3RSb3cgPSBudWxsO1xuICByb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBpZiAoIWNsb3Nlc3RSb3cgfHwgTWF0aC5hYnMoeSAtIChyb3cudG9wICsgcm93LmJvdHRvbSkgLyAyKSA8IE1hdGguYWJzKHkgLSAoY2xvc2VzdFJvdy50b3AgKyBjbG9zZXN0Um93LmJvdHRvbSkgLyAyKSkge1xuICAgICAgY2xvc2VzdFJvdyA9IHJvdztcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRoZW4gZmluZCBjbG9zZXN0IGNhcmV0IGJ5IHggd2l0aGluIHRoYXQgcm93XG4gIGNsb3Nlc3RSb3cuY2FyZXRzLmZvckVhY2goY2FyZXQgPT4ge1xuICAgIGlmICghY2xvc2VzdENhcmV0IHx8IE1hdGguYWJzKHggLSBjYXJldC54KSA8IE1hdGguYWJzKHggLSBjbG9zZXN0Q2FyZXQueCkpIHtcbiAgICAgIGNsb3Nlc3RDYXJldCA9IGNhcmV0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjbG9zZXN0Q2FyZXRcbn1cblxuXG5jb25zdCBfcmVjdHNDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogR2l2ZW4gc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXIgaW5kZXhlcywgcmV0dXJuIGEgbGlzdCBvZiByZWN0YW5nbGVzIGNvdmVyaW5nIGFsbCB0aGVcbiAqIGNoYXJhY3RlcnMgd2l0aGluIHRoYXQgc2VsZWN0aW9uLlxuICogQHBhcmFtIHtUcm9pa2FUZXh0UmVuZGVySW5mb30gdGV4dFJlbmRlckluZm9cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyIGluIHRoZSBzZWxlY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgLSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhciBhZnRlciB0aGUgc2VsZWN0aW9uXG4gKiBAcmV0dXJuIHtBcnJheTx7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfT4gfCBudWxsfVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25SZWN0cyh0ZXh0UmVuZGVySW5mbywgc3RhcnQsIGVuZCkge1xuICBsZXQgcmVjdHM7XG4gIGlmICh0ZXh0UmVuZGVySW5mbykge1xuICAgIC8vIENoZWNrIGNhY2hlIC0gdGV4dFJlbmRlckluZm8gaXMgZnJvemVuIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSBiYXNlZCBvbiBpdFxuICAgIGxldCBwcmV2UmVzdWx0ID0gX3JlY3RzQ2FjaGUuZ2V0KHRleHRSZW5kZXJJbmZvKTtcbiAgICBpZiAocHJldlJlc3VsdCAmJiBwcmV2UmVzdWx0LnN0YXJ0ID09PSBzdGFydCAmJiBwcmV2UmVzdWx0LmVuZCA9PT0gZW5kKSB7XG4gICAgICByZXR1cm4gcHJldlJlc3VsdC5yZWN0c1xuICAgIH1cblxuICAgIGNvbnN0IHtjYXJldFBvc2l0aW9uc30gPSB0ZXh0UmVuZGVySW5mbztcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIGlmIChlbmQgPCBzdGFydCkge1xuICAgICAgY29uc3QgcyA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICBlbmQgPSBzO1xuICAgIH1cbiAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCAwKTtcbiAgICBlbmQgPSBNYXRoLm1pbihlbmQsIGNhcmV0UG9zaXRpb25zLmxlbmd0aCArIDEpO1xuXG4gICAgLy8gQnVpbGQgbGlzdCBvZiByZWN0cywgZXhwYW5kaW5nIHRoZSBjdXJyZW50IHJlY3QgZm9yIGFsbCBjaGFyYWN0ZXJzIGluIGEgcnVuIGFuZCBzdGFydGluZ1xuICAgIC8vIGEgbmV3IHJlY3Qgd2hlbmV2ZXIgcmVhY2hpbmcgYSBuZXcgbGluZSBvciBhIG5ldyBiaWRpIGRpcmVjdGlvblxuICAgIHJlY3RzID0gW107XG4gICAgbGV0IGN1cnJlbnRSZWN0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgeDEgPSBjYXJldFBvc2l0aW9uc1tpICogNF07XG4gICAgICBjb25zdCB4MiA9IGNhcmV0UG9zaXRpb25zW2kgKiA0ICsgMV07XG4gICAgICBjb25zdCBsZWZ0ID0gTWF0aC5taW4oeDEsIHgyKTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gTWF0aC5tYXgoeDEsIHgyKTtcbiAgICAgIGNvbnN0IGJvdHRvbSA9IGNhcmV0UG9zaXRpb25zW2kgKiA0ICsgMl07XG4gICAgICBjb25zdCB0b3AgPSBjYXJldFBvc2l0aW9uc1tpICogNCArIDNdO1xuICAgICAgaWYgKCFjdXJyZW50UmVjdCB8fCBib3R0b20gIT09IGN1cnJlbnRSZWN0LmJvdHRvbSB8fCB0b3AgIT09IGN1cnJlbnRSZWN0LnRvcCB8fCBsZWZ0ID4gY3VycmVudFJlY3QucmlnaHQgfHwgcmlnaHQgPCBjdXJyZW50UmVjdC5sZWZ0KSB7XG4gICAgICAgIGN1cnJlbnRSZWN0ID0ge1xuICAgICAgICAgIGxlZnQ6IEluZmluaXR5LFxuICAgICAgICAgIHJpZ2h0OiAtSW5maW5pdHksXG4gICAgICAgICAgYm90dG9tLFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgfTtcbiAgICAgICAgcmVjdHMucHVzaChjdXJyZW50UmVjdCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50UmVjdC5sZWZ0ID0gTWF0aC5taW4obGVmdCwgY3VycmVudFJlY3QubGVmdCk7XG4gICAgICBjdXJyZW50UmVjdC5yaWdodCA9IE1hdGgubWF4KHJpZ2h0LCBjdXJyZW50UmVjdC5yaWdodCk7XG4gICAgfVxuXG4gICAgLy8gTWVyZ2UgYW55IG92ZXJsYXBwaW5nIHJlY3RzLCBlLmcuIHRob3NlIGZvcm1lZCBieSBhZGphY2VudCBiaWRpIHJ1bnNcbiAgICByZWN0cy5zb3J0KChhLCBiKSA9PiBiLmJvdHRvbSAtIGEuYm90dG9tIHx8IGEubGVmdCAtIGIubGVmdCk7XG4gICAgZm9yIChsZXQgaSA9IHJlY3RzLmxlbmd0aCAtIDE7IGktLSA+IDA7KSB7XG4gICAgICBjb25zdCByZWN0QSA9IHJlY3RzW2ldO1xuICAgICAgY29uc3QgcmVjdEIgPSByZWN0c1tpICsgMV07XG4gICAgICBpZiAocmVjdEEuYm90dG9tID09PSByZWN0Qi5ib3R0b20gJiYgcmVjdEEudG9wID09PSByZWN0Qi50b3AgJiYgcmVjdEEubGVmdCA8PSByZWN0Qi5yaWdodCAmJiByZWN0QS5yaWdodCA+PSByZWN0Qi5sZWZ0KSB7XG4gICAgICAgIHJlY3RCLmxlZnQgPSBNYXRoLm1pbihyZWN0Qi5sZWZ0LCByZWN0QS5sZWZ0KTtcbiAgICAgICAgcmVjdEIucmlnaHQgPSBNYXRoLm1heChyZWN0Qi5yaWdodCwgcmVjdEEucmlnaHQpO1xuICAgICAgICByZWN0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3JlY3RzQ2FjaGUuc2V0KHRleHRSZW5kZXJJbmZvLCB7c3RhcnQsIGVuZCwgcmVjdHN9KTtcbiAgfVxuICByZXR1cm4gcmVjdHNcbn1cblxuY29uc3QgX2NhcmV0c0J5Um93Q2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIEdyb3VwIGEgc2V0IG9mIGNhcmV0cyBieSByb3cgb2YgdGV4dCwgY2FjaGluZyB0aGUgcmVzdWx0LiBBIHNpbmdsZSByb3cgb2YgdGV4dCBtYXkgY29udGFpbiBjYXJldHMgb2ZcbiAqIGRpZmZlcmluZyBwb3NpdGlvbnMvaGVpZ2h0cyBpZiBpdCBoYXMgbXVsdGlwbGUgZm9udHMsIGFuZCB0aGV5IG1heSBvdmVybGFwIHNsaWdodGx5IGFjcm9zcyByb3dzLCBzbyB0aGlzXG4gKiB1c2VzIGFuIGFzc3VtcHRpb24gb2YgXCJhdCBsZWFzdCBvdmVybGFwcGluZyBieSBoYWxmXCIgdG8gcHV0IHRoZW0gaW4gdGhlIHNhbWUgcm93LlxuICogQHJldHVybiBBcnJheTx7Ym90dG9tOiBudW1iZXIsIHRvcDogbnVtYmVyLCBjYXJldHM6IFRleHRDYXJldFtdfT5cbiAqL1xuZnVuY3Rpb24gZ3JvdXBDYXJldHNCeVJvdyh0ZXh0UmVuZGVySW5mbykge1xuICAvLyB0ZXh0UmVuZGVySW5mbyBpcyBmcm96ZW4gc28gaXQncyBzYWZlIHRvIGNhY2hlIGJhc2VkIG9uIGl0XG4gIGxldCByb3dzID0gX2NhcmV0c0J5Um93Q2FjaGUuZ2V0KHRleHRSZW5kZXJJbmZvKTtcbiAgaWYgKCFyb3dzKSB7XG4gICAgcm93cyA9IFtdO1xuICAgIGNvbnN0IHtjYXJldFBvc2l0aW9uc30gPSB0ZXh0UmVuZGVySW5mbztcbiAgICBsZXQgY3VyUm93O1xuXG4gICAgY29uc3QgdmlzaXRDYXJldCA9ICh4LCBib3R0b20sIHRvcCwgY2hhckluZGV4KSA9PiB7XG4gICAgICAvLyBuZXcgcm93IGlmIG5vdCBvdmVybGFwcGluZyBieSBhdCBsZWFzdCBoYWxmXG4gICAgICBpZiAoIWN1clJvdyB8fCAodG9wIDwgKGN1clJvdy50b3AgKyBjdXJSb3cuYm90dG9tKSAvIDIpKSB7XG4gICAgICAgIHJvd3MucHVzaChjdXJSb3cgPSB7Ym90dG9tLCB0b3AsIGNhcmV0czogW119KTtcbiAgICAgIH1cbiAgICAgIC8vIGV4cGFuZCB2ZXJ0aWNhbCBsaW1pdHMgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAodG9wID4gY3VyUm93LnRvcCkgY3VyUm93LnRvcCA9IHRvcDtcbiAgICAgIGlmIChib3R0b20gPCBjdXJSb3cuYm90dG9tKSBjdXJSb3cuYm90dG9tID0gYm90dG9tO1xuICAgICAgY3VyUm93LmNhcmV0cy5wdXNoKHtcbiAgICAgICAgeCxcbiAgICAgICAgeTogYm90dG9tLFxuICAgICAgICBoZWlnaHQ6IHRvcCAtIGJvdHRvbSxcbiAgICAgICAgY2hhckluZGV4LFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGNhcmV0UG9zaXRpb25zLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICB2aXNpdENhcmV0KGNhcmV0UG9zaXRpb25zW2ldLCBjYXJldFBvc2l0aW9uc1tpICsgMl0sIGNhcmV0UG9zaXRpb25zW2kgKyAzXSwgaSAvIDQpO1xuICAgIH1cbiAgICAvLyBBZGQgb25lIG1vcmUgY2FyZXQgYWZ0ZXIgdGhlIGZpbmFsIGNoYXJcbiAgICB2aXNpdENhcmV0KGNhcmV0UG9zaXRpb25zW2kgLSAzXSwgY2FyZXRQb3NpdGlvbnNbaSAtIDJdLCBjYXJldFBvc2l0aW9uc1tpIC0gMV0sIGkgLyA0KTtcbiAgfVxuICBfY2FyZXRzQnlSb3dDYWNoZS5zZXQodGV4dFJlbmRlckluZm8sIHJvd3MpO1xuICByZXR1cm4gcm93c1xufVxuXG5leHBvcnQgeyBHbHlwaHNHZW9tZXRyeSwgVGV4dCwgY29uZmlndXJlVGV4dEJ1aWxkZXIsIGNyZWF0ZVRleHREZXJpdmVkTWF0ZXJpYWwsIGR1bXBTREZUZXh0dXJlcywgZm9udFJlc29sdmVyV29ya2VyTW9kdWxlLCBnZXRDYXJldEF0UG9pbnQsIGdldFNlbGVjdGlvblJlY3RzLCBnZXRUZXh0UmVuZGVySW5mbywgcHJlbG9hZEZvbnQsIHR5cGVzZXR0ZXJXb3JrZXJNb2R1bGUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/troika-three-text/dist/troika-three-text.esm.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/troika-three-utils/dist/troika-three-utils.esm.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BezierMesh: function() { return /* binding */ BezierMesh; },\n/* harmony export */   createDerivedMaterial: function() { return /* binding */ createDerivedMaterial; },\n/* harmony export */   expandShaderIncludes: function() { return /* binding */ expandShaderIncludes; },\n/* harmony export */   getShaderUniformTypes: function() { return /* binding */ getShaderUniformTypes; },\n/* harmony export */   getShadersForMaterial: function() { return /* binding */ getShadersForMaterial; },\n/* harmony export */   invertMatrix4: function() { return /* binding */ invertMatrix4; },\n/* harmony export */   voidMainRegExp: function() { return /* binding */ voidMainRegExp; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-client)/./node_modules/three/build/three.module.js\");\n\n\n/**\n * Regular expression for matching the `void main() {` opener line in GLSL.\n * @type {RegExp}\n */\nconst voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n/**\n * Recursively expands all `#include <xyz>` statements within string of shader code.\n * Copied from three's WebGLProgram#parseIncludes for external use.\n *\n * @param {string} source - The GLSL source code to evaluate\n * @return {string} The GLSL code with all includes expanded\n */\nfunction expandShaderIncludes( source ) {\n  const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n  function replace(match, include) {\n    let chunk = three__WEBPACK_IMPORTED_MODULE_0__.ShaderChunk[include];\n    return chunk ? expandShaderIncludes(chunk) : match\n  }\n  return source.replace( pattern, replace )\n}\n\n/*\n * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\n * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\n * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\n */\n\nconst _lut = [];\n\nfor (let i = 0; i < 256; i++) {\n  _lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n}\n\nfunction generateUUID() {\n\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n  const d0 = Math.random() * 0xffffffff | 0;\n  const d1 = Math.random() * 0xffffffff | 0;\n  const d2 = Math.random() * 0xffffffff | 0;\n  const d3 = Math.random() * 0xffffffff | 0;\n  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +\n    _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +\n    _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +\n    _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];\n\n  // .toUpperCase() here flattens concatenated strings to save heap memory space.\n  return uuid.toUpperCase()\n\n}\n\n// Local assign polyfill to avoid importing troika-core\nconst assign = Object.assign || function(/*target, ...sources*/) {\n  let target = arguments[0];\n  for (let i = 1, len = arguments.length; i < len; i++) {\n    let source = arguments[i];\n    if (source) {\n      for (let prop in source) {\n        if (Object.prototype.hasOwnProperty.call(source, prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n  return target\n};\n\n\nconst epoch = Date.now();\nconst CONSTRUCTOR_CACHE = new WeakMap();\nconst SHADER_UPGRADE_CACHE = new Map();\n\n// Material ids must be integers, but we can't access the increment from Three's `Material` module,\n// so let's choose a sufficiently large starting value that should theoretically never collide.\nlet materialInstanceId = 1e10;\n\n/**\n * A utility for creating a custom shader material derived from another material's\n * shaders. This allows you to inject custom shader logic and transforms into the\n * builtin ThreeJS materials without having to recreate them from scratch.\n *\n * @param {THREE.Material} baseMaterial - the original material to derive from\n *\n * @param {Object} options - How the base material should be modified.\n * @param {Object} options.defines - Custom `defines` for the material\n * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\n *        both shaders, and it will automatically be updated on each render frame with a number of\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n *        true calendar time.\n * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n *        shader's `void main` function.\n * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n *        shader's `void main` function.\n * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n *        those attributes exposed by their normal names as read/write values.\n * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n *        shader's `void main` function.\n * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n *        want those to apply to your changes use `fragmentColorTransform` instead.\n * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n *        output value. Will be injected near the end of the `void main` function, but before any\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n *        `fragmentMainOutro`.\n * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\n *        special that's not covered by the other builtin options. This function will be executed before\n *        any other transforms are applied.\n * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\n *        material, rather than the default behavior of copying it. This allows the derived material to\n *        automatically pick up changes made to the base material and its properties. This can be useful\n *        where the derived material is hidden from the user as an implementation detail, allowing them\n *        to work with the original material like normal. But it can result in unexpected behavior if not\n *        handled carefully.\n *\n * @return {THREE.Material}\n *\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n * which can be called to get a variant of the derived material for use in shadow casting. If the\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\n */\nfunction createDerivedMaterial(baseMaterial, options) {\n  // Generate a key that is unique to the content of these `options`. We'll use this\n  // throughout for caching and for generating the upgraded shader code. This increases\n  // the likelihood that the resulting shaders will line up across multiple calls so\n  // their GL programs can be shared and cached.\n  const optionsKey = getKeyForOptions(options);\n\n  // First check to see if we've already derived from this baseMaterial using this\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\n  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n  if (!ctorsByDerivation) {\n    CONSTRUCTOR_CACHE.set(baseMaterial, (ctorsByDerivation = Object.create(null)));\n  }\n  if (ctorsByDerivation[optionsKey]) {\n    return new ctorsByDerivation[optionsKey]()\n  }\n\n  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;\n\n  // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n  // the renderer switches to this material's program\n  const onBeforeCompile = function (shaderInfo, renderer) {\n    baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);\n\n    // Upgrade the shaders, caching the result by incoming source code\n    const cacheKey = this.customProgramCacheKey() + '|' + shaderInfo.vertexShader + '|' + shaderInfo.fragmentShader;\n    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n    if (!upgradedShaders) {\n      const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n    }\n\n    // Inject upgraded shaders and uniforms into the program\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n    assign(shaderInfo.uniforms, this.uniforms);\n\n    // Inject auto-updating time uniform if requested\n    if (options.timeUniform) {\n      shaderInfo.uniforms[options.timeUniform] = {\n        get value() {return Date.now() - epoch}\n      };\n    }\n\n    // Users can still add their own handlers on top of ours\n    if (this[privateBeforeCompileProp]) {\n      this[privateBeforeCompileProp](shaderInfo);\n    }\n  };\n\n  const DerivedMaterial = function DerivedMaterial() {\n    return derive(options.chained ? baseMaterial : baseMaterial.clone())\n  };\n\n  const derive = function(base) {\n    // Prototype chain to the base material\n    const derived = Object.create(base, descriptor);\n\n    // Store the baseMaterial for reference; this is always the original even when cloning\n    Object.defineProperty(derived, 'baseMaterial', { value: baseMaterial });\n\n    // Needs its own ids\n    Object.defineProperty(derived, 'id', { value: materialInstanceId++ });\n    derived.uuid = generateUUID();\n\n    // Merge uniforms, defines, and extensions\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\n    derived.defines = assign({}, base.defines, options.defines);\n    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material\n    derived.extensions = assign({}, base.extensions, options.extensions);\n\n    // Don't inherit EventDispatcher listeners\n    derived._listeners = undefined;\n\n    return derived\n  };\n\n  const descriptor = {\n    constructor: {value: DerivedMaterial},\n    isDerivedMaterial: {value: true},\n\n    customProgramCacheKey: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        return baseMaterial.customProgramCacheKey() + '|' + optionsKey\n      }\n    },\n\n    onBeforeCompile: {\n      get() {\n        return onBeforeCompile\n      },\n      set(fn) {\n        this[privateBeforeCompileProp] = fn;\n      }\n    },\n\n    copy: {\n      writable: true,\n      configurable: true,\n      value: function (source) {\n        baseMaterial.copy.call(this, source);\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n          assign(this.extensions, source.extensions);\n          assign(this.defines, source.defines);\n          assign(this.uniforms, three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.clone(source.uniforms));\n        }\n        return this\n      }\n    },\n\n    clone: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        const newBase = new baseMaterial.constructor();\n        return derive(newBase).copy(this)\n      }\n    },\n\n    /**\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDepthMaterial: {\n      writable: true,\n      configurable: true,\n      value: function() {\n        let depthMaterial = this._depthMaterial;\n        if (!depthMaterial) {\n          depthMaterial = this._depthMaterial = createDerivedMaterial(\n            baseMaterial.isDerivedMaterial\n              ? baseMaterial.getDepthMaterial()\n              : new three__WEBPACK_IMPORTED_MODULE_0__.MeshDepthMaterial({ depthPacking: three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking }),\n            options\n          );\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return depthMaterial\n      }\n    },\n\n    /**\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDistanceMaterial: {\n      writable: true,\n      configurable: true,\n      value: function() {\n        let distanceMaterial = this._distanceMaterial;\n        if (!distanceMaterial) {\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(\n            baseMaterial.isDerivedMaterial\n              ? baseMaterial.getDistanceMaterial()\n              : new three__WEBPACK_IMPORTED_MODULE_0__.MeshDistanceMaterial(),\n            options\n          );\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return distanceMaterial\n      }\n    },\n\n    dispose: {\n      writable: true,\n      configurable: true,\n      value() {\n        const {_depthMaterial, _distanceMaterial} = this;\n        if (_depthMaterial) _depthMaterial.dispose();\n        if (_distanceMaterial) _distanceMaterial.dispose();\n        baseMaterial.dispose.call(this);\n      }\n    }\n  };\n\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\n  return new DerivedMaterial()\n}\n\n\nfunction upgradeShaders(material, {vertexShader, fragmentShader}, options, key) {\n  let {\n    vertexDefs,\n    vertexMainIntro,\n    vertexMainOutro,\n    vertexTransform,\n    fragmentDefs,\n    fragmentMainIntro,\n    fragmentMainOutro,\n    fragmentColorTransform,\n    customRewriter,\n    timeUniform\n  } = options;\n\n  vertexDefs = vertexDefs || '';\n  vertexMainIntro = vertexMainIntro || '';\n  vertexMainOutro = vertexMainOutro || '';\n  fragmentDefs = fragmentDefs || '';\n  fragmentMainIntro = fragmentMainIntro || '';\n  fragmentMainOutro = fragmentMainOutro || '';\n\n  // Expand includes if needed\n  if (vertexTransform || customRewriter) {\n    vertexShader = expandShaderIncludes(vertexShader);\n  }\n  if (fragmentColorTransform || customRewriter) {\n    // We need to be able to find postprocessing chunks after include expansion in order to\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n    // so we still mark them.\n    fragmentShader = fragmentShader.replace(\n      /^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,\n      '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n'\n    );\n    fragmentShader = expandShaderIncludes(fragmentShader);\n  }\n\n  // Apply custom rewriter function\n  if (customRewriter) {\n    let res = customRewriter({vertexShader, fragmentShader});\n    vertexShader = res.vertexShader;\n    fragmentShader = res.fragmentShader;\n  }\n\n  // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n  // those and re-insert them into the outro in the correct place:\n  if (fragmentColorTransform) {\n    let postChunks = [];\n    fragmentShader = fragmentShader.replace(\n      /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n      match => {\n        postChunks.push(match);\n        return ''\n      }\n    );\n    fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;\n  }\n\n  // Inject auto-updating time uniform if requested\n  if (timeUniform) {\n    const code = `\\nuniform float ${timeUniform};\\n`;\n    vertexDefs = code + vertexDefs;\n    fragmentDefs = code + fragmentDefs;\n  }\n\n  // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n  if (vertexTransform) {\n    // Hoist these defs to the very top so they work in other function defs\n    vertexShader = `vec3 troika_position_${key};\nvec3 troika_normal_${key};\nvec2 troika_uv_${key};\n${vertexShader}\n`;\n    vertexDefs = `${vertexDefs}\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${vertexTransform}\n}\n`;\n    vertexMainIntro = `\ntroika_position_${key} = vec3(position);\ntroika_normal_${key} = vec3(normal);\ntroika_uv_${key} = vec2(uv);\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\n${vertexMainIntro}\n`;\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`\n    });\n\n    // Three r152 introduced the MAP_UV token, replace it too if it's pointing to the main 'uv'\n    // Perhaps the other textures too going forward?\n    if (!(material.map && material.map.channel > 0)) {\n      vertexShader = vertexShader.replace(/\\bMAP_UV\\b/g, `troika_uv_${key}`);\n    }\n  }\n\n  // Inject defs and intro/outro snippets\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n\n  return {\n    vertexShader,\n    fragmentShader\n  }\n}\n\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n  if (intro || outro || defs) {\n    shaderCode = shaderCode.replace(voidMainRegExp, `\n${defs}\nvoid troikaOrigMain${id}() {`\n    );\n    shaderCode += `\nvoid main() {\n  ${intro}\n  troikaOrigMain${id}();\n  ${outro}\n}`;\n  }\n  return shaderCode\n}\n\n\nfunction optionsJsonReplacer(key, value) {\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value\n}\n\nlet _idCtr = 0;\nconst optionsHashesToIds = new Map();\nfunction getKeyForOptions(options) {\n  const optionsHash = JSON.stringify(options, optionsJsonReplacer);\n  let id = optionsHashesToIds.get(optionsHash);\n  if (id == null) {\n    optionsHashesToIds.set(optionsHash, (id = ++_idCtr));\n  }\n  return id\n}\n\n// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n// TODO how can we keep this from getting stale?\nconst MATERIAL_TYPES_TO_SHADERS = {\n  MeshDepthMaterial: 'depth',\n  MeshDistanceMaterial: 'distanceRGBA',\n  MeshNormalMaterial: 'normal',\n  MeshBasicMaterial: 'basic',\n  MeshLambertMaterial: 'lambert',\n  MeshPhongMaterial: 'phong',\n  MeshToonMaterial: 'toon',\n  MeshStandardMaterial: 'physical',\n  MeshPhysicalMaterial: 'physical',\n  MeshMatcapMaterial: 'matcap',\n  LineBasicMaterial: 'basic',\n  LineDashedMaterial: 'dashed',\n  PointsMaterial: 'points',\n  ShadowMaterial: 'shadow',\n  SpriteMaterial: 'sprite'\n};\n\n/**\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n * used to render that material.\n *\n * @param material - the Material instance\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n */\nfunction getShadersForMaterial(material) {\n  let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n  return builtinType ? three__WEBPACK_IMPORTED_MODULE_0__.ShaderLib[builtinType] : material //TODO fallback for unknown type?\n}\n\n/**\n * Find all uniforms and their types within a shader code string.\n *\n * @param {string} shader - The shader code to parse\n * @return {object} mapping of uniform names to their glsl type\n */\nfunction getShaderUniformTypes(shader) {\n  let uniformRE = /\\buniform\\s+(int|float|vec[234]|mat[34])\\s+([A-Za-z_][\\w]*)/g;\n  let uniforms = Object.create(null);\n  let match;\n  while ((match = uniformRE.exec(shader)) !== null) {\n    uniforms[match[2]] = match[1];\n  }\n  return uniforms\n}\n\n/**\n * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion\n * that happened in ThreeJS r123.\n * @param {Matrix4} srcMatrix\n * @param {Matrix4} [tgtMatrix]\n */\nfunction invertMatrix4(srcMatrix, tgtMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()) {\n  if (typeof tgtMatrix.invert === 'function') {\n    tgtMatrix.copy(srcMatrix).invert();\n  } else {\n    tgtMatrix.getInverse(srcMatrix);\n  }\n  return tgtMatrix\n}\n\n/*\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\ndivided into a reasonable number of height segments.\n*/\n\nconst vertexDefs = `\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n`;\n\nconst vertexTransform = `\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won't see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n`;\n\nconst fragmentDefs = `\nuniform vec3 dashing;\nvarying float bezierT;\n`;\n\nconst fragmentMainIntro = `\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n`;\n\n// Debugging: separate color for each of the 6 sides:\n// const fragmentColorTransform = `\n// float sideNum = floor(vUV.x * 6.0);\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n//   vec3(1.0, 0.0, 1.0);\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n// `\n\n\n\nfunction createBezierMeshMaterial(baseMaterial) {\n  return createDerivedMaterial(\n    baseMaterial,\n    {\n      chained: true,\n      uniforms: {\n        pointA: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        controlA: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        controlB: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        pointB: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        radius: {value: 0.01},\n        dashing: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()} //on, off, offset\n      },\n      vertexDefs,\n      vertexTransform,\n      fragmentDefs,\n      fragmentMainIntro\n    }\n  )\n}\n\nlet geometry = null;\n\nconst defaultBaseMaterial = /*#__PURE__*/new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({color: 0xffffff, side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide});\n\n\n/**\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n * automatically.\n *\n * The cubiz bezier path is determined by its four `Vector3` properties:\n * - `pointA`\n * - `controlA`\n * - `controlB`\n * - `pointB`\n *\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n *\n * You can also give the tube a dashed appearance with two properties:\n *\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n *   used as input to the cubic bezier function, not its visible length.)\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n *\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n * thicker tubes.\n *\n * TODO: proper geometry bounding sphere and raycasting\n * TODO: allow control of the geometry's segment counts\n */\nclass BezierMesh extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n  static getGeometry() {\n    return geometry || (geometry =\n      new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\n    )\n  }\n\n  constructor() {\n    super(\n      BezierMesh.getGeometry(),\n      defaultBaseMaterial\n    );\n\n    this.pointA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.controlA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.controlB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.pointB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.radius = 0.01;\n    this.dashArray = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this.dashOffset = 0;\n\n    // TODO - disabling frustum culling until I figure out how to customize the\n    //  geometry's bounding sphere that gets used\n    this.frustumCulled = false;\n  }\n\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n  get material() {\n    let derivedMaterial = this._derivedMaterial;\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n      derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n      // dispose the derived material when its base material is disposed:\n      baseMaterial.addEventListener('dispose', function onDispose() {\n        baseMaterial.removeEventListener('dispose', onDispose);\n        derivedMaterial.dispose();\n      });\n    }\n    return derivedMaterial\n  }\n  set material(baseMaterial) {\n    this._baseMaterial = baseMaterial;\n  }\n\n  // Create and update material for shadows upon request:\n  get customDepthMaterial() {\n    return this.material.getDepthMaterial()\n  }\n  get customDistanceMaterial() {\n    return this.material.getDistanceMaterial()\n  }\n\n  onBeforeRender() {\n    const {uniforms} = this.material;\n    const {pointA, controlA, controlB, pointB, radius, dashArray, dashOffset} = this;\n    uniforms.pointA.value.copy(pointA);\n    uniforms.controlA.value.copy(controlA);\n    uniforms.controlB.value.copy(controlB);\n    uniforms.pointB.value.copy(pointB);\n    uniforms.radius.value = radius;\n    uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n  }\n\n  raycast(/*raycaster, intersects*/) {\n    // TODO - just fail for now\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL3Ryb2lrYS10aHJlZS11dGlscy9kaXN0L3Ryb2lrYS10aHJlZS11dGlscy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBOE07O0FBRTlNO0FBQ0EscURBQXFEO0FBQ3JELFVBQVU7QUFDVjtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUSxrRUFBa0Usa0JBQWtCO0FBQ3ZHLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FB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QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxtRUFBbUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWdKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90cm9pa2EtdGhyZWUtdXRpbHMvZGlzdC90cm9pa2EtdGhyZWUtdXRpbHMuZXNtLmpzP2ExNzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2hhZGVyQ2h1bmssIFVuaWZvcm1zVXRpbHMsIE1lc2hEZXB0aE1hdGVyaWFsLCBSR0JBRGVwdGhQYWNraW5nLCBNZXNoRGlzdGFuY2VNYXRlcmlhbCwgU2hhZGVyTGliLCBNYXRyaXg0LCBWZWN0b3IzLCBNZXNoLCBDeWxpbmRlckdlb21ldHJ5LCBWZWN0b3IyLCBNZXNoU3RhbmRhcmRNYXRlcmlhbCwgRG91YmxlU2lkZSB9IGZyb20gJ3RocmVlJztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nIHRoZSBgdm9pZCBtYWluKCkge2Agb3BlbmVyIGxpbmUgaW4gR0xTTC5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmNvbnN0IHZvaWRNYWluUmVnRXhwID0gL1xcYnZvaWRcXHMrbWFpblxccypcXChcXHMqXFwpXFxzKnsvZztcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBleHBhbmRzIGFsbCBgI2luY2x1ZGUgPHh5ej5gIHN0YXRlbWVudHMgd2l0aGluIHN0cmluZyBvZiBzaGFkZXIgY29kZS5cbiAqIENvcGllZCBmcm9tIHRocmVlJ3MgV2ViR0xQcm9ncmFtI3BhcnNlSW5jbHVkZXMgZm9yIGV4dGVybmFsIHVzZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIC0gVGhlIEdMU0wgc291cmNlIGNvZGUgdG8gZXZhbHVhdGVcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEdMU0wgY29kZSB3aXRoIGFsbCBpbmNsdWRlcyBleHBhbmRlZFxuICovXG5mdW5jdGlvbiBleHBhbmRTaGFkZXJJbmNsdWRlcyggc291cmNlICkge1xuICBjb25zdCBwYXR0ZXJuID0gL15bIFxcdF0qI2luY2x1ZGUgKzwoW1xcd1xcZC4vXSspPi9nbTtcbiAgZnVuY3Rpb24gcmVwbGFjZShtYXRjaCwgaW5jbHVkZSkge1xuICAgIGxldCBjaHVuayA9IFNoYWRlckNodW5rW2luY2x1ZGVdO1xuICAgIHJldHVybiBjaHVuayA/IGV4cGFuZFNoYWRlckluY2x1ZGVzKGNodW5rKSA6IG1hdGNoXG4gIH1cbiAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKCBwYXR0ZXJuLCByZXBsYWNlIClcbn1cblxuLypcbiAqIFRoaXMgaXMgYSBkaXJlY3QgY29weSBvZiBNYXRoVXRpbHMuZ2VuZXJhdGVVVUlEIGZyb20gVGhyZWUuanMsIHRvIHByZXNlcnZlIGNvbXBhdGliaWxpdHkgd2l0aCB0aHJlZVxuICogdmVyc2lvbnMgYmVmb3JlIDAuMTEzLjAgYXMgaXQgd2FzIGNoYW5nZWQgZnJvbSBNYXRoIHRvIE1hdGhVdGlscyBpbiB0aGF0IHZlcnNpb24uXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2Jsb2IvZGQ4YjVhYTNiMjcwYzE3MDk2YjkwOTQ1Y2QyZDZkMWIxM2FhZWM1My9zcmMvbWF0aC9NYXRoVXRpbHMuanMjTDE2XG4gKi9cblxuY29uc3QgX2x1dCA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gIF9sdXRbaV0gPSAoaSA8IDE2ID8gJzAnIDogJycpICsgKGkpLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCkge1xuXG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC8yMTk2MzEzNiMyMTk2MzEzNlxuXG4gIGNvbnN0IGQwID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICBjb25zdCBkMSA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgY29uc3QgZDIgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gIGNvbnN0IGQzID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICBjb25zdCB1dWlkID0gX2x1dFtkMCAmIDB4ZmZdICsgX2x1dFtkMCA+PiA4ICYgMHhmZl0gKyBfbHV0W2QwID4+IDE2ICYgMHhmZl0gKyBfbHV0W2QwID4+IDI0ICYgMHhmZl0gKyAnLScgK1xuICAgIF9sdXRbZDEgJiAweGZmXSArIF9sdXRbZDEgPj4gOCAmIDB4ZmZdICsgJy0nICsgX2x1dFtkMSA+PiAxNiAmIDB4MGYgfCAweDQwXSArIF9sdXRbZDEgPj4gMjQgJiAweGZmXSArICctJyArXG4gICAgX2x1dFtkMiAmIDB4M2YgfCAweDgwXSArIF9sdXRbZDIgPj4gOCAmIDB4ZmZdICsgJy0nICsgX2x1dFtkMiA+PiAxNiAmIDB4ZmZdICsgX2x1dFtkMiA+PiAyNCAmIDB4ZmZdICtcbiAgICBfbHV0W2QzICYgMHhmZl0gKyBfbHV0W2QzID4+IDggJiAweGZmXSArIF9sdXRbZDMgPj4gMTYgJiAweGZmXSArIF9sdXRbZDMgPj4gMjQgJiAweGZmXTtcblxuICAvLyAudG9VcHBlckNhc2UoKSBoZXJlIGZsYXR0ZW5zIGNvbmNhdGVuYXRlZCBzdHJpbmdzIHRvIHNhdmUgaGVhcCBtZW1vcnkgc3BhY2UuXG4gIHJldHVybiB1dWlkLnRvVXBwZXJDYXNlKClcblxufVxuXG4vLyBMb2NhbCBhc3NpZ24gcG9seWZpbGwgdG8gYXZvaWQgaW1wb3J0aW5nIHRyb2lrYS1jb3JlXG5jb25zdCBhc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKC8qdGFyZ2V0LCAuLi5zb3VyY2VzKi8pIHtcbiAgbGV0IHRhcmdldCA9IGFyZ3VtZW50c1swXTtcbiAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGxldCBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgZm9yIChsZXQgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXRcbn07XG5cblxuY29uc3QgZXBvY2ggPSBEYXRlLm5vdygpO1xuY29uc3QgQ09OU1RSVUNUT1JfQ0FDSEUgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgU0hBREVSX1VQR1JBREVfQ0FDSEUgPSBuZXcgTWFwKCk7XG5cbi8vIE1hdGVyaWFsIGlkcyBtdXN0IGJlIGludGVnZXJzLCBidXQgd2UgY2FuJ3QgYWNjZXNzIHRoZSBpbmNyZW1lbnQgZnJvbSBUaHJlZSdzIGBNYXRlcmlhbGAgbW9kdWxlLFxuLy8gc28gbGV0J3MgY2hvb3NlIGEgc3VmZmljaWVudGx5IGxhcmdlIHN0YXJ0aW5nIHZhbHVlIHRoYXQgc2hvdWxkIHRoZW9yZXRpY2FsbHkgbmV2ZXIgY29sbGlkZS5cbmxldCBtYXRlcmlhbEluc3RhbmNlSWQgPSAxZTEwO1xuXG4vKipcbiAqIEEgdXRpbGl0eSBmb3IgY3JlYXRpbmcgYSBjdXN0b20gc2hhZGVyIG1hdGVyaWFsIGRlcml2ZWQgZnJvbSBhbm90aGVyIG1hdGVyaWFsJ3NcbiAqIHNoYWRlcnMuIFRoaXMgYWxsb3dzIHlvdSB0byBpbmplY3QgY3VzdG9tIHNoYWRlciBsb2dpYyBhbmQgdHJhbnNmb3JtcyBpbnRvIHRoZVxuICogYnVpbHRpbiBUaHJlZUpTIG1hdGVyaWFscyB3aXRob3V0IGhhdmluZyB0byByZWNyZWF0ZSB0aGVtIGZyb20gc2NyYXRjaC5cbiAqXG4gKiBAcGFyYW0ge1RIUkVFLk1hdGVyaWFsfSBiYXNlTWF0ZXJpYWwgLSB0aGUgb3JpZ2luYWwgbWF0ZXJpYWwgdG8gZGVyaXZlIGZyb21cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEhvdyB0aGUgYmFzZSBtYXRlcmlhbCBzaG91bGQgYmUgbW9kaWZpZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5kZWZpbmVzIC0gQ3VzdG9tIGBkZWZpbmVzYCBmb3IgdGhlIG1hdGVyaWFsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5leHRlbnNpb25zIC0gQ3VzdG9tIGBleHRlbnNpb25zYCBmb3IgdGhlIG1hdGVyaWFsLCBlLmcuIGB7ZGVyaXZhdGl2ZXM6IHRydWV9YFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMudW5pZm9ybXMgLSBDdXN0b20gYHVuaWZvcm1zYCBmb3IgdXNlIGluIHRoZSBtb2RpZmllZCBzaGFkZXIuIFRoZXNlIGNhblxuICogICAgICAgIGJlIGFjY2Vzc2VkIGFuZCBtYW5pcHVsYXRlZCB2aWEgdGhlIHJlc3VsdGluZyBtYXRlcmlhbCdzIGB1bmlmb3Jtc2AgcHJvcGVydHksIGp1c3QgbGlrZVxuICogICAgICAgIGluIGEgU2hhZGVyTWF0ZXJpYWwuIFlvdSBkbyBub3QgbmVlZCB0byByZXBlYXQgdGhlIGJhc2UgbWF0ZXJpYWwncyBvd24gdW5pZm9ybXMgaGVyZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRpbWVVbmlmb3JtIC0gSWYgc3BlY2lmaWVkLCBhIHVuaWZvcm0gb2YgdGhpcyBuYW1lIHdpbGwgYmUgaW5qZWN0ZWQgaW50b1xuICogICAgICAgIGJvdGggc2hhZGVycywgYW5kIGl0IHdpbGwgYXV0b21hdGljYWxseSBiZSB1cGRhdGVkIG9uIGVhY2ggcmVuZGVyIGZyYW1lIHdpdGggYSBudW1iZXIgb2ZcbiAqICAgICAgICBlbGFwc2VkIG1pbGxpc2Vjb25kcy4gVGhlIFwiemVyb1wiIGVwb2NoIHRpbWUgaXMgbm90IHNpZ25pZmljYW50IHNvIGRvbid0IHJlbHkgb24gdGhpcyBhcyBhXG4gKiAgICAgICAgdHJ1ZSBjYWxlbmRhciB0aW1lLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudmVydGV4RGVmcyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGludG8gdGhlIHZlcnRleCBzaGFkZXIncyB0b3AtbGV2ZWxcbiAqICAgICAgICBkZWZpbml0aW9ucywgYWJvdmUgdGhlIGB2b2lkIG1haW4oKWAgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy52ZXJ0ZXhNYWluSW50cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgdG9wIG9mIHRoZSB2ZXJ0ZXhcbiAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnZlcnRleE1haW5PdXRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSBlbmQgb2YgdGhlIHZlcnRleFxuICogICAgICAgIHNoYWRlcidzIGB2b2lkIG1haW5gIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudmVydGV4VHJhbnNmb3JtIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBtYW5pcHVsYXRlIHRoZSBgcG9zaXRpb25gLCBgbm9ybWFsYCxcbiAqICAgICAgICBhbmQvb3IgYHV2YCB2ZXJ0ZXggYXR0cmlidXRlcy4gVGhpcyBjb2RlIHdpbGwgYmUgd3JhcHBlZCB3aXRoaW4gYSBzdGFuZGFsb25lIGZ1bmN0aW9uIHdpdGhcbiAqICAgICAgICB0aG9zZSBhdHRyaWJ1dGVzIGV4cG9zZWQgYnkgdGhlaXIgbm9ybWFsIG5hbWVzIGFzIHJlYWQvd3JpdGUgdmFsdWVzLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZnJhZ21lbnREZWZzIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgaW50byB0aGUgZnJhZ21lbnQgc2hhZGVyJ3MgdG9wLWxldmVsXG4gKiAgICAgICAgZGVmaW5pdGlvbnMsIGFib3ZlIHRoZSBgdm9pZCBtYWluKClgIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZnJhZ21lbnRNYWluSW50cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgdG9wIG9mIHRoZSBmcmFnbWVudFxuICogICAgICAgIHNoYWRlcidzIGB2b2lkIG1haW5gIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuZnJhZ21lbnRNYWluT3V0cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudFxuICogICAgICAgIHNoYWRlcidzIGB2b2lkIG1haW5gIGZ1bmN0aW9uLiBZb3UgY2FuIG1hbmlwdWxhdGUgYGdsX0ZyYWdDb2xvcmAgaGVyZSBidXQga2VlcCBpbiBtaW5kIGl0IGdvZXNcbiAqICAgICAgICBhZnRlciBhbnkgb2YgVGhyZWVKUydzIGNvbG9yIHBvc3Rwcm9jZXNzaW5nIHNoYWRlciBjaHVua3MgKHRvbmVtYXBwaW5nLCBmb2csIGV0Yy4pLCBzbyBpZiB5b3VcbiAqICAgICAgICB3YW50IHRob3NlIHRvIGFwcGx5IHRvIHlvdXIgY2hhbmdlcyB1c2UgYGZyYWdtZW50Q29sb3JUcmFuc2Zvcm1gIGluc3RlYWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5mcmFnbWVudENvbG9yVHJhbnNmb3JtIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBtYW5pcHVsYXRlIHRoZSBgZ2xfRnJhZ0NvbG9yYFxuICogICAgICAgIG91dHB1dCB2YWx1ZS4gV2lsbCBiZSBpbmplY3RlZCBuZWFyIHRoZSBlbmQgb2YgdGhlIGB2b2lkIG1haW5gIGZ1bmN0aW9uLCBidXQgYmVmb3JlIGFueVxuICogICAgICAgIG9mIFRocmVlSlMncyBjb2xvciBwb3N0cHJvY2Vzc2luZyBzaGFkZXIgY2h1bmtzICh0b25lbWFwcGluZywgZm9nLCBldGMuKSwgYW5kIGJlZm9yZSB0aGVcbiAqICAgICAgICBgZnJhZ21lbnRNYWluT3V0cm9gLlxuICogQHBhcmFtIHtmdW5jdGlvbjx7dmVydGV4U2hhZGVyLGZyYWdtZW50U2hhZGVyfT46e3ZlcnRleFNoYWRlcixmcmFnbWVudFNoYWRlcn19IG9wdGlvbnMuY3VzdG9tUmV3cml0ZXIgLSBBIGZ1bmN0aW9uXG4gKiAgICAgICAgZm9yIHBlcmZvcm1pbmcgY3VzdG9tIHJld3JpdGVzIG9mIHRoZSBmdWxsIHNoYWRlciBjb2RlLiBVc2VmdWwgaWYgeW91IG5lZWQgdG8gZG8gc29tZXRoaW5nXG4gKiAgICAgICAgc3BlY2lhbCB0aGF0J3Mgbm90IGNvdmVyZWQgYnkgdGhlIG90aGVyIGJ1aWx0aW4gb3B0aW9ucy4gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGV4ZWN1dGVkIGJlZm9yZVxuICogICAgICAgIGFueSBvdGhlciB0cmFuc2Zvcm1zIGFyZSBhcHBsaWVkLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNoYWluZWQgLSBTZXQgdG8gYHRydWVgIHRvIHByb3RvdHlwZS1jaGFpbiB0aGUgZGVyaXZlZCBtYXRlcmlhbCB0byB0aGUgYmFzZVxuICogICAgICAgIG1hdGVyaWFsLCByYXRoZXIgdGhhbiB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBjb3B5aW5nIGl0LiBUaGlzIGFsbG93cyB0aGUgZGVyaXZlZCBtYXRlcmlhbCB0b1xuICogICAgICAgIGF1dG9tYXRpY2FsbHkgcGljayB1cCBjaGFuZ2VzIG1hZGUgdG8gdGhlIGJhc2UgbWF0ZXJpYWwgYW5kIGl0cyBwcm9wZXJ0aWVzLiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAqICAgICAgICB3aGVyZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCBpcyBoaWRkZW4gZnJvbSB0aGUgdXNlciBhcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwsIGFsbG93aW5nIHRoZW1cbiAqICAgICAgICB0byB3b3JrIHdpdGggdGhlIG9yaWdpbmFsIG1hdGVyaWFsIGxpa2Ugbm9ybWFsLiBCdXQgaXQgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW9yIGlmIG5vdFxuICogICAgICAgIGhhbmRsZWQgY2FyZWZ1bGx5LlxuICpcbiAqIEByZXR1cm4ge1RIUkVFLk1hdGVyaWFsfVxuICpcbiAqIFRoZSByZXR1cm5lZCBtYXRlcmlhbCB3aWxsIGFsc28gaGF2ZSB0d28gbmV3IG1ldGhvZHMsIGBnZXREZXB0aE1hdGVyaWFsKClgIGFuZCBgZ2V0RGlzdGFuY2VNYXRlcmlhbCgpYCxcbiAqIHdoaWNoIGNhbiBiZSBjYWxsZWQgdG8gZ2V0IGEgdmFyaWFudCBvZiB0aGUgZGVyaXZlZCBtYXRlcmlhbCBmb3IgdXNlIGluIHNoYWRvdyBjYXN0aW5nLiBJZiB0aGVcbiAqIHRhcmdldCBtZXNoIGlzIGV4cGVjdGVkIHRvIGNhc3Qgc2hhZG93cywgdGhlbiB5b3UgY2FuIGFzc2lnbiB0aGVzZSB0byB0aGUgbWVzaCdzIGBjdXN0b21EZXB0aE1hdGVyaWFsYFxuICogKGZvciBkaXJlY3Rpb25hbCBhbmQgc3BvdCBsaWdodHMpIGFuZC9vciBgY3VzdG9tRGlzdGFuY2VNYXRlcmlhbGAgKGZvciBwb2ludCBsaWdodHMpIHByb3BlcnRpZXMgdG9cbiAqIGFsbG93IHRoZSBjYXN0IHNoYWRvdyB0byBob25vciB5b3VyIGRlcml2ZWQgc2hhZGVyJ3MgdmVydGV4IHRyYW5zZm9ybXMgYW5kIGRpc2NhcmRlZCBmcmFnbWVudHMuIFRoZXNlXG4gKiB3aWxsIGFsc28gc2V0IGEgY3VzdG9tIGAjZGVmaW5lIElTX0RFUFRIX01BVEVSSUFMYCBvciBgI2RlZmluZSBJU19ESVNUQU5DRV9NQVRFUklBTGAgdGhhdCB5b3UgY2FuIGxvb2tcbiAqIGZvciBpbiB5b3VyIGRlcml2ZWQgc2hhZGVycyB3aXRoIGAjaWZkZWZgIHRvIGN1c3RvbWl6ZSB0aGVpciBiZWhhdmlvciBmb3IgdGhlIGRlcHRoIG9yIGRpc3RhbmNlXG4gKiBzY2VuYXJpb3MsIGUuZy4gc2tpcHBpbmcgYW50aWFsaWFzaW5nIG9yIGV4cGVuc2l2ZSBzaGFkZXIgbG9naWMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwsIG9wdGlvbnMpIHtcbiAgLy8gR2VuZXJhdGUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIGNvbnRlbnQgb2YgdGhlc2UgYG9wdGlvbnNgLiBXZSdsbCB1c2UgdGhpc1xuICAvLyB0aHJvdWdob3V0IGZvciBjYWNoaW5nIGFuZCBmb3IgZ2VuZXJhdGluZyB0aGUgdXBncmFkZWQgc2hhZGVyIGNvZGUuIFRoaXMgaW5jcmVhc2VzXG4gIC8vIHRoZSBsaWtlbGlob29kIHRoYXQgdGhlIHJlc3VsdGluZyBzaGFkZXJzIHdpbGwgbGluZSB1cCBhY3Jvc3MgbXVsdGlwbGUgY2FsbHMgc29cbiAgLy8gdGhlaXIgR0wgcHJvZ3JhbXMgY2FuIGJlIHNoYXJlZCBhbmQgY2FjaGVkLlxuICBjb25zdCBvcHRpb25zS2V5ID0gZ2V0S2V5Rm9yT3B0aW9ucyhvcHRpb25zKTtcblxuICAvLyBGaXJzdCBjaGVjayB0byBzZWUgaWYgd2UndmUgYWxyZWFkeSBkZXJpdmVkIGZyb20gdGhpcyBiYXNlTWF0ZXJpYWwgdXNpbmcgdGhpc1xuICAvLyB1bmlxdWUgc2V0IG9mIG9wdGlvbnMsIGFuZCBpZiBzbyByZXVzZSB0aGUgY29uc3RydWN0b3IgdG8gYXZvaWQgc29tZSBhbGxvY2F0aW9ucy5cbiAgbGV0IGN0b3JzQnlEZXJpdmF0aW9uID0gQ09OU1RSVUNUT1JfQ0FDSEUuZ2V0KGJhc2VNYXRlcmlhbCk7XG4gIGlmICghY3RvcnNCeURlcml2YXRpb24pIHtcbiAgICBDT05TVFJVQ1RPUl9DQUNIRS5zZXQoYmFzZU1hdGVyaWFsLCAoY3RvcnNCeURlcml2YXRpb24gPSBPYmplY3QuY3JlYXRlKG51bGwpKSk7XG4gIH1cbiAgaWYgKGN0b3JzQnlEZXJpdmF0aW9uW29wdGlvbnNLZXldKSB7XG4gICAgcmV0dXJuIG5ldyBjdG9yc0J5RGVyaXZhdGlvbltvcHRpb25zS2V5XSgpXG4gIH1cblxuICBjb25zdCBwcml2YXRlQmVmb3JlQ29tcGlsZVByb3AgPSBgX29uQmVmb3JlQ29tcGlsZSR7b3B0aW9uc0tleX1gO1xuXG4gIC8vIFByaXZhdGUgb25CZWZvcmVDb21waWxlIGhhbmRsZXIgdGhhdCBpbmplY3RzIHRoZSBtb2RpZmllZCBzaGFkZXJzIGFuZCB1bmlmb3JtcyB3aGVuXG4gIC8vIHRoZSByZW5kZXJlciBzd2l0Y2hlcyB0byB0aGlzIG1hdGVyaWFsJ3MgcHJvZ3JhbVxuICBjb25zdCBvbkJlZm9yZUNvbXBpbGUgPSBmdW5jdGlvbiAoc2hhZGVySW5mbywgcmVuZGVyZXIpIHtcbiAgICBiYXNlTWF0ZXJpYWwub25CZWZvcmVDb21waWxlLmNhbGwodGhpcywgc2hhZGVySW5mbywgcmVuZGVyZXIpO1xuXG4gICAgLy8gVXBncmFkZSB0aGUgc2hhZGVycywgY2FjaGluZyB0aGUgcmVzdWx0IGJ5IGluY29taW5nIHNvdXJjZSBjb2RlXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmN1c3RvbVByb2dyYW1DYWNoZUtleSgpICsgJ3wnICsgc2hhZGVySW5mby52ZXJ0ZXhTaGFkZXIgKyAnfCcgKyBzaGFkZXJJbmZvLmZyYWdtZW50U2hhZGVyO1xuICAgIGxldCB1cGdyYWRlZFNoYWRlcnMgPSBTSEFERVJfVVBHUkFERV9DQUNIRVtjYWNoZUtleV07XG4gICAgaWYgKCF1cGdyYWRlZFNoYWRlcnMpIHtcbiAgICAgIGNvbnN0IHVwZ3JhZGVkID0gdXBncmFkZVNoYWRlcnModGhpcywgc2hhZGVySW5mbywgb3B0aW9ucywgb3B0aW9uc0tleSk7XG4gICAgICB1cGdyYWRlZFNoYWRlcnMgPSBTSEFERVJfVVBHUkFERV9DQUNIRVtjYWNoZUtleV0gPSB1cGdyYWRlZDtcbiAgICB9XG5cbiAgICAvLyBJbmplY3QgdXBncmFkZWQgc2hhZGVycyBhbmQgdW5pZm9ybXMgaW50byB0aGUgcHJvZ3JhbVxuICAgIHNoYWRlckluZm8udmVydGV4U2hhZGVyID0gdXBncmFkZWRTaGFkZXJzLnZlcnRleFNoYWRlcjtcbiAgICBzaGFkZXJJbmZvLmZyYWdtZW50U2hhZGVyID0gdXBncmFkZWRTaGFkZXJzLmZyYWdtZW50U2hhZGVyO1xuICAgIGFzc2lnbihzaGFkZXJJbmZvLnVuaWZvcm1zLCB0aGlzLnVuaWZvcm1zKTtcblxuICAgIC8vIEluamVjdCBhdXRvLXVwZGF0aW5nIHRpbWUgdW5pZm9ybSBpZiByZXF1ZXN0ZWRcbiAgICBpZiAob3B0aW9ucy50aW1lVW5pZm9ybSkge1xuICAgICAgc2hhZGVySW5mby51bmlmb3Jtc1tvcHRpb25zLnRpbWVVbmlmb3JtXSA9IHtcbiAgICAgICAgZ2V0IHZhbHVlKCkge3JldHVybiBEYXRlLm5vdygpIC0gZXBvY2h9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFVzZXJzIGNhbiBzdGlsbCBhZGQgdGhlaXIgb3duIGhhbmRsZXJzIG9uIHRvcCBvZiBvdXJzXG4gICAgaWYgKHRoaXNbcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wXSkge1xuICAgICAgdGhpc1twcml2YXRlQmVmb3JlQ29tcGlsZVByb3BdKHNoYWRlckluZm8pO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBEZXJpdmVkTWF0ZXJpYWwgPSBmdW5jdGlvbiBEZXJpdmVkTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIGRlcml2ZShvcHRpb25zLmNoYWluZWQgPyBiYXNlTWF0ZXJpYWwgOiBiYXNlTWF0ZXJpYWwuY2xvbmUoKSlcbiAgfTtcblxuICBjb25zdCBkZXJpdmUgPSBmdW5jdGlvbihiYXNlKSB7XG4gICAgLy8gUHJvdG90eXBlIGNoYWluIHRvIHRoZSBiYXNlIG1hdGVyaWFsXG4gICAgY29uc3QgZGVyaXZlZCA9IE9iamVjdC5jcmVhdGUoYmFzZSwgZGVzY3JpcHRvcik7XG5cbiAgICAvLyBTdG9yZSB0aGUgYmFzZU1hdGVyaWFsIGZvciByZWZlcmVuY2U7IHRoaXMgaXMgYWx3YXlzIHRoZSBvcmlnaW5hbCBldmVuIHdoZW4gY2xvbmluZ1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXJpdmVkLCAnYmFzZU1hdGVyaWFsJywgeyB2YWx1ZTogYmFzZU1hdGVyaWFsIH0pO1xuXG4gICAgLy8gTmVlZHMgaXRzIG93biBpZHNcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVyaXZlZCwgJ2lkJywgeyB2YWx1ZTogbWF0ZXJpYWxJbnN0YW5jZUlkKysgfSk7XG4gICAgZGVyaXZlZC51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICAvLyBNZXJnZSB1bmlmb3JtcywgZGVmaW5lcywgYW5kIGV4dGVuc2lvbnNcbiAgICBkZXJpdmVkLnVuaWZvcm1zID0gYXNzaWduKHt9LCBiYXNlLnVuaWZvcm1zLCBvcHRpb25zLnVuaWZvcm1zKTtcbiAgICBkZXJpdmVkLmRlZmluZXMgPSBhc3NpZ24oe30sIGJhc2UuZGVmaW5lcywgb3B0aW9ucy5kZWZpbmVzKTtcbiAgICBkZXJpdmVkLmRlZmluZXNbYFRST0lLQV9ERVJJVkVEX01BVEVSSUFMXyR7b3B0aW9uc0tleX1gXSA9ICcnOyAvL2ZvcmNlIGEgcHJvZ3JhbSBjaGFuZ2UgZnJvbSB0aGUgYmFzZSBtYXRlcmlhbFxuICAgIGRlcml2ZWQuZXh0ZW5zaW9ucyA9IGFzc2lnbih7fSwgYmFzZS5leHRlbnNpb25zLCBvcHRpb25zLmV4dGVuc2lvbnMpO1xuXG4gICAgLy8gRG9uJ3QgaW5oZXJpdCBFdmVudERpc3BhdGNoZXIgbGlzdGVuZXJzXG4gICAgZGVyaXZlZC5fbGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIGRlcml2ZWRcbiAgfTtcblxuICBjb25zdCBkZXNjcmlwdG9yID0ge1xuICAgIGNvbnN0cnVjdG9yOiB7dmFsdWU6IERlcml2ZWRNYXRlcmlhbH0sXG4gICAgaXNEZXJpdmVkTWF0ZXJpYWw6IHt2YWx1ZTogdHJ1ZX0sXG5cbiAgICBjdXN0b21Qcm9ncmFtQ2FjaGVLZXk6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VNYXRlcmlhbC5jdXN0b21Qcm9ncmFtQ2FjaGVLZXkoKSArICd8JyArIG9wdGlvbnNLZXlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25CZWZvcmVDb21waWxlOiB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBvbkJlZm9yZUNvbXBpbGVcbiAgICAgIH0sXG4gICAgICBzZXQoZm4pIHtcbiAgICAgICAgdGhpc1twcml2YXRlQmVmb3JlQ29tcGlsZVByb3BdID0gZm47XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvcHk6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgYmFzZU1hdGVyaWFsLmNvcHkuY2FsbCh0aGlzLCBzb3VyY2UpO1xuICAgICAgICBpZiAoIWJhc2VNYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsICYmICFiYXNlTWF0ZXJpYWwuaXNEZXJpdmVkTWF0ZXJpYWwpIHtcbiAgICAgICAgICBhc3NpZ24odGhpcy5leHRlbnNpb25zLCBzb3VyY2UuZXh0ZW5zaW9ucyk7XG4gICAgICAgICAgYXNzaWduKHRoaXMuZGVmaW5lcywgc291cmNlLmRlZmluZXMpO1xuICAgICAgICAgIGFzc2lnbih0aGlzLnVuaWZvcm1zLCBVbmlmb3Jtc1V0aWxzLmNsb25lKHNvdXJjZS51bmlmb3JtcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfSxcblxuICAgIGNsb25lOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG5ld0Jhc2UgPSBuZXcgYmFzZU1hdGVyaWFsLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgIHJldHVybiBkZXJpdmUobmV3QmFzZSkuY29weSh0aGlzKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IHRvIGdldCBhIE1lc2hEZXB0aE1hdGVyaWFsIHRoYXQgd2lsbCBob25vciB0aGlzIGRlcml2ZWQgbWF0ZXJpYWwncyB2ZXJ0ZXhcbiAgICAgKiB0cmFuc2Zvcm1hdGlvbnMgYW5kIGRpc2NhcmRlZCBmcmFnbWVudHMuXG4gICAgICovXG4gICAgZ2V0RGVwdGhNYXRlcmlhbDoge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGxldCBkZXB0aE1hdGVyaWFsID0gdGhpcy5fZGVwdGhNYXRlcmlhbDtcbiAgICAgICAgaWYgKCFkZXB0aE1hdGVyaWFsKSB7XG4gICAgICAgICAgZGVwdGhNYXRlcmlhbCA9IHRoaXMuX2RlcHRoTWF0ZXJpYWwgPSBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoXG4gICAgICAgICAgICBiYXNlTWF0ZXJpYWwuaXNEZXJpdmVkTWF0ZXJpYWxcbiAgICAgICAgICAgICAgPyBiYXNlTWF0ZXJpYWwuZ2V0RGVwdGhNYXRlcmlhbCgpXG4gICAgICAgICAgICAgIDogbmV3IE1lc2hEZXB0aE1hdGVyaWFsKHsgZGVwdGhQYWNraW5nOiBSR0JBRGVwdGhQYWNraW5nIH0pLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZGVwdGhNYXRlcmlhbC5kZWZpbmVzLklTX0RFUFRIX01BVEVSSUFMID0gJyc7XG4gICAgICAgICAgZGVwdGhNYXRlcmlhbC51bmlmb3JtcyA9IHRoaXMudW5pZm9ybXM7IC8vYXV0b21hdGljYWxseSByZWNpZXZlIHNhbWUgdW5pZm9ybSB2YWx1ZXNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVwdGhNYXRlcmlhbFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IHRvIGdldCBhIE1lc2hEaXN0YW5jZU1hdGVyaWFsIHRoYXQgd2lsbCBob25vciB0aGlzIGRlcml2ZWQgbWF0ZXJpYWwncyB2ZXJ0ZXhcbiAgICAgKiB0cmFuc2Zvcm1hdGlvbnMgYW5kIGRpc2NhcmRlZCBmcmFnbWVudHMuXG4gICAgICovXG4gICAgZ2V0RGlzdGFuY2VNYXRlcmlhbDoge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGxldCBkaXN0YW5jZU1hdGVyaWFsID0gdGhpcy5fZGlzdGFuY2VNYXRlcmlhbDtcbiAgICAgICAgaWYgKCFkaXN0YW5jZU1hdGVyaWFsKSB7XG4gICAgICAgICAgZGlzdGFuY2VNYXRlcmlhbCA9IHRoaXMuX2Rpc3RhbmNlTWF0ZXJpYWwgPSBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoXG4gICAgICAgICAgICBiYXNlTWF0ZXJpYWwuaXNEZXJpdmVkTWF0ZXJpYWxcbiAgICAgICAgICAgICAgPyBiYXNlTWF0ZXJpYWwuZ2V0RGlzdGFuY2VNYXRlcmlhbCgpXG4gICAgICAgICAgICAgIDogbmV3IE1lc2hEaXN0YW5jZU1hdGVyaWFsKCksXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaXN0YW5jZU1hdGVyaWFsLmRlZmluZXMuSVNfRElTVEFOQ0VfTUFURVJJQUwgPSAnJztcbiAgICAgICAgICBkaXN0YW5jZU1hdGVyaWFsLnVuaWZvcm1zID0gdGhpcy51bmlmb3JtczsgLy9hdXRvbWF0aWNhbGx5IHJlY2lldmUgc2FtZSB1bmlmb3JtIHZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXN0YW5jZU1hdGVyaWFsXG4gICAgICB9XG4gICAgfSxcblxuICAgIGRpc3Bvc2U6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHtfZGVwdGhNYXRlcmlhbCwgX2Rpc3RhbmNlTWF0ZXJpYWx9ID0gdGhpcztcbiAgICAgICAgaWYgKF9kZXB0aE1hdGVyaWFsKSBfZGVwdGhNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIGlmIChfZGlzdGFuY2VNYXRlcmlhbCkgX2Rpc3RhbmNlTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICBiYXNlTWF0ZXJpYWwuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjdG9yc0J5RGVyaXZhdGlvbltvcHRpb25zS2V5XSA9IERlcml2ZWRNYXRlcmlhbDtcbiAgcmV0dXJuIG5ldyBEZXJpdmVkTWF0ZXJpYWwoKVxufVxuXG5cbmZ1bmN0aW9uIHVwZ3JhZGVTaGFkZXJzKG1hdGVyaWFsLCB7dmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcn0sIG9wdGlvbnMsIGtleSkge1xuICBsZXQge1xuICAgIHZlcnRleERlZnMsXG4gICAgdmVydGV4TWFpbkludHJvLFxuICAgIHZlcnRleE1haW5PdXRybyxcbiAgICB2ZXJ0ZXhUcmFuc2Zvcm0sXG4gICAgZnJhZ21lbnREZWZzLFxuICAgIGZyYWdtZW50TWFpbkludHJvLFxuICAgIGZyYWdtZW50TWFpbk91dHJvLFxuICAgIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0sXG4gICAgY3VzdG9tUmV3cml0ZXIsXG4gICAgdGltZVVuaWZvcm1cbiAgfSA9IG9wdGlvbnM7XG5cbiAgdmVydGV4RGVmcyA9IHZlcnRleERlZnMgfHwgJyc7XG4gIHZlcnRleE1haW5JbnRybyA9IHZlcnRleE1haW5JbnRybyB8fCAnJztcbiAgdmVydGV4TWFpbk91dHJvID0gdmVydGV4TWFpbk91dHJvIHx8ICcnO1xuICBmcmFnbWVudERlZnMgPSBmcmFnbWVudERlZnMgfHwgJyc7XG4gIGZyYWdtZW50TWFpbkludHJvID0gZnJhZ21lbnRNYWluSW50cm8gfHwgJyc7XG4gIGZyYWdtZW50TWFpbk91dHJvID0gZnJhZ21lbnRNYWluT3V0cm8gfHwgJyc7XG5cbiAgLy8gRXhwYW5kIGluY2x1ZGVzIGlmIG5lZWRlZFxuICBpZiAodmVydGV4VHJhbnNmb3JtIHx8IGN1c3RvbVJld3JpdGVyKSB7XG4gICAgdmVydGV4U2hhZGVyID0gZXhwYW5kU2hhZGVySW5jbHVkZXModmVydGV4U2hhZGVyKTtcbiAgfVxuICBpZiAoZnJhZ21lbnRDb2xvclRyYW5zZm9ybSB8fCBjdXN0b21SZXdyaXRlcikge1xuICAgIC8vIFdlIG5lZWQgdG8gYmUgYWJsZSB0byBmaW5kIHBvc3Rwcm9jZXNzaW5nIGNodW5rcyBhZnRlciBpbmNsdWRlIGV4cGFuc2lvbiBpbiBvcmRlciB0b1xuICAgIC8vIHB1dCB0aGVtIGFmdGVyIHRoZSBmcmFnbWVudENvbG9yVHJhbnNmb3JtLCBzbyBtYXJrIHRoZW0gd2l0aCBjb21tZW50cyBmaXJzdC4gRXZlbiBpZlxuICAgIC8vIHRoaXMgcGFydGljdWxhciBkZXJpdmF0aW9uIGRvZXNuJ3QgaGF2ZSBhIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0sIG90aGVyIGRlcml2YXRpb25zIG1heSxcbiAgICAvLyBzbyB3ZSBzdGlsbCBtYXJrIHRoZW0uXG4gICAgZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlci5yZXBsYWNlKFxuICAgICAgL15bIFxcdF0qI2luY2x1ZGUgPCgoPzp0b25lbWFwcGluZ3xlbmNvZGluZ3N8Zm9nfHByZW11bHRpcGxpZWRfYWxwaGF8ZGl0aGVyaW5nKV9mcmFnbWVudCk+L2dtLFxuICAgICAgJ1xcbi8vIUJFR0lOX1BPU1RfQ0hVTksgJDFcXG4kJlxcbi8vIUVORF9QT1NUX0NIVU5LXFxuJ1xuICAgICk7XG4gICAgZnJhZ21lbnRTaGFkZXIgPSBleHBhbmRTaGFkZXJJbmNsdWRlcyhmcmFnbWVudFNoYWRlcik7XG4gIH1cblxuICAvLyBBcHBseSBjdXN0b20gcmV3cml0ZXIgZnVuY3Rpb25cbiAgaWYgKGN1c3RvbVJld3JpdGVyKSB7XG4gICAgbGV0IHJlcyA9IGN1c3RvbVJld3JpdGVyKHt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyfSk7XG4gICAgdmVydGV4U2hhZGVyID0gcmVzLnZlcnRleFNoYWRlcjtcbiAgICBmcmFnbWVudFNoYWRlciA9IHJlcy5mcmFnbWVudFNoYWRlcjtcbiAgfVxuXG4gIC8vIFRoZSBmcmFnbWVudENvbG9yVHJhbnNmb3JtIG5lZWRzIHRvIGdvIGJlZm9yZSBhbnkgcG9zdHByb2Nlc3NpbmcgY2h1bmtzLCBzbyBleHRyYWN0XG4gIC8vIHRob3NlIGFuZCByZS1pbnNlcnQgdGhlbSBpbnRvIHRoZSBvdXRybyBpbiB0aGUgY29ycmVjdCBwbGFjZTpcbiAgaWYgKGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0pIHtcbiAgICBsZXQgcG9zdENodW5rcyA9IFtdO1xuICAgIGZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXIucmVwbGFjZShcbiAgICAgIC9eXFwvXFwvIUJFR0lOX1BPU1RfQ0hVTktbXl0rP15cXC9cXC8hRU5EX1BPU1RfQ0hVTksvZ20sIC8vIFteXSs/ID0gbm9uLWdyZWVkeSBtYXRjaCBvZiBhbnkgY2hhcnMgaW5jbHVkaW5nIG5ld2xpbmVzXG4gICAgICBtYXRjaCA9PiB7XG4gICAgICAgIHBvc3RDaHVua3MucHVzaChtYXRjaCk7XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgfVxuICAgICk7XG4gICAgZnJhZ21lbnRNYWluT3V0cm8gPSBgJHtmcmFnbWVudENvbG9yVHJhbnNmb3JtfVxcbiR7cG9zdENodW5rcy5qb2luKCdcXG4nKX1cXG4ke2ZyYWdtZW50TWFpbk91dHJvfWA7XG4gIH1cblxuICAvLyBJbmplY3QgYXV0by11cGRhdGluZyB0aW1lIHVuaWZvcm0gaWYgcmVxdWVzdGVkXG4gIGlmICh0aW1lVW5pZm9ybSkge1xuICAgIGNvbnN0IGNvZGUgPSBgXFxudW5pZm9ybSBmbG9hdCAke3RpbWVVbmlmb3JtfTtcXG5gO1xuICAgIHZlcnRleERlZnMgPSBjb2RlICsgdmVydGV4RGVmcztcbiAgICBmcmFnbWVudERlZnMgPSBjb2RlICsgZnJhZ21lbnREZWZzO1xuICB9XG5cbiAgLy8gSW5qZWN0IGEgZnVuY3Rpb24gZm9yIHRoZSB2ZXJ0ZXhUcmFuc2Zvcm0gYW5kIHJlbmFtZSBhbGwgdXNhZ2VzIG9mIHBvc2l0aW9uL25vcm1hbC91dlxuICBpZiAodmVydGV4VHJhbnNmb3JtKSB7XG4gICAgLy8gSG9pc3QgdGhlc2UgZGVmcyB0byB0aGUgdmVyeSB0b3Agc28gdGhleSB3b3JrIGluIG90aGVyIGZ1bmN0aW9uIGRlZnNcbiAgICB2ZXJ0ZXhTaGFkZXIgPSBgdmVjMyB0cm9pa2FfcG9zaXRpb25fJHtrZXl9O1xudmVjMyB0cm9pa2Ffbm9ybWFsXyR7a2V5fTtcbnZlYzIgdHJvaWthX3V2XyR7a2V5fTtcbiR7dmVydGV4U2hhZGVyfVxuYDtcbiAgICB2ZXJ0ZXhEZWZzID0gYCR7dmVydGV4RGVmc31cbnZvaWQgdHJvaWthVmVydGV4VHJhbnNmb3JtJHtrZXl9KGlub3V0IHZlYzMgcG9zaXRpb24sIGlub3V0IHZlYzMgbm9ybWFsLCBpbm91dCB2ZWMyIHV2KSB7XG4gICR7dmVydGV4VHJhbnNmb3JtfVxufVxuYDtcbiAgICB2ZXJ0ZXhNYWluSW50cm8gPSBgXG50cm9pa2FfcG9zaXRpb25fJHtrZXl9ID0gdmVjMyhwb3NpdGlvbik7XG50cm9pa2Ffbm9ybWFsXyR7a2V5fSA9IHZlYzMobm9ybWFsKTtcbnRyb2lrYV91dl8ke2tleX0gPSB2ZWMyKHV2KTtcbnRyb2lrYVZlcnRleFRyYW5zZm9ybSR7a2V5fSh0cm9pa2FfcG9zaXRpb25fJHtrZXl9LCB0cm9pa2Ffbm9ybWFsXyR7a2V5fSwgdHJvaWthX3V2XyR7a2V5fSk7XG4ke3ZlcnRleE1haW5JbnRyb31cbmA7XG4gICAgdmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyLnJlcGxhY2UoL1xcYihwb3NpdGlvbnxub3JtYWx8dXYpXFxiL2csIChtYXRjaCwgbWF0Y2gxLCBpbmRleCwgZnVsbFN0cikgPT4ge1xuICAgICAgcmV0dXJuIC9cXGJhdHRyaWJ1dGVcXHMrdmVjWzIzXVxccyskLy50ZXN0KGZ1bGxTdHIuc3Vic3RyKDAsIGluZGV4KSkgPyBtYXRjaDEgOiBgdHJvaWthXyR7bWF0Y2gxfV8ke2tleX1gXG4gICAgfSk7XG5cbiAgICAvLyBUaHJlZSByMTUyIGludHJvZHVjZWQgdGhlIE1BUF9VViB0b2tlbiwgcmVwbGFjZSBpdCB0b28gaWYgaXQncyBwb2ludGluZyB0byB0aGUgbWFpbiAndXYnXG4gICAgLy8gUGVyaGFwcyB0aGUgb3RoZXIgdGV4dHVyZXMgdG9vIGdvaW5nIGZvcndhcmQ/XG4gICAgaWYgKCEobWF0ZXJpYWwubWFwICYmIG1hdGVyaWFsLm1hcC5jaGFubmVsID4gMCkpIHtcbiAgICAgIHZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlci5yZXBsYWNlKC9cXGJNQVBfVVZcXGIvZywgYHRyb2lrYV91dl8ke2tleX1gKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbmplY3QgZGVmcyBhbmQgaW50cm8vb3V0cm8gc25pcHBldHNcbiAgdmVydGV4U2hhZGVyID0gaW5qZWN0SW50b1NoYWRlckNvZGUodmVydGV4U2hhZGVyLCBrZXksIHZlcnRleERlZnMsIHZlcnRleE1haW5JbnRybywgdmVydGV4TWFpbk91dHJvKTtcbiAgZnJhZ21lbnRTaGFkZXIgPSBpbmplY3RJbnRvU2hhZGVyQ29kZShmcmFnbWVudFNoYWRlciwga2V5LCBmcmFnbWVudERlZnMsIGZyYWdtZW50TWFpbkludHJvLCBmcmFnbWVudE1haW5PdXRybyk7XG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJ0ZXhTaGFkZXIsXG4gICAgZnJhZ21lbnRTaGFkZXJcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmplY3RJbnRvU2hhZGVyQ29kZShzaGFkZXJDb2RlLCBpZCwgZGVmcywgaW50cm8sIG91dHJvKSB7XG4gIGlmIChpbnRybyB8fCBvdXRybyB8fCBkZWZzKSB7XG4gICAgc2hhZGVyQ29kZSA9IHNoYWRlckNvZGUucmVwbGFjZSh2b2lkTWFpblJlZ0V4cCwgYFxuJHtkZWZzfVxudm9pZCB0cm9pa2FPcmlnTWFpbiR7aWR9KCkge2BcbiAgICApO1xuICAgIHNoYWRlckNvZGUgKz0gYFxudm9pZCBtYWluKCkge1xuICAke2ludHJvfVxuICB0cm9pa2FPcmlnTWFpbiR7aWR9KCk7XG4gICR7b3V0cm99XG59YDtcbiAgfVxuICByZXR1cm4gc2hhZGVyQ29kZVxufVxuXG5cbmZ1bmN0aW9uIG9wdGlvbnNKc29uUmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4ga2V5ID09PSAndW5pZm9ybXMnID8gdW5kZWZpbmVkIDogdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlXG59XG5cbmxldCBfaWRDdHIgPSAwO1xuY29uc3Qgb3B0aW9uc0hhc2hlc1RvSWRzID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0S2V5Rm9yT3B0aW9ucyhvcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnNIYXNoID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucywgb3B0aW9uc0pzb25SZXBsYWNlcik7XG4gIGxldCBpZCA9IG9wdGlvbnNIYXNoZXNUb0lkcy5nZXQob3B0aW9uc0hhc2gpO1xuICBpZiAoaWQgPT0gbnVsbCkge1xuICAgIG9wdGlvbnNIYXNoZXNUb0lkcy5zZXQob3B0aW9uc0hhc2gsIChpZCA9ICsrX2lkQ3RyKSk7XG4gIH1cbiAgcmV0dXJuIGlkXG59XG5cbi8vIENvcGllZCBmcm9tIHRocmVlanMgV2ViR0xQcm9ncmFtcy5qcyBzbyB3ZSBjYW4gcmVzb2x2ZSBidWlsdGluIG1hdGVyaWFscyB0byB0aGVpciBzaGFkZXJzXG4vLyBUT0RPIGhvdyBjYW4gd2Uga2VlcCB0aGlzIGZyb20gZ2V0dGluZyBzdGFsZT9cbmNvbnN0IE1BVEVSSUFMX1RZUEVTX1RPX1NIQURFUlMgPSB7XG4gIE1lc2hEZXB0aE1hdGVyaWFsOiAnZGVwdGgnLFxuICBNZXNoRGlzdGFuY2VNYXRlcmlhbDogJ2Rpc3RhbmNlUkdCQScsXG4gIE1lc2hOb3JtYWxNYXRlcmlhbDogJ25vcm1hbCcsXG4gIE1lc2hCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuICBNZXNoTGFtYmVydE1hdGVyaWFsOiAnbGFtYmVydCcsXG4gIE1lc2hQaG9uZ01hdGVyaWFsOiAncGhvbmcnLFxuICBNZXNoVG9vbk1hdGVyaWFsOiAndG9vbicsXG4gIE1lc2hTdGFuZGFyZE1hdGVyaWFsOiAncGh5c2ljYWwnLFxuICBNZXNoUGh5c2ljYWxNYXRlcmlhbDogJ3BoeXNpY2FsJyxcbiAgTWVzaE1hdGNhcE1hdGVyaWFsOiAnbWF0Y2FwJyxcbiAgTGluZUJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXG4gIExpbmVEYXNoZWRNYXRlcmlhbDogJ2Rhc2hlZCcsXG4gIFBvaW50c01hdGVyaWFsOiAncG9pbnRzJyxcbiAgU2hhZG93TWF0ZXJpYWw6ICdzaGFkb3cnLFxuICBTcHJpdGVNYXRlcmlhbDogJ3Nwcml0ZSdcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBUaHJlZS5qcyBgTWF0ZXJpYWxgIGluc3RhbmNlLCBmaW5kIHRoZSBzaGFkZXJzL3VuaWZvcm1zIHRoYXQgd2lsbCBiZVxuICogdXNlZCB0byByZW5kZXIgdGhhdCBtYXRlcmlhbC5cbiAqXG4gKiBAcGFyYW0gbWF0ZXJpYWwgLSB0aGUgTWF0ZXJpYWwgaW5zdGFuY2VcbiAqIEByZXR1cm4ge29iamVjdH0gLSB0aGUgbWF0ZXJpYWwncyBzaGFkZXIgaW5mbzogYHt1bmlmb3Jtczp7fSwgZnJhZ21lbnRTaGFkZXI6JycsIHZlcnRleFNoYWRlcjonJ31gXG4gKi9cbmZ1bmN0aW9uIGdldFNoYWRlcnNGb3JNYXRlcmlhbChtYXRlcmlhbCkge1xuICBsZXQgYnVpbHRpblR5cGUgPSBNQVRFUklBTF9UWVBFU19UT19TSEFERVJTW21hdGVyaWFsLnR5cGVdO1xuICByZXR1cm4gYnVpbHRpblR5cGUgPyBTaGFkZXJMaWJbYnVpbHRpblR5cGVdIDogbWF0ZXJpYWwgLy9UT0RPIGZhbGxiYWNrIGZvciB1bmtub3duIHR5cGU/XG59XG5cbi8qKlxuICogRmluZCBhbGwgdW5pZm9ybXMgYW5kIHRoZWlyIHR5cGVzIHdpdGhpbiBhIHNoYWRlciBjb2RlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hhZGVyIC0gVGhlIHNoYWRlciBjb2RlIHRvIHBhcnNlXG4gKiBAcmV0dXJuIHtvYmplY3R9IG1hcHBpbmcgb2YgdW5pZm9ybSBuYW1lcyB0byB0aGVpciBnbHNsIHR5cGVcbiAqL1xuZnVuY3Rpb24gZ2V0U2hhZGVyVW5pZm9ybVR5cGVzKHNoYWRlcikge1xuICBsZXQgdW5pZm9ybVJFID0gL1xcYnVuaWZvcm1cXHMrKGludHxmbG9hdHx2ZWNbMjM0XXxtYXRbMzRdKVxccysoW0EtWmEtel9dW1xcd10qKS9nO1xuICBsZXQgdW5pZm9ybXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBsZXQgbWF0Y2g7XG4gIHdoaWxlICgobWF0Y2ggPSB1bmlmb3JtUkUuZXhlYyhzaGFkZXIpKSAhPT0gbnVsbCkge1xuICAgIHVuaWZvcm1zW21hdGNoWzJdXSA9IG1hdGNoWzFdO1xuICB9XG4gIHJldHVybiB1bmlmb3Jtc1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3Igc21vb3RoaW5nIG91dCB0aGUgYG0uZ2V0SW52ZXJzZSh4KWAgLS0+IGBtLmNvcHkoeCkuaW52ZXJ0KClgIGNvbnZlcnNpb25cbiAqIHRoYXQgaGFwcGVuZWQgaW4gVGhyZWVKUyByMTIzLlxuICogQHBhcmFtIHtNYXRyaXg0fSBzcmNNYXRyaXhcbiAqIEBwYXJhbSB7TWF0cml4NH0gW3RndE1hdHJpeF1cbiAqL1xuZnVuY3Rpb24gaW52ZXJ0TWF0cml4NChzcmNNYXRyaXgsIHRndE1hdHJpeCA9IG5ldyBNYXRyaXg0KCkpIHtcbiAgaWYgKHR5cGVvZiB0Z3RNYXRyaXguaW52ZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGd0TWF0cml4LmNvcHkoc3JjTWF0cml4KS5pbnZlcnQoKTtcbiAgfSBlbHNlIHtcbiAgICB0Z3RNYXRyaXguZ2V0SW52ZXJzZShzcmNNYXRyaXgpO1xuICB9XG4gIHJldHVybiB0Z3RNYXRyaXhcbn1cblxuLypcbklucHV0IGdlb21ldHJ5IGlzIGEgY3lsaW5kZXIgd2l0aCByPTEsIGhlaWdodCBpbiB5IGRpbWVuc2lvbiBmcm9tIDAgdG8gMSxcbmRpdmlkZWQgaW50byBhIHJlYXNvbmFibGUgbnVtYmVyIG9mIGhlaWdodCBzZWdtZW50cy5cbiovXG5cbmNvbnN0IHZlcnRleERlZnMgPSBgXG51bmlmb3JtIHZlYzMgcG9pbnRBO1xudW5pZm9ybSB2ZWMzIGNvbnRyb2xBO1xudW5pZm9ybSB2ZWMzIGNvbnRyb2xCO1xudW5pZm9ybSB2ZWMzIHBvaW50QjtcbnVuaWZvcm0gZmxvYXQgcmFkaXVzO1xudmFyeWluZyBmbG9hdCBiZXppZXJUO1xuXG52ZWMzIGN1YmljQmV6aWVyKHZlYzMgcDEsIHZlYzMgYzEsIHZlYzMgYzIsIHZlYzMgcDIsIGZsb2F0IHQpIHtcbiAgZmxvYXQgdDIgPSAxLjAgLSB0O1xuICBmbG9hdCBiMCA9IHQyICogdDIgKiB0MjtcbiAgZmxvYXQgYjEgPSAzLjAgKiB0ICogdDIgKiB0MjtcbiAgZmxvYXQgYjIgPSAzLjAgKiB0ICogdCAqIHQyO1xuICBmbG9hdCBiMyA9IHQgKiB0ICogdDtcbiAgcmV0dXJuIGIwICogcDEgKyBiMSAqIGMxICsgYjIgKiBjMiArIGIzICogcDI7XG59XG5cbnZlYzMgY3ViaWNCZXppZXJEZXJpdmF0aXZlKHZlYzMgcDEsIHZlYzMgYzEsIHZlYzMgYzIsIHZlYzMgcDIsIGZsb2F0IHQpIHtcbiAgZmxvYXQgdDIgPSAxLjAgLSB0O1xuICByZXR1cm4gLTMuMCAqIHAxICogdDIgKiB0MiArXG4gICAgYzEgKiAoMy4wICogdDIgKiB0MiAtIDYuMCAqIHQyICogdCkgK1xuICAgIGMyICogKDYuMCAqIHQyICogdCAtIDMuMCAqIHQgKiB0KSArXG4gICAgMy4wICogcDIgKiB0ICogdDtcbn1cbmA7XG5cbmNvbnN0IHZlcnRleFRyYW5zZm9ybSA9IGBcbmZsb2F0IHQgPSBwb3NpdGlvbi55O1xuYmV6aWVyVCA9IHQ7XG52ZWMzIGJlemllckNlbnRlclBvcyA9IGN1YmljQmV6aWVyKHBvaW50QSwgY29udHJvbEEsIGNvbnRyb2xCLCBwb2ludEIsIHQpO1xudmVjMyBiZXppZXJEaXIgPSBub3JtYWxpemUoY3ViaWNCZXppZXJEZXJpdmF0aXZlKHBvaW50QSwgY29udHJvbEEsIGNvbnRyb2xCLCBwb2ludEIsIHQpKTtcblxuLy8gTWFrZSBcInNpZGV3YXlzXCIgYWx3YXlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGNhbWVyYSByYXk7IHRoaXMgZW5zdXJlcyB0aGF0IGFueSB0d2lzdHNcbi8vIGluIHRoZSBjeWxpbmRlciBvY2N1ciB3aGVyZSB5b3Ugd29uJ3Qgc2VlIHRoZW06IFxudmVjMyB2aWV3RGlyZWN0aW9uID0gbm9ybWFsTWF0cml4ICogdmVjMygwLjAsIDAuMCwgMS4wKTtcbmlmIChiZXppZXJEaXIgPT0gdmlld0RpcmVjdGlvbikge1xuICBiZXppZXJEaXIgPSBub3JtYWxpemUoY3ViaWNCZXppZXJEZXJpdmF0aXZlKHBvaW50QSwgY29udHJvbEEsIGNvbnRyb2xCLCBwb2ludEIsIHQgPT0gMS4wID8gdCAtIDAuMDAwMSA6IHQgKyAwLjAwMDEpKTtcbn1cbnZlYzMgc2lkZXdheXMgPSBub3JtYWxpemUoY3Jvc3MoYmV6aWVyRGlyLCB2aWV3RGlyZWN0aW9uKSk7XG52ZWMzIHVwaXNoID0gbm9ybWFsaXplKGNyb3NzKHNpZGV3YXlzLCBiZXppZXJEaXIpKTtcblxuLy8gQnVpbGQgYSBtYXRyaXggZm9yIHRyYW5zZm9ybWluZyB0aGlzIGRpc2MgaW4gdGhlIGN5bGluZGVyOlxubWF0NCBkaXNjVHg7XG5kaXNjVHhbMF0ueHl6ID0gc2lkZXdheXMgKiByYWRpdXM7XG5kaXNjVHhbMV0ueHl6ID0gYmV6aWVyRGlyICogcmFkaXVzO1xuZGlzY1R4WzJdLnh5eiA9IHVwaXNoICogcmFkaXVzO1xuZGlzY1R4WzNdLnh5eiA9IGJlemllckNlbnRlclBvcztcbmRpc2NUeFszXVszXSA9IDEuMDtcblxuLy8gQXBwbHkgdHJhbnNmb3JtLCBpZ25vcmluZyBvcmlnaW5hbCB5XG5wb3NpdGlvbiA9IChkaXNjVHggKiB2ZWM0KHBvc2l0aW9uLngsIDAuMCwgcG9zaXRpb24ueiwgMS4wKSkueHl6O1xubm9ybWFsID0gbm9ybWFsaXplKG1hdDMoZGlzY1R4KSAqIG5vcm1hbCk7XG5gO1xuXG5jb25zdCBmcmFnbWVudERlZnMgPSBgXG51bmlmb3JtIHZlYzMgZGFzaGluZztcbnZhcnlpbmcgZmxvYXQgYmV6aWVyVDtcbmA7XG5cbmNvbnN0IGZyYWdtZW50TWFpbkludHJvID0gYFxuaWYgKGRhc2hpbmcueCArIGRhc2hpbmcueSA+IDAuMCkge1xuICBmbG9hdCBkYXNoRnJhYyA9IG1vZChiZXppZXJUIC0gZGFzaGluZy56LCBkYXNoaW5nLnggKyBkYXNoaW5nLnkpO1xuICBpZiAoZGFzaEZyYWMgPiBkYXNoaW5nLngpIHtcbiAgICBkaXNjYXJkO1xuICB9XG59XG5gO1xuXG4vLyBEZWJ1Z2dpbmc6IHNlcGFyYXRlIGNvbG9yIGZvciBlYWNoIG9mIHRoZSA2IHNpZGVzOlxuLy8gY29uc3QgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSA9IGBcbi8vIGZsb2F0IHNpZGVOdW0gPSBmbG9vcih2VVYueCAqIDYuMCk7XG4vLyB2ZWMzIG1peENvbG9yID0gc2lkZU51bSA8IDEuMCA/IHZlYzMoMS4wLCAwLjAsIDAuMCkgOlxuLy8gICBzaWRlTnVtIDwgMi4wID8gdmVjMygwLjAsIDEuMCwgMS4wKSA6XG4vLyAgIHNpZGVOdW0gPCAzLjAgPyB2ZWMzKDEuMCwgMS4wLCAwLjApIDpcbi8vICAgc2lkZU51bSA8IDQuMCA/IHZlYzMoMC4wLCAwLjAsIDEuMCkgOlxuLy8gICBzaWRlTnVtIDwgNS4wID8gdmVjMygwLjAsIDEuMCwgMC4wKSA6XG4vLyAgIHZlYzMoMS4wLCAwLjAsIDEuMCk7XG4vLyBnbF9GcmFnQ29sb3IueHl6ID0gbWl4KGdsX0ZyYWdDb2xvci54eXosIG1peENvbG9yLCAwLjUpO1xuLy8gYFxuXG5cblxuZnVuY3Rpb24gY3JlYXRlQmV6aWVyTWVzaE1hdGVyaWFsKGJhc2VNYXRlcmlhbCkge1xuICByZXR1cm4gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKFxuICAgIGJhc2VNYXRlcmlhbCxcbiAgICB7XG4gICAgICBjaGFpbmVkOiB0cnVlLFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgcG9pbnRBOiB7dmFsdWU6IG5ldyBWZWN0b3IzKCl9LFxuICAgICAgICBjb250cm9sQToge3ZhbHVlOiBuZXcgVmVjdG9yMygpfSxcbiAgICAgICAgY29udHJvbEI6IHt2YWx1ZTogbmV3IFZlY3RvcjMoKX0sXG4gICAgICAgIHBvaW50Qjoge3ZhbHVlOiBuZXcgVmVjdG9yMygpfSxcbiAgICAgICAgcmFkaXVzOiB7dmFsdWU6IDAuMDF9LFxuICAgICAgICBkYXNoaW5nOiB7dmFsdWU6IG5ldyBWZWN0b3IzKCl9IC8vb24sIG9mZiwgb2Zmc2V0XG4gICAgICB9LFxuICAgICAgdmVydGV4RGVmcyxcbiAgICAgIHZlcnRleFRyYW5zZm9ybSxcbiAgICAgIGZyYWdtZW50RGVmcyxcbiAgICAgIGZyYWdtZW50TWFpbkludHJvXG4gICAgfVxuICApXG59XG5cbmxldCBnZW9tZXRyeSA9IG51bGw7XG5cbmNvbnN0IGRlZmF1bHRCYXNlTWF0ZXJpYWwgPSAvKiNfX1BVUkVfXyovbmV3IE1lc2hTdGFuZGFyZE1hdGVyaWFsKHtjb2xvcjogMHhmZmZmZmYsIHNpZGU6IERvdWJsZVNpZGV9KTtcblxuXG4vKipcbiAqIEEgVGhyZWVKUyBgTWVzaGAgdGhhdCBiZW5kcyBhIHR1YmUgc2hhcGUgYWxvbmcgYSAzRCBjdWJpYyBiZXppZXIgcGF0aC4gVGhlIGJlbmRpbmcgaXMgZG9uZVxuICogYnkgZGVmb3JtaW5nIGEgc3RyYWlnaHQgY3lsaW5kcmljYWwgZ2VvbWV0cnkgaW4gdGhlIHZlcnRleCBzaGFkZXIgYmFzZWQgb24gYSBzZXQgb2YgZm91clxuICogY29udHJvbCBwb2ludCB1bmlmb3Jtcy4gSXQgcGF0Y2hlcyB0aGUgbmVjZXNzYXJ5IEdMU0wgaW50byB0aGUgbWVzaCdzIGFzc2lnbmVkIGBtYXRlcmlhbGBcbiAqIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogVGhlIGN1Yml6IGJlemllciBwYXRoIGlzIGRldGVybWluZWQgYnkgaXRzIGZvdXIgYFZlY3RvcjNgIHByb3BlcnRpZXM6XG4gKiAtIGBwb2ludEFgXG4gKiAtIGBjb250cm9sQWBcbiAqIC0gYGNvbnRyb2xCYFxuICogLSBgcG9pbnRCYFxuICpcbiAqIFRoZSB0dWJlJ3MgcmFkaXVzIGlzIGNvbnRyb2xsZWQgYnkgaXRzIGByYWRpdXNgIHByb3BlcnR5LCB3aGljaCBkZWZhdWx0cyB0byBgMC4wMWAuXG4gKlxuICogWW91IGNhbiBhbHNvIGdpdmUgdGhlIHR1YmUgYSBkYXNoZWQgYXBwZWFyYW5jZSB3aXRoIHR3byBwcm9wZXJ0aWVzOlxuICpcbiAqIC0gYGRhc2hBcnJheWAgLSBhbiBhcnJheSBvZiB0d28gbnVtYmVycywgZGVmaW5pbmcgdGhlIGxlbmd0aCBvZiBcIm9uXCIgYW5kIFwib2ZmXCIgcGFydHMgb2ZcbiAqICAgdGhlIGRhc2guIEVhY2ggaXMgYSAwLTEgcmF0aW8gb2YgdGhlIGVudGlyZSBwYXRoJ3MgbGVuZ3RoLiAoQWN0dWFsbHkgdGhpcyBpcyB0aGUgYHRgIGxlbmd0aFxuICogICB1c2VkIGFzIGlucHV0IHRvIHRoZSBjdWJpYyBiZXppZXIgZnVuY3Rpb24sIG5vdCBpdHMgdmlzaWJsZSBsZW5ndGguKVxuICogLSBgZGFzaE9mZnNldGAgLSBvZmZzZXQgb2Ygd2hlcmUgdGhlIGRhc2ggc3RhcnRzLiBZb3UgY2FuIGFuaW1hdGUgdGhpcyB0byBtYWtlIHRoZSBkYXNoZXMgbW92ZS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGRhc2hlcyB3aWxsIGFwcGVhciBsaWtlIGEgaG9sbG93IHR1YmUsIG5vdCBzb2xpZC4gVGhpcyB3aWxsIGJlIG1vcmUgYXBwYXJlbnQgb25cbiAqIHRoaWNrZXIgdHViZXMuXG4gKlxuICogVE9ETzogcHJvcGVyIGdlb21ldHJ5IGJvdW5kaW5nIHNwaGVyZSBhbmQgcmF5Y2FzdGluZ1xuICogVE9ETzogYWxsb3cgY29udHJvbCBvZiB0aGUgZ2VvbWV0cnkncyBzZWdtZW50IGNvdW50c1xuICovXG5jbGFzcyBCZXppZXJNZXNoIGV4dGVuZHMgTWVzaCB7XG4gIHN0YXRpYyBnZXRHZW9tZXRyeSgpIHtcbiAgICByZXR1cm4gZ2VvbWV0cnkgfHwgKGdlb21ldHJ5ID1cbiAgICAgIG5ldyBDeWxpbmRlckdlb21ldHJ5KDEsIDEsIDEsIDYsIDY0KS50cmFuc2xhdGUoMCwgMC41LCAwKVxuICAgIClcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFxuICAgICAgQmV6aWVyTWVzaC5nZXRHZW9tZXRyeSgpLFxuICAgICAgZGVmYXVsdEJhc2VNYXRlcmlhbFxuICAgICk7XG5cbiAgICB0aGlzLnBvaW50QSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jb250cm9sQSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5jb250cm9sQiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5wb2ludEIgPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMucmFkaXVzID0gMC4wMTtcbiAgICB0aGlzLmRhc2hBcnJheSA9IG5ldyBWZWN0b3IyKCk7XG4gICAgdGhpcy5kYXNoT2Zmc2V0ID0gMDtcblxuICAgIC8vIFRPRE8gLSBkaXNhYmxpbmcgZnJ1c3R1bSBjdWxsaW5nIHVudGlsIEkgZmlndXJlIG91dCBob3cgdG8gY3VzdG9taXplIHRoZVxuICAgIC8vICBnZW9tZXRyeSdzIGJvdW5kaW5nIHNwaGVyZSB0aGF0IGdldHMgdXNlZFxuICAgIHRoaXMuZnJ1c3R1bUN1bGxlZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSGFuZGxlciBmb3IgYXV0b21hdGljYWxseSB3cmFwcGluZyB0aGUgYmFzZSBtYXRlcmlhbCB3aXRoIG91ciB1cGdyYWRlcy4gV2UgZG8gdGhlIHdyYXBwaW5nXG4gIC8vIGxhemlseSBvbiBfcmVhZF8gcmF0aGVyIHRoYW4gd3JpdGUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd3JhcHBpbmcgb24gdHJhbnNpZW50IHZhbHVlcy5cbiAgZ2V0IG1hdGVyaWFsKCkge1xuICAgIGxldCBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWw7XG4gICAgY29uc3QgYmFzZU1hdGVyaWFsID0gdGhpcy5fYmFzZU1hdGVyaWFsIHx8IHRoaXMuX2RlZmF1bHRNYXRlcmlhbCB8fCAodGhpcy5fZGVmYXVsdE1hdGVyaWFsID0gZGVmYXVsdEJhc2VNYXRlcmlhbC5jbG9uZSgpKTtcbiAgICBpZiAoIWRlcml2ZWRNYXRlcmlhbCB8fCBkZXJpdmVkTWF0ZXJpYWwuYmFzZU1hdGVyaWFsICE9PSBiYXNlTWF0ZXJpYWwpIHtcbiAgICAgIGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbCA9IGNyZWF0ZUJlemllck1lc2hNYXRlcmlhbChiYXNlTWF0ZXJpYWwpO1xuICAgICAgLy8gZGlzcG9zZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCB3aGVuIGl0cyBiYXNlIG1hdGVyaWFsIGlzIGRpc3Bvc2VkOlxuICAgICAgYmFzZU1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBmdW5jdGlvbiBvbkRpc3Bvc2UoKSB7XG4gICAgICAgIGJhc2VNYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgb25EaXNwb3NlKTtcbiAgICAgICAgZGVyaXZlZE1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVyaXZlZE1hdGVyaWFsXG4gIH1cbiAgc2V0IG1hdGVyaWFsKGJhc2VNYXRlcmlhbCkge1xuICAgIHRoaXMuX2Jhc2VNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbDtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhbmQgdXBkYXRlIG1hdGVyaWFsIGZvciBzaGFkb3dzIHVwb24gcmVxdWVzdDpcbiAgZ2V0IGN1c3RvbURlcHRoTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0ZXJpYWwuZ2V0RGVwdGhNYXRlcmlhbCgpXG4gIH1cbiAgZ2V0IGN1c3RvbURpc3RhbmNlTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0ZXJpYWwuZ2V0RGlzdGFuY2VNYXRlcmlhbCgpXG4gIH1cblxuICBvbkJlZm9yZVJlbmRlcigpIHtcbiAgICBjb25zdCB7dW5pZm9ybXN9ID0gdGhpcy5tYXRlcmlhbDtcbiAgICBjb25zdCB7cG9pbnRBLCBjb250cm9sQSwgY29udHJvbEIsIHBvaW50QiwgcmFkaXVzLCBkYXNoQXJyYXksIGRhc2hPZmZzZXR9ID0gdGhpcztcbiAgICB1bmlmb3Jtcy5wb2ludEEudmFsdWUuY29weShwb2ludEEpO1xuICAgIHVuaWZvcm1zLmNvbnRyb2xBLnZhbHVlLmNvcHkoY29udHJvbEEpO1xuICAgIHVuaWZvcm1zLmNvbnRyb2xCLnZhbHVlLmNvcHkoY29udHJvbEIpO1xuICAgIHVuaWZvcm1zLnBvaW50Qi52YWx1ZS5jb3B5KHBvaW50Qik7XG4gICAgdW5pZm9ybXMucmFkaXVzLnZhbHVlID0gcmFkaXVzO1xuICAgIHVuaWZvcm1zLmRhc2hpbmcudmFsdWUuc2V0KGRhc2hBcnJheS54LCBkYXNoQXJyYXkueSwgZGFzaE9mZnNldCB8fCAwKTtcbiAgfVxuXG4gIHJheWNhc3QoLypyYXljYXN0ZXIsIGludGVyc2VjdHMqLykge1xuICAgIC8vIFRPRE8gLSBqdXN0IGZhaWwgZm9yIG5vd1xuICB9XG59XG5cbmV4cG9ydCB7IEJlemllck1lc2gsIGNyZWF0ZURlcml2ZWRNYXRlcmlhbCwgZXhwYW5kU2hhZGVySW5jbHVkZXMsIGdldFNoYWRlclVuaWZvcm1UeXBlcywgZ2V0U2hhZGVyc0Zvck1hdGVyaWFsLCBpbnZlcnRNYXRyaXg0LCB2b2lkTWFpblJlZ0V4cCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineWorkerModule: function() { return /* binding */ defineWorkerModule; },\n/* harmony export */   stringifyFunction: function() { return /* binding */ stringifyFunction; },\n/* harmony export */   terminateWorker: function() { return /* binding */ terminateWorker; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-client)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * Main content for the worker that handles the loading and execution of\n * modules within it.\n */\nfunction workerBootstrap() {\n  var modules = Object.create(null);\n\n  // Handle messages for registering a module\n  function registerModule(ref, callback) {\n    var id = ref.id;\n    var name = ref.name;\n    var dependencies = ref.dependencies; if ( dependencies === void 0 ) dependencies = [];\n    var init = ref.init; if ( init === void 0 ) init = function(){};\n    var getTransferables = ref.getTransferables; if ( getTransferables === void 0 ) getTransferables = null;\n\n    // Only register once\n    if (modules[id]) { return }\n\n    try {\n      // If any dependencies are modules, ensure they're registered and grab their value\n      dependencies = dependencies.map(function (dep) {\n        if (dep && dep.isWorkerModule) {\n          registerModule(dep, function (depResult) {\n            if (depResult instanceof Error) { throw depResult }\n          });\n          dep = modules[dep.id].value;\n        }\n        return dep\n      });\n\n      // Rehydrate functions\n      init = rehydrate((\"<\" + name + \">.init\"), init);\n      if (getTransferables) {\n        getTransferables = rehydrate((\"<\" + name + \">.getTransferables\"), getTransferables);\n      }\n\n      // Initialize the module and store its value\n      var value = null;\n      if (typeof init === 'function') {\n        value = init.apply(void 0, dependencies);\n      } else {\n        console.error('worker module init function failed to rehydrate');\n      }\n      modules[id] = {\n        id: id,\n        value: value,\n        getTransferables: getTransferables\n      };\n      callback(value);\n    } catch(err) {\n      if (!(err && err.noLog)) {\n        console.error(err);\n      }\n      callback(err);\n    }\n  }\n\n  // Handle messages for calling a registered module's result function\n  function callModule(ref, callback) {\n    var ref$1;\n\n    var id = ref.id;\n    var args = ref.args;\n    if (!modules[id] || typeof modules[id].value !== 'function') {\n      callback(new Error((\"Worker module \" + id + \": not found or its 'init' did not return a function\")));\n    }\n    try {\n      var result = (ref$1 = modules[id]).value.apply(ref$1, args);\n      if (result && typeof result.then === 'function') {\n        result.then(handleResult, function (rej) { return callback(rej instanceof Error ? rej : new Error('' + rej)); });\n      } else {\n        handleResult(result);\n      }\n    } catch(err) {\n      callback(err);\n    }\n    function handleResult(result) {\n      try {\n        var tx = modules[id].getTransferables && modules[id].getTransferables(result);\n        if (!tx || !Array.isArray(tx) || !tx.length) {\n          tx = undefined; //postMessage is very picky about not passing null or empty transferables\n        }\n        callback(result, tx);\n      } catch(err) {\n        console.error(err);\n        callback(err);\n      }\n    }\n  }\n\n  function rehydrate(name, str) {\n    var result = void 0;\n    self.troikaDefine = function (r) { return result = r; };\n    var url = URL.createObjectURL(\n      new Blob(\n        [(\"/** \" + (name.replace(/\\*/g, '')) + \" **/\\n\\ntroikaDefine(\\n\" + str + \"\\n)\")],\n        {type: 'application/javascript'}\n      )\n    );\n    try {\n      importScripts(url);\n    } catch(err) {\n      console.error(err);\n    }\n    URL.revokeObjectURL(url);\n    delete self.troikaDefine;\n    return result\n  }\n\n  // Handler for all messages within the worker\n  self.addEventListener('message', function (e) {\n    var ref = e.data;\n    var messageId = ref.messageId;\n    var action = ref.action;\n    var data = ref.data;\n    try {\n      // Module registration\n      if (action === 'registerModule') {\n        registerModule(data, function (result) {\n          if (result instanceof Error) {\n            postMessage({\n              messageId: messageId,\n              success: false,\n              error: result.message\n            });\n          } else {\n            postMessage({\n              messageId: messageId,\n              success: true,\n              result: {isCallable: typeof result === 'function'}\n            });\n          }\n        });\n      }\n      // Invocation\n      if (action === 'callModule') {\n        callModule(data, function (result, transferables) {\n          if (result instanceof Error) {\n            postMessage({\n              messageId: messageId,\n              success: false,\n              error: result.message\n            });\n          } else {\n            postMessage({\n              messageId: messageId,\n              success: true,\n              result: result\n            }, transferables || undefined);\n          }\n        });\n      }\n    } catch(err) {\n      postMessage({\n        messageId: messageId,\n        success: false,\n        error: err.stack\n      });\n    }\n  });\n}\n\n/**\n * Fallback for `defineWorkerModule` that behaves identically but runs in the main\n * thread, for when the execution environment doesn't support web workers or they\n * are disallowed due to e.g. CSP security restrictions.\n */\nfunction defineMainThreadModule(options) {\n  var moduleFunc = function() {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    return moduleFunc._getInitResult().then(function (initResult) {\n      if (typeof initResult === 'function') {\n        return initResult.apply(void 0, args)\n      } else {\n        throw new Error('Worker module function was called but `init` did not return a callable function')\n      }\n    })\n  };\n  moduleFunc._getInitResult = function() {\n    // We can ignore getTransferables in main thread. TODO workerId?\n    var dependencies = options.dependencies;\n    var init = options.init;\n\n    // Resolve dependencies\n    dependencies = Array.isArray(dependencies) ? dependencies.map(function (dep) { return dep && dep._getInitResult ? dep._getInitResult() : dep; }\n    ) : [];\n\n    // Invoke init with the resolved dependencies\n    var initPromise = Promise.all(dependencies).then(function (deps) {\n      return init.apply(null, deps)\n    });\n\n    // Cache the resolved promise for subsequent calls\n    moduleFunc._getInitResult = function () { return initPromise; };\n\n    return initPromise\n  };\n  return moduleFunc\n}\n\nvar supportsWorkers = function () {\n  var supported = false;\n\n  // Only attempt worker initialization in browsers; elsewhere it would just be\n  // noise e.g. loading into a Node environment for SSR.\n  if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {\n    try {\n      // TODO additional checks for things like importScripts within the worker?\n      //  Would need to be an async check.\n      var worker = new Worker(\n        URL.createObjectURL(new Blob([''], { type: 'application/javascript' }))\n      );\n      worker.terminate();\n      supported = true;\n    } catch (err) {\n      if (typeof process !== 'undefined' && \"development\" === 'test') {} else {\n        console.log(\n          (\"Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [\" + (err.message) + \"]\")\n        );\n      }\n    }\n  }\n\n  // Cached result\n  supportsWorkers = function () { return supported; };\n  return supported\n};\n\nvar _workerModuleId = 0;\nvar _messageId = 0;\nvar _allowInitAsString = false;\nvar workers = Object.create(null);\nvar registeredModules = Object.create(null); //workerId -> Set<unregisterFn>\nvar openRequests = Object.create(null);\n\n\n/**\n * Define a module of code that will be executed with a web worker. This provides a simple\n * interface for moving chunks of logic off the main thread, and managing their dependencies\n * among one another.\n *\n * @param {object} options\n * @param {function} options.init\n * @param {array} [options.dependencies]\n * @param {function} [options.getTransferables]\n * @param {string} [options.name]\n * @param {string} [options.workerId]\n * @return {function(...[*]): {then}}\n */\nfunction defineWorkerModule(options) {\n  if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {\n    throw new Error('requires `options.init` function')\n  }\n  var dependencies = options.dependencies;\n  var init = options.init;\n  var getTransferables = options.getTransferables;\n  var workerId = options.workerId;\n\n  if (!supportsWorkers()) {\n    return defineMainThreadModule(options)\n  }\n\n  if (workerId == null) {\n    workerId = '#default';\n  }\n  var id = \"workerModule\" + (++_workerModuleId);\n  var name = options.name || id;\n  var registrationPromise = null;\n\n  dependencies = dependencies && dependencies.map(function (dep) {\n    // Wrap raw functions as worker modules with no dependencies\n    if (typeof dep === 'function' && !dep.workerModuleData) {\n      _allowInitAsString = true;\n      dep = defineWorkerModule({\n        workerId: workerId,\n        name: (\"<\" + name + \"> function dependency: \" + (dep.name)),\n        init: (\"function(){return (\\n\" + (stringifyFunction(dep)) + \"\\n)}\")\n      });\n      _allowInitAsString = false;\n    }\n    // Grab postable data for worker modules\n    if (dep && dep.workerModuleData) {\n      dep = dep.workerModuleData;\n    }\n    return dep\n  });\n\n  function moduleFunc() {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    // Register this module if needed\n    if (!registrationPromise) {\n      registrationPromise = callWorker(workerId,'registerModule', moduleFunc.workerModuleData);\n      var unregister = function () {\n        registrationPromise = null;\n        registeredModules[workerId].delete(unregister);\n      }\n      ;(registeredModules[workerId] || (registeredModules[workerId] = new Set())).add(unregister);\n    }\n\n    // Invoke the module, returning a promise\n    return registrationPromise.then(function (ref) {\n      var isCallable = ref.isCallable;\n\n      if (isCallable) {\n        return callWorker(workerId,'callModule', {id: id, args: args})\n      } else {\n        throw new Error('Worker module function was called but `init` did not return a callable function')\n      }\n    })\n  }\n  moduleFunc.workerModuleData = {\n    isWorkerModule: true,\n    id: id,\n    name: name,\n    dependencies: dependencies,\n    init: stringifyFunction(init),\n    getTransferables: getTransferables && stringifyFunction(getTransferables)\n  };\n  return moduleFunc\n}\n\n/**\n * Terminate an active Worker by a workerId that was passed to defineWorkerModule.\n * This only terminates the Worker itself; the worker module will remain available\n * and if you call it again its Worker will be respawned.\n * @param {string} workerId\n */\nfunction terminateWorker(workerId) {\n  // Unregister all modules that were registered in that worker\n  if (registeredModules[workerId]) {\n    registeredModules[workerId].forEach(function (unregister) {\n      unregister();\n    });\n  }\n  // Terminate the Worker object\n  if (workers[workerId]) {\n    workers[workerId].terminate();\n    delete workers[workerId];\n  }\n}\n\n/**\n * Stringifies a function into a form that can be deserialized in the worker\n * @param fn\n */\nfunction stringifyFunction(fn) {\n  var str = fn.toString();\n  // If it was defined in object method/property format, it needs to be modified\n  if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {\n    str = 'function ' + str;\n  }\n  return str\n}\n\n\nfunction getWorker(workerId) {\n  var worker = workers[workerId];\n  if (!worker) {\n    // Bootstrap the worker's content\n    var bootstrap = stringifyFunction(workerBootstrap);\n\n    // Create the worker from the bootstrap function content\n    worker = workers[workerId] = new Worker(\n      URL.createObjectURL(\n        new Blob(\n          [(\"/** Worker Module Bootstrap: \" + (workerId.replace(/\\*/g, '')) + \" **/\\n\\n;(\" + bootstrap + \")()\")],\n          {type: 'application/javascript'}\n        )\n      )\n    );\n\n    // Single handler for response messages from the worker\n    worker.onmessage = function (e) {\n      var response = e.data;\n      var msgId = response.messageId;\n      var callback = openRequests[msgId];\n      if (!callback) {\n        throw new Error('WorkerModule response with empty or unknown messageId')\n      }\n      delete openRequests[msgId];\n      callback(response);\n    };\n  }\n  return worker\n}\n\n// Issue a call to the worker with a callback to handle the response\nfunction callWorker(workerId, action, data) {\n  return new Promise(function (resolve, reject) {\n    var messageId = ++_messageId;\n    openRequests[messageId] = function (response) {\n      if (response.success) {\n        resolve(response.result);\n      } else {\n        reject(new Error((\"Error in worker \" + action + \" call: \" + (response.error))));\n      }\n    };\n    getWorker(workerId).postMessage({\n      messageId: messageId,\n      action: action,\n      data: data\n    });\n  })\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL3Ryb2lrYS13b3JrZXItdXRpbHMvZGlzdC90cm9pa2Etd29ya2VyLXV0aWxzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLHlCQUF5QjtBQUN6QixpREFBaUQ7O0FBRWpEO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsb0VBQW9FO0FBQ3ZILFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQ0FBZ0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGlCQUFpQixPQUFPLG9CQUFvQixhQUFvQixhQUFhLEVBQUMsQ0FBQztBQUMvRTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOENBQThDO0FBQ3pFLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRCxtQkFBbUI7QUFDckUsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEYsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFa0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Ryb2lrYS13b3JrZXItdXRpbHMvZGlzdC90cm9pa2Etd29ya2VyLXV0aWxzLmVzbS5qcz8xM2Y5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTWFpbiBjb250ZW50IGZvciB0aGUgd29ya2VyIHRoYXQgaGFuZGxlcyB0aGUgbG9hZGluZyBhbmQgZXhlY3V0aW9uIG9mXG4gKiBtb2R1bGVzIHdpdGhpbiBpdC5cbiAqL1xuZnVuY3Rpb24gd29ya2VyQm9vdHN0cmFwKCkge1xuICB2YXIgbW9kdWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy8gSGFuZGxlIG1lc3NhZ2VzIGZvciByZWdpc3RlcmluZyBhIG1vZHVsZVxuICBmdW5jdGlvbiByZWdpc3Rlck1vZHVsZShyZWYsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGlkID0gcmVmLmlkO1xuICAgIHZhciBuYW1lID0gcmVmLm5hbWU7XG4gICAgdmFyIGRlcGVuZGVuY2llcyA9IHJlZi5kZXBlbmRlbmNpZXM7IGlmICggZGVwZW5kZW5jaWVzID09PSB2b2lkIDAgKSBkZXBlbmRlbmNpZXMgPSBbXTtcbiAgICB2YXIgaW5pdCA9IHJlZi5pbml0OyBpZiAoIGluaXQgPT09IHZvaWQgMCApIGluaXQgPSBmdW5jdGlvbigpe307XG4gICAgdmFyIGdldFRyYW5zZmVyYWJsZXMgPSByZWYuZ2V0VHJhbnNmZXJhYmxlczsgaWYgKCBnZXRUcmFuc2ZlcmFibGVzID09PSB2b2lkIDAgKSBnZXRUcmFuc2ZlcmFibGVzID0gbnVsbDtcblxuICAgIC8vIE9ubHkgcmVnaXN0ZXIgb25jZVxuICAgIGlmIChtb2R1bGVzW2lkXSkgeyByZXR1cm4gfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIElmIGFueSBkZXBlbmRlbmNpZXMgYXJlIG1vZHVsZXMsIGVuc3VyZSB0aGV5J3JlIHJlZ2lzdGVyZWQgYW5kIGdyYWIgdGhlaXIgdmFsdWVcbiAgICAgIGRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcy5tYXAoZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICBpZiAoZGVwICYmIGRlcC5pc1dvcmtlck1vZHVsZSkge1xuICAgICAgICAgIHJlZ2lzdGVyTW9kdWxlKGRlcCwgZnVuY3Rpb24gKGRlcFJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlcFJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7IHRocm93IGRlcFJlc3VsdCB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVwID0gbW9kdWxlc1tkZXAuaWRdLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXBcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZWh5ZHJhdGUgZnVuY3Rpb25zXG4gICAgICBpbml0ID0gcmVoeWRyYXRlKChcIjxcIiArIG5hbWUgKyBcIj4uaW5pdFwiKSwgaW5pdCk7XG4gICAgICBpZiAoZ2V0VHJhbnNmZXJhYmxlcykge1xuICAgICAgICBnZXRUcmFuc2ZlcmFibGVzID0gcmVoeWRyYXRlKChcIjxcIiArIG5hbWUgKyBcIj4uZ2V0VHJhbnNmZXJhYmxlc1wiKSwgZ2V0VHJhbnNmZXJhYmxlcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEluaXRpYWxpemUgdGhlIG1vZHVsZSBhbmQgc3RvcmUgaXRzIHZhbHVlXG4gICAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBpbml0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gaW5pdC5hcHBseSh2b2lkIDAsIGRlcGVuZGVuY2llcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCd3b3JrZXIgbW9kdWxlIGluaXQgZnVuY3Rpb24gZmFpbGVkIHRvIHJlaHlkcmF0ZScpO1xuICAgICAgfVxuICAgICAgbW9kdWxlc1tpZF0gPSB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBnZXRUcmFuc2ZlcmFibGVzOiBnZXRUcmFuc2ZlcmFibGVzXG4gICAgICB9O1xuICAgICAgY2FsbGJhY2sodmFsdWUpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICBpZiAoIShlcnIgJiYgZXJyLm5vTG9nKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBtZXNzYWdlcyBmb3IgY2FsbGluZyBhIHJlZ2lzdGVyZWQgbW9kdWxlJ3MgcmVzdWx0IGZ1bmN0aW9uXG4gIGZ1bmN0aW9uIGNhbGxNb2R1bGUocmVmLCBjYWxsYmFjaykge1xuICAgIHZhciByZWYkMTtcblxuICAgIHZhciBpZCA9IHJlZi5pZDtcbiAgICB2YXIgYXJncyA9IHJlZi5hcmdzO1xuICAgIGlmICghbW9kdWxlc1tpZF0gfHwgdHlwZW9mIG1vZHVsZXNbaWRdLnZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3IoKFwiV29ya2VyIG1vZHVsZSBcIiArIGlkICsgXCI6IG5vdCBmb3VuZCBvciBpdHMgJ2luaXQnIGRpZCBub3QgcmV0dXJuIGEgZnVuY3Rpb25cIikpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXN1bHQgPSAocmVmJDEgPSBtb2R1bGVzW2lkXSkudmFsdWUuYXBwbHkocmVmJDEsIGFyZ3MpO1xuICAgICAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzdWx0LnRoZW4oaGFuZGxlUmVzdWx0LCBmdW5jdGlvbiAocmVqKSB7IHJldHVybiBjYWxsYmFjayhyZWogaW5zdGFuY2VvZiBFcnJvciA/IHJlaiA6IG5ldyBFcnJvcignJyArIHJlaikpOyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZVJlc3VsdChyZXN1bHQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSZXN1bHQocmVzdWx0KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdHggPSBtb2R1bGVzW2lkXS5nZXRUcmFuc2ZlcmFibGVzICYmIG1vZHVsZXNbaWRdLmdldFRyYW5zZmVyYWJsZXMocmVzdWx0KTtcbiAgICAgICAgaWYgKCF0eCB8fCAhQXJyYXkuaXNBcnJheSh0eCkgfHwgIXR4Lmxlbmd0aCkge1xuICAgICAgICAgIHR4ID0gdW5kZWZpbmVkOyAvL3Bvc3RNZXNzYWdlIGlzIHZlcnkgcGlja3kgYWJvdXQgbm90IHBhc3NpbmcgbnVsbCBvciBlbXB0eSB0cmFuc2ZlcmFibGVzXG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2socmVzdWx0LCB0eCk7XG4gICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVoeWRyYXRlKG5hbWUsIHN0cikge1xuICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gICAgc2VsZi50cm9pa2FEZWZpbmUgPSBmdW5jdGlvbiAocikgeyByZXR1cm4gcmVzdWx0ID0gcjsgfTtcbiAgICB2YXIgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChcbiAgICAgIG5ldyBCbG9iKFxuICAgICAgICBbKFwiLyoqIFwiICsgKG5hbWUucmVwbGFjZSgvXFwqL2csICcnKSkgKyBcIiAqKi9cXG5cXG50cm9pa2FEZWZpbmUoXFxuXCIgKyBzdHIgKyBcIlxcbilcIildLFxuICAgICAgICB7dHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnfVxuICAgICAgKVxuICAgICk7XG4gICAgdHJ5IHtcbiAgICAgIGltcG9ydFNjcmlwdHModXJsKTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH1cbiAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG4gICAgZGVsZXRlIHNlbGYudHJvaWthRGVmaW5lO1xuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIEhhbmRsZXIgZm9yIGFsbCBtZXNzYWdlcyB3aXRoaW4gdGhlIHdvcmtlclxuICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciByZWYgPSBlLmRhdGE7XG4gICAgdmFyIG1lc3NhZ2VJZCA9IHJlZi5tZXNzYWdlSWQ7XG4gICAgdmFyIGFjdGlvbiA9IHJlZi5hY3Rpb247XG4gICAgdmFyIGRhdGEgPSByZWYuZGF0YTtcbiAgICB0cnkge1xuICAgICAgLy8gTW9kdWxlIHJlZ2lzdHJhdGlvblxuICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JlZ2lzdGVyTW9kdWxlJykge1xuICAgICAgICByZWdpc3Rlck1vZHVsZShkYXRhLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6IHJlc3VsdC5tZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBtZXNzYWdlSWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgcmVzdWx0OiB7aXNDYWxsYWJsZTogdHlwZW9mIHJlc3VsdCA9PT0gJ2Z1bmN0aW9uJ31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBJbnZvY2F0aW9uXG4gICAgICBpZiAoYWN0aW9uID09PSAnY2FsbE1vZHVsZScpIHtcbiAgICAgICAgY2FsbE1vZHVsZShkYXRhLCBmdW5jdGlvbiAocmVzdWx0LCB0cmFuc2ZlcmFibGVzKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6IHJlc3VsdC5tZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBtZXNzYWdlSWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVyci5zdGFja1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBGYWxsYmFjayBmb3IgYGRlZmluZVdvcmtlck1vZHVsZWAgdGhhdCBiZWhhdmVzIGlkZW50aWNhbGx5IGJ1dCBydW5zIGluIHRoZSBtYWluXG4gKiB0aHJlYWQsIGZvciB3aGVuIHRoZSBleGVjdXRpb24gZW52aXJvbm1lbnQgZG9lc24ndCBzdXBwb3J0IHdlYiB3b3JrZXJzIG9yIHRoZXlcbiAqIGFyZSBkaXNhbGxvd2VkIGR1ZSB0byBlLmcuIENTUCBzZWN1cml0eSByZXN0cmljdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZU1haW5UaHJlYWRNb2R1bGUob3B0aW9ucykge1xuICB2YXIgbW9kdWxlRnVuYyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHJldHVybiBtb2R1bGVGdW5jLl9nZXRJbml0UmVzdWx0KCkudGhlbihmdW5jdGlvbiAoaW5pdFJlc3VsdCkge1xuICAgICAgaWYgKHR5cGVvZiBpbml0UmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBpbml0UmVzdWx0LmFwcGx5KHZvaWQgMCwgYXJncylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya2VyIG1vZHVsZSBmdW5jdGlvbiB3YXMgY2FsbGVkIGJ1dCBgaW5pdGAgZGlkIG5vdCByZXR1cm4gYSBjYWxsYWJsZSBmdW5jdGlvbicpXG4gICAgICB9XG4gICAgfSlcbiAgfTtcbiAgbW9kdWxlRnVuYy5fZ2V0SW5pdFJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFdlIGNhbiBpZ25vcmUgZ2V0VHJhbnNmZXJhYmxlcyBpbiBtYWluIHRocmVhZC4gVE9ETyB3b3JrZXJJZD9cbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gb3B0aW9ucy5kZXBlbmRlbmNpZXM7XG4gICAgdmFyIGluaXQgPSBvcHRpb25zLmluaXQ7XG5cbiAgICAvLyBSZXNvbHZlIGRlcGVuZGVuY2llc1xuICAgIGRlcGVuZGVuY2llcyA9IEFycmF5LmlzQXJyYXkoZGVwZW5kZW5jaWVzKSA/IGRlcGVuZGVuY2llcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gZGVwICYmIGRlcC5fZ2V0SW5pdFJlc3VsdCA/IGRlcC5fZ2V0SW5pdFJlc3VsdCgpIDogZGVwOyB9XG4gICAgKSA6IFtdO1xuXG4gICAgLy8gSW52b2tlIGluaXQgd2l0aCB0aGUgcmVzb2x2ZWQgZGVwZW5kZW5jaWVzXG4gICAgdmFyIGluaXRQcm9taXNlID0gUHJvbWlzZS5hbGwoZGVwZW5kZW5jaWVzKS50aGVuKGZ1bmN0aW9uIChkZXBzKSB7XG4gICAgICByZXR1cm4gaW5pdC5hcHBseShudWxsLCBkZXBzKVxuICAgIH0pO1xuXG4gICAgLy8gQ2FjaGUgdGhlIHJlc29sdmVkIHByb21pc2UgZm9yIHN1YnNlcXVlbnQgY2FsbHNcbiAgICBtb2R1bGVGdW5jLl9nZXRJbml0UmVzdWx0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5pdFByb21pc2U7IH07XG5cbiAgICByZXR1cm4gaW5pdFByb21pc2VcbiAgfTtcbiAgcmV0dXJuIG1vZHVsZUZ1bmNcbn1cblxudmFyIHN1cHBvcnRzV29ya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN1cHBvcnRlZCA9IGZhbHNlO1xuXG4gIC8vIE9ubHkgYXR0ZW1wdCB3b3JrZXIgaW5pdGlhbGl6YXRpb24gaW4gYnJvd3NlcnM7IGVsc2V3aGVyZSBpdCB3b3VsZCBqdXN0IGJlXG4gIC8vIG5vaXNlIGUuZy4gbG9hZGluZyBpbnRvIGEgTm9kZSBlbnZpcm9ubWVudCBmb3IgU1NSLlxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkge1xuICAgICAgLy8gVE9ETyBhZGRpdGlvbmFsIGNoZWNrcyBmb3IgdGhpbmdzIGxpa2UgaW1wb3J0U2NyaXB0cyB3aXRoaW4gdGhlIHdvcmtlcj9cbiAgICAgIC8vICBXb3VsZCBuZWVkIHRvIGJlIGFuIGFzeW5jIGNoZWNrLlxuICAgICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoXG4gICAgICAgIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoWycnXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSkpXG4gICAgICApO1xuICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0JykgOyBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgKFwiVHJvaWthIGNyZWF0ZVdvcmtlck1vZHVsZTogd2ViIHdvcmtlcnMgbm90IGFsbG93ZWQ7IGZhbGxpbmcgYmFjayB0byBtYWluIHRocmVhZCBleGVjdXRpb24uIENhdXNlOiBbXCIgKyAoZXJyLm1lc3NhZ2UpICsgXCJdXCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FjaGVkIHJlc3VsdFxuICBzdXBwb3J0c1dvcmtlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzdXBwb3J0ZWQ7IH07XG4gIHJldHVybiBzdXBwb3J0ZWRcbn07XG5cbnZhciBfd29ya2VyTW9kdWxlSWQgPSAwO1xudmFyIF9tZXNzYWdlSWQgPSAwO1xudmFyIF9hbGxvd0luaXRBc1N0cmluZyA9IGZhbHNlO1xudmFyIHdvcmtlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xudmFyIHJlZ2lzdGVyZWRNb2R1bGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgLy93b3JrZXJJZCAtPiBTZXQ8dW5yZWdpc3RlckZuPlxudmFyIG9wZW5SZXF1ZXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblxuLyoqXG4gKiBEZWZpbmUgYSBtb2R1bGUgb2YgY29kZSB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2l0aCBhIHdlYiB3b3JrZXIuIFRoaXMgcHJvdmlkZXMgYSBzaW1wbGVcbiAqIGludGVyZmFjZSBmb3IgbW92aW5nIGNodW5rcyBvZiBsb2dpYyBvZmYgdGhlIG1haW4gdGhyZWFkLCBhbmQgbWFuYWdpbmcgdGhlaXIgZGVwZW5kZW5jaWVzXG4gKiBhbW9uZyBvbmUgYW5vdGhlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5pbml0XG4gKiBAcGFyYW0ge2FycmF5fSBbb3B0aW9ucy5kZXBlbmRlbmNpZXNdXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5nZXRUcmFuc2ZlcmFibGVzXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm5hbWVdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMud29ya2VySWRdXG4gKiBAcmV0dXJuIHtmdW5jdGlvbiguLi5bKl0pOiB7dGhlbn19XG4gKi9cbmZ1bmN0aW9uIGRlZmluZVdvcmtlck1vZHVsZShvcHRpb25zKSB7XG4gIGlmICgoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMuaW5pdCAhPT0gJ2Z1bmN0aW9uJykgJiYgIV9hbGxvd0luaXRBc1N0cmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZXMgYG9wdGlvbnMuaW5pdGAgZnVuY3Rpb24nKVxuICB9XG4gIHZhciBkZXBlbmRlbmNpZXMgPSBvcHRpb25zLmRlcGVuZGVuY2llcztcbiAgdmFyIGluaXQgPSBvcHRpb25zLmluaXQ7XG4gIHZhciBnZXRUcmFuc2ZlcmFibGVzID0gb3B0aW9ucy5nZXRUcmFuc2ZlcmFibGVzO1xuICB2YXIgd29ya2VySWQgPSBvcHRpb25zLndvcmtlcklkO1xuXG4gIGlmICghc3VwcG9ydHNXb3JrZXJzKCkpIHtcbiAgICByZXR1cm4gZGVmaW5lTWFpblRocmVhZE1vZHVsZShvcHRpb25zKVxuICB9XG5cbiAgaWYgKHdvcmtlcklkID09IG51bGwpIHtcbiAgICB3b3JrZXJJZCA9ICcjZGVmYXVsdCc7XG4gIH1cbiAgdmFyIGlkID0gXCJ3b3JrZXJNb2R1bGVcIiArICgrK193b3JrZXJNb2R1bGVJZCk7XG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IGlkO1xuICB2YXIgcmVnaXN0cmF0aW9uUHJvbWlzZSA9IG51bGw7XG5cbiAgZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzICYmIGRlcGVuZGVuY2llcy5tYXAoZnVuY3Rpb24gKGRlcCkge1xuICAgIC8vIFdyYXAgcmF3IGZ1bmN0aW9ucyBhcyB3b3JrZXIgbW9kdWxlcyB3aXRoIG5vIGRlcGVuZGVuY2llc1xuICAgIGlmICh0eXBlb2YgZGVwID09PSAnZnVuY3Rpb24nICYmICFkZXAud29ya2VyTW9kdWxlRGF0YSkge1xuICAgICAgX2FsbG93SW5pdEFzU3RyaW5nID0gdHJ1ZTtcbiAgICAgIGRlcCA9IGRlZmluZVdvcmtlck1vZHVsZSh7XG4gICAgICAgIHdvcmtlcklkOiB3b3JrZXJJZCxcbiAgICAgICAgbmFtZTogKFwiPFwiICsgbmFtZSArIFwiPiBmdW5jdGlvbiBkZXBlbmRlbmN5OiBcIiArIChkZXAubmFtZSkpLFxuICAgICAgICBpbml0OiAoXCJmdW5jdGlvbigpe3JldHVybiAoXFxuXCIgKyAoc3RyaW5naWZ5RnVuY3Rpb24oZGVwKSkgKyBcIlxcbil9XCIpXG4gICAgICB9KTtcbiAgICAgIF9hbGxvd0luaXRBc1N0cmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBHcmFiIHBvc3RhYmxlIGRhdGEgZm9yIHdvcmtlciBtb2R1bGVzXG4gICAgaWYgKGRlcCAmJiBkZXAud29ya2VyTW9kdWxlRGF0YSkge1xuICAgICAgZGVwID0gZGVwLndvcmtlck1vZHVsZURhdGE7XG4gICAgfVxuICAgIHJldHVybiBkZXBcbiAgfSk7XG5cbiAgZnVuY3Rpb24gbW9kdWxlRnVuYygpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAvLyBSZWdpc3RlciB0aGlzIG1vZHVsZSBpZiBuZWVkZWRcbiAgICBpZiAoIXJlZ2lzdHJhdGlvblByb21pc2UpIHtcbiAgICAgIHJlZ2lzdHJhdGlvblByb21pc2UgPSBjYWxsV29ya2VyKHdvcmtlcklkLCdyZWdpc3Rlck1vZHVsZScsIG1vZHVsZUZ1bmMud29ya2VyTW9kdWxlRGF0YSk7XG4gICAgICB2YXIgdW5yZWdpc3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVnaXN0cmF0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHJlZ2lzdGVyZWRNb2R1bGVzW3dvcmtlcklkXS5kZWxldGUodW5yZWdpc3Rlcik7XG4gICAgICB9XG4gICAgICA7KHJlZ2lzdGVyZWRNb2R1bGVzW3dvcmtlcklkXSB8fCAocmVnaXN0ZXJlZE1vZHVsZXNbd29ya2VySWRdID0gbmV3IFNldCgpKSkuYWRkKHVucmVnaXN0ZXIpO1xuICAgIH1cblxuICAgIC8vIEludm9rZSB0aGUgbW9kdWxlLCByZXR1cm5pbmcgYSBwcm9taXNlXG4gICAgcmV0dXJuIHJlZ2lzdHJhdGlvblByb21pc2UudGhlbihmdW5jdGlvbiAocmVmKSB7XG4gICAgICB2YXIgaXNDYWxsYWJsZSA9IHJlZi5pc0NhbGxhYmxlO1xuXG4gICAgICBpZiAoaXNDYWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gY2FsbFdvcmtlcih3b3JrZXJJZCwnY2FsbE1vZHVsZScsIHtpZDogaWQsIGFyZ3M6IGFyZ3N9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrZXIgbW9kdWxlIGZ1bmN0aW9uIHdhcyBjYWxsZWQgYnV0IGBpbml0YCBkaWQgbm90IHJldHVybiBhIGNhbGxhYmxlIGZ1bmN0aW9uJylcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIG1vZHVsZUZ1bmMud29ya2VyTW9kdWxlRGF0YSA9IHtcbiAgICBpc1dvcmtlck1vZHVsZTogdHJ1ZSxcbiAgICBpZDogaWQsXG4gICAgbmFtZTogbmFtZSxcbiAgICBkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llcyxcbiAgICBpbml0OiBzdHJpbmdpZnlGdW5jdGlvbihpbml0KSxcbiAgICBnZXRUcmFuc2ZlcmFibGVzOiBnZXRUcmFuc2ZlcmFibGVzICYmIHN0cmluZ2lmeUZ1bmN0aW9uKGdldFRyYW5zZmVyYWJsZXMpXG4gIH07XG4gIHJldHVybiBtb2R1bGVGdW5jXG59XG5cbi8qKlxuICogVGVybWluYXRlIGFuIGFjdGl2ZSBXb3JrZXIgYnkgYSB3b3JrZXJJZCB0aGF0IHdhcyBwYXNzZWQgdG8gZGVmaW5lV29ya2VyTW9kdWxlLlxuICogVGhpcyBvbmx5IHRlcm1pbmF0ZXMgdGhlIFdvcmtlciBpdHNlbGY7IHRoZSB3b3JrZXIgbW9kdWxlIHdpbGwgcmVtYWluIGF2YWlsYWJsZVxuICogYW5kIGlmIHlvdSBjYWxsIGl0IGFnYWluIGl0cyBXb3JrZXIgd2lsbCBiZSByZXNwYXduZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gd29ya2VySWRcbiAqL1xuZnVuY3Rpb24gdGVybWluYXRlV29ya2VyKHdvcmtlcklkKSB7XG4gIC8vIFVucmVnaXN0ZXIgYWxsIG1vZHVsZXMgdGhhdCB3ZXJlIHJlZ2lzdGVyZWQgaW4gdGhhdCB3b3JrZXJcbiAgaWYgKHJlZ2lzdGVyZWRNb2R1bGVzW3dvcmtlcklkXSkge1xuICAgIHJlZ2lzdGVyZWRNb2R1bGVzW3dvcmtlcklkXS5mb3JFYWNoKGZ1bmN0aW9uICh1bnJlZ2lzdGVyKSB7XG4gICAgICB1bnJlZ2lzdGVyKCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gVGVybWluYXRlIHRoZSBXb3JrZXIgb2JqZWN0XG4gIGlmICh3b3JrZXJzW3dvcmtlcklkXSkge1xuICAgIHdvcmtlcnNbd29ya2VySWRdLnRlcm1pbmF0ZSgpO1xuICAgIGRlbGV0ZSB3b3JrZXJzW3dvcmtlcklkXTtcbiAgfVxufVxuXG4vKipcbiAqIFN0cmluZ2lmaWVzIGEgZnVuY3Rpb24gaW50byBhIGZvcm0gdGhhdCBjYW4gYmUgZGVzZXJpYWxpemVkIGluIHRoZSB3b3JrZXJcbiAqIEBwYXJhbSBmblxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlGdW5jdGlvbihmbikge1xuICB2YXIgc3RyID0gZm4udG9TdHJpbmcoKTtcbiAgLy8gSWYgaXQgd2FzIGRlZmluZWQgaW4gb2JqZWN0IG1ldGhvZC9wcm9wZXJ0eSBmb3JtYXQsIGl0IG5lZWRzIHRvIGJlIG1vZGlmaWVkXG4gIGlmICghL15mdW5jdGlvbi8udGVzdChzdHIpICYmIC9eXFx3K1xccypcXCgvLnRlc3Qoc3RyKSkge1xuICAgIHN0ciA9ICdmdW5jdGlvbiAnICsgc3RyO1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuXG5mdW5jdGlvbiBnZXRXb3JrZXIod29ya2VySWQpIHtcbiAgdmFyIHdvcmtlciA9IHdvcmtlcnNbd29ya2VySWRdO1xuICBpZiAoIXdvcmtlcikge1xuICAgIC8vIEJvb3RzdHJhcCB0aGUgd29ya2VyJ3MgY29udGVudFxuICAgIHZhciBib290c3RyYXAgPSBzdHJpbmdpZnlGdW5jdGlvbih3b3JrZXJCb290c3RyYXApO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSB3b3JrZXIgZnJvbSB0aGUgYm9vdHN0cmFwIGZ1bmN0aW9uIGNvbnRlbnRcbiAgICB3b3JrZXIgPSB3b3JrZXJzW3dvcmtlcklkXSA9IG5ldyBXb3JrZXIoXG4gICAgICBVUkwuY3JlYXRlT2JqZWN0VVJMKFxuICAgICAgICBuZXcgQmxvYihcbiAgICAgICAgICBbKFwiLyoqIFdvcmtlciBNb2R1bGUgQm9vdHN0cmFwOiBcIiArICh3b3JrZXJJZC5yZXBsYWNlKC9cXCovZywgJycpKSArIFwiICoqL1xcblxcbjsoXCIgKyBib290c3RyYXAgKyBcIikoKVwiKV0sXG4gICAgICAgICAge3R5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J31cbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG5cbiAgICAvLyBTaW5nbGUgaGFuZGxlciBmb3IgcmVzcG9uc2UgbWVzc2FnZXMgZnJvbSB0aGUgd29ya2VyXG4gICAgd29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgcmVzcG9uc2UgPSBlLmRhdGE7XG4gICAgICB2YXIgbXNnSWQgPSByZXNwb25zZS5tZXNzYWdlSWQ7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBvcGVuUmVxdWVzdHNbbXNnSWRdO1xuICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtlck1vZHVsZSByZXNwb25zZSB3aXRoIGVtcHR5IG9yIHVua25vd24gbWVzc2FnZUlkJylcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBvcGVuUmVxdWVzdHNbbXNnSWRdO1xuICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHdvcmtlclxufVxuXG4vLyBJc3N1ZSBhIGNhbGwgdG8gdGhlIHdvcmtlciB3aXRoIGEgY2FsbGJhY2sgdG8gaGFuZGxlIHRoZSByZXNwb25zZVxuZnVuY3Rpb24gY2FsbFdvcmtlcih3b3JrZXJJZCwgYWN0aW9uLCBkYXRhKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIG1lc3NhZ2VJZCA9ICsrX21lc3NhZ2VJZDtcbiAgICBvcGVuUmVxdWVzdHNbbWVzc2FnZUlkXSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcigoXCJFcnJvciBpbiB3b3JrZXIgXCIgKyBhY3Rpb24gKyBcIiBjYWxsOiBcIiArIChyZXNwb25zZS5lcnJvcikpKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBnZXRXb3JrZXIod29ya2VySWQpLnBvc3RNZXNzYWdlKHtcbiAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH0pXG59XG5cbmV4cG9ydCB7IGRlZmluZVdvcmtlck1vZHVsZSwgc3RyaW5naWZ5RnVuY3Rpb24sIHRlcm1pbmF0ZVdvcmtlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/bidi-js/dist/bidi.mjs":
/*!********************************************!*\
  !*** ./node_modules/bidi-js/dist/bidi.mjs ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nfunction bidiFactory() {\nvar bidi = (function (exports) {\n\n  // Bidi character types data, auto generated\n  var DATA = {\n    \"R\": \"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73\",\n    \"EN\": \"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9\",\n    \"ES\": \"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2\",\n    \"ET\": \"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj\",\n    \"AN\": \"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u\",\n    \"CS\": \"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b\",\n    \"B\": \"a,3,f+2,2v,690\",\n    \"S\": \"9,2,k\",\n    \"WS\": \"c,k,4f4,1vk+a,u,1j,335\",\n    \"ON\": \"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i\",\n    \"BN\": \"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1\",\n    \"NSM\": \"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n\",\n    \"AL\": \"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d\",\n    \"LRO\": \"6ct\",\n    \"RLO\": \"6cu\",\n    \"LRE\": \"6cq\",\n    \"RLE\": \"6cr\",\n    \"PDF\": \"6cs\",\n    \"LRI\": \"6ee\",\n    \"RLI\": \"6ef\",\n    \"FSI\": \"6eg\",\n    \"PDI\": \"6eh\"\n  };\n\n  var TYPES = {};\n  var TYPES_TO_NAMES = {};\n  TYPES.L = 1; //L is the default\n  TYPES_TO_NAMES[1] = 'L';\n  Object.keys(DATA).forEach(function (type, i) {\n    TYPES[type] = 1 << (i + 1);\n    TYPES_TO_NAMES[TYPES[type]] = type;\n  });\n  Object.freeze(TYPES);\n\n  var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;\n  var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;\n  var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;\n  var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;\n  var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;\n\n  var map = null;\n\n  function parseData () {\n    if (!map) {\n      //const start = performance.now()\n      map = new Map();\n      var loop = function ( type ) {\n        if (DATA.hasOwnProperty(type)) {\n          var lastCode = 0;\n          DATA[type].split(',').forEach(function (range) {\n            var ref = range.split('+');\n            var skip = ref[0];\n            var step = ref[1];\n            skip = parseInt(skip, 36);\n            step = step ? parseInt(step, 36) : 0;\n            map.set(lastCode += skip, TYPES[type]);\n            for (var i = 0; i < step; i++) {\n              map.set(++lastCode, TYPES[type]);\n            }\n          });\n        }\n      };\n\n      for (var type in DATA) loop( type );\n      //console.log(`char types parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  /**\n   * @param {string} char\n   * @return {number}\n   */\n  function getBidiCharType (char) {\n    parseData();\n    return map.get(char.codePointAt(0)) || TYPES.L\n  }\n\n  function getBidiCharTypeName(char) {\n    return TYPES_TO_NAMES[getBidiCharType(char)]\n  }\n\n  // Bidi bracket pairs data, auto generated\n  var data$1 = {\n    \"pairs\": \"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1\",\n    \"canonical\": \"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye\"\n  };\n\n  /**\n   * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or\n   * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object\n   * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.\n   * @param {string} encodedString\n   * @param {boolean} includeReverse - true if you want reverseMap in the output\n   * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}\n   */\n  function parseCharacterMap (encodedString, includeReverse) {\n    var radix = 36;\n    var lastCode = 0;\n    var map = new Map();\n    var reverseMap = includeReverse && new Map();\n    var prevPair;\n    encodedString.split(',').forEach(function visit(entry) {\n      if (entry.indexOf('+') !== -1) {\n        for (var i = +entry; i--;) {\n          visit(prevPair);\n        }\n      } else {\n        prevPair = entry;\n        var ref = entry.split('>');\n        var a = ref[0];\n        var b = ref[1];\n        a = String.fromCodePoint(lastCode += parseInt(a, radix));\n        b = String.fromCodePoint(lastCode += parseInt(b, radix));\n        map.set(a, b);\n        includeReverse && reverseMap.set(b, a);\n      }\n    });\n    return { map: map, reverseMap: reverseMap }\n  }\n\n  var openToClose, closeToOpen, canonical;\n\n  function parse$1 () {\n    if (!openToClose) {\n      //const start = performance.now()\n      var ref = parseCharacterMap(data$1.pairs, true);\n      var map = ref.map;\n      var reverseMap = ref.reverseMap;\n      openToClose = map;\n      closeToOpen = reverseMap;\n      canonical = parseCharacterMap(data$1.canonical, false).map;\n      //console.log(`brackets parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  function openingToClosingBracket (char) {\n    parse$1();\n    return openToClose.get(char) || null\n  }\n\n  function closingToOpeningBracket (char) {\n    parse$1();\n    return closeToOpen.get(char) || null\n  }\n\n  function getCanonicalBracket (char) {\n    parse$1();\n    return canonical.get(char) || null\n  }\n\n  // Local type aliases\n  var TYPE_L = TYPES.L;\n  var TYPE_R = TYPES.R;\n  var TYPE_EN = TYPES.EN;\n  var TYPE_ES = TYPES.ES;\n  var TYPE_ET = TYPES.ET;\n  var TYPE_AN = TYPES.AN;\n  var TYPE_CS = TYPES.CS;\n  var TYPE_B = TYPES.B;\n  var TYPE_S = TYPES.S;\n  var TYPE_ON = TYPES.ON;\n  var TYPE_BN = TYPES.BN;\n  var TYPE_NSM = TYPES.NSM;\n  var TYPE_AL = TYPES.AL;\n  var TYPE_LRO = TYPES.LRO;\n  var TYPE_RLO = TYPES.RLO;\n  var TYPE_LRE = TYPES.LRE;\n  var TYPE_RLE = TYPES.RLE;\n  var TYPE_PDF = TYPES.PDF;\n  var TYPE_LRI = TYPES.LRI;\n  var TYPE_RLI = TYPES.RLI;\n  var TYPE_FSI = TYPES.FSI;\n  var TYPE_PDI = TYPES.PDI;\n\n  /**\n   * @typedef {object} GetEmbeddingLevelsResult\n   * @property {{start, end, level}[]} paragraphs\n   * @property {Uint8Array} levels\n   */\n\n  /**\n   * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels\n   * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved\n   * base embedding level.\n   *\n   * @param {string} string - The input string\n   * @param {\"ltr\"|\"rtl\"|\"auto\"} [baseDirection] - Use \"ltr\" or \"rtl\" to force a base paragraph direction,\n   *        otherwise a direction will be chosen automatically from each paragraph's contents.\n   * @return {GetEmbeddingLevelsResult}\n   */\n  function getEmbeddingLevels (string, baseDirection) {\n    var MAX_DEPTH = 125;\n\n    // Start by mapping all characters to their unicode type, as a bitmask integer\n    var charTypes = new Uint32Array(string.length);\n    for (var i = 0; i < string.length; i++) {\n      charTypes[i] = getBidiCharType(string[i]);\n    }\n\n    var charTypeCounts = new Map(); //will be cleared at start of each paragraph\n    function changeCharType(i, type) {\n      var oldType = charTypes[i];\n      charTypes[i] = type;\n      charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);\n      if (oldType & NEUTRAL_ISOLATE_TYPES) {\n        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);\n      }\n      charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);\n      if (type & NEUTRAL_ISOLATE_TYPES) {\n        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n      }\n    }\n\n    var embedLevels = new Uint8Array(string.length);\n    var isolationPairs = new Map(); //init->pdi and pdi->init\n\n    // === 3.3.1 The Paragraph Level ===\n    // 3.3.1 P1: Split the text into paragraphs\n    var paragraphs = []; // [{start, end, level}, ...]\n    var paragraph = null;\n    for (var i$1 = 0; i$1 < string.length; i$1++) {\n      if (!paragraph) {\n        paragraphs.push(paragraph = {\n          start: i$1,\n          end: string.length - 1,\n          // 3.3.1 P2-P3: Determine the paragraph level\n          level: baseDirection === 'rtl' ? 1 : baseDirection === 'ltr' ? 0 : determineAutoEmbedLevel(i$1, false)\n        });\n      }\n      if (charTypes[i$1] & TYPE_B) {\n        paragraph.end = i$1;\n        paragraph = null;\n      }\n    }\n\n    var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;\n    var nextEven = function (n) { return n + ((n & 1) ? 1 : 2); };\n    var nextOdd = function (n) { return n + ((n & 1) ? 2 : 1); };\n\n    // Everything from here on will operate per paragraph.\n    for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {\n      paragraph = paragraphs[paraIdx];\n      var statusStack = [{\n        _level: paragraph.level,\n        _override: 0, //0=neutral, 1=L, 2=R\n        _isolate: 0 //bool\n      }];\n      var stackTop = (void 0);\n      var overflowIsolateCount = 0;\n      var overflowEmbeddingCount = 0;\n      var validIsolateCount = 0;\n      charTypeCounts.clear();\n\n      // === 3.3.2 Explicit Levels and Directions ===\n      for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {\n        var charType = charTypes[i$2];\n        stackTop = statusStack[statusStack.length - 1];\n\n        // Set initial counts\n        charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);\n        if (charType & NEUTRAL_ISOLATE_TYPES) {\n          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n        }\n\n        // Explicit Embeddings: 3.3.2 X2 - X3\n        if (charType & FORMATTING_TYPES) { //prefilter all formatters\n          if (charType & (TYPE_RLE | TYPE_LRE)) {\n            embedLevels[i$2] = stackTop._level; // 5.2\n            var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);\n            if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n              statusStack.push({\n                _level: level,\n                _override: 0,\n                _isolate: 0\n              });\n            } else if (!overflowIsolateCount) {\n              overflowEmbeddingCount++;\n            }\n          }\n\n          // Explicit Overrides: 3.3.2 X4 - X5\n          else if (charType & (TYPE_RLO | TYPE_LRO)) {\n            embedLevels[i$2] = stackTop._level; // 5.2\n            var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);\n            if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n              statusStack.push({\n                _level: level$1,\n                _override: (charType & TYPE_RLO) ? TYPE_R : TYPE_L,\n                _isolate: 0\n              });\n            } else if (!overflowIsolateCount) {\n              overflowEmbeddingCount++;\n            }\n          }\n\n          // Isolates: 3.3.2 X5a - X5c\n          else if (charType & ISOLATE_INIT_TYPES) {\n            // X5c - FSI becomes either RLI or LRI\n            if (charType & TYPE_FSI) {\n              charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;\n            }\n\n            embedLevels[i$2] = stackTop._level;\n            if (stackTop._override) {\n              changeCharType(i$2, stackTop._override);\n            }\n            var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);\n            if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {\n              validIsolateCount++;\n              statusStack.push({\n                _level: level$2,\n                _override: 0,\n                _isolate: 1,\n                _isolInitIndex: i$2\n              });\n            } else {\n              overflowIsolateCount++;\n            }\n          }\n\n          // Terminating Isolates: 3.3.2 X6a\n          else if (charType & TYPE_PDI) {\n            if (overflowIsolateCount > 0) {\n              overflowIsolateCount--;\n            } else if (validIsolateCount > 0) {\n              overflowEmbeddingCount = 0;\n              while (!statusStack[statusStack.length - 1]._isolate) {\n                statusStack.pop();\n              }\n              // Add to isolation pairs bidirectional mapping:\n              var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;\n              if (isolInitIndex != null) {\n                isolationPairs.set(isolInitIndex, i$2);\n                isolationPairs.set(i$2, isolInitIndex);\n              }\n              statusStack.pop();\n              validIsolateCount--;\n            }\n            stackTop = statusStack[statusStack.length - 1];\n            embedLevels[i$2] = stackTop._level;\n            if (stackTop._override) {\n              changeCharType(i$2, stackTop._override);\n            }\n          }\n\n\n          // Terminating Embeddings and Overrides: 3.3.2 X7\n          else if (charType & TYPE_PDF) {\n            if (overflowIsolateCount === 0) {\n              if (overflowEmbeddingCount > 0) {\n                overflowEmbeddingCount--;\n              } else if (!stackTop._isolate && statusStack.length > 1) {\n                statusStack.pop();\n                stackTop = statusStack[statusStack.length - 1];\n              }\n            }\n            embedLevels[i$2] = stackTop._level; // 5.2\n          }\n\n          // End of Paragraph: 3.3.2 X8\n          else if (charType & TYPE_B) {\n            embedLevels[i$2] = paragraph.level;\n          }\n        }\n\n        // Non-formatting characters: 3.3.2 X6\n        else {\n          embedLevels[i$2] = stackTop._level;\n          // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage\n          if (stackTop._override && charType !== TYPE_BN) {\n            changeCharType(i$2, stackTop._override);\n          }\n        }\n      }\n\n      // === 3.3.3 Preparations for Implicit Processing ===\n\n      // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9\n      // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to\n      // easily ignore them all from here on out.\n\n      // 3.3.3 X10\n      // Compute the set of isolating run sequences as specified by BD13\n      var levelRuns = [];\n      var currentRun = null;\n      for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {\n        var charType$1 = charTypes[i$3];\n        if (!(charType$1 & BN_LIKE_TYPES)) {\n          var lvl = embedLevels[i$3];\n          var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;\n          var isPDI = charType$1 === TYPE_PDI;\n          if (currentRun && lvl === currentRun._level) {\n            currentRun._end = i$3;\n            currentRun._endsWithIsolInit = isIsolInit;\n          } else {\n            levelRuns.push(currentRun = {\n              _start: i$3,\n              _end: i$3,\n              _level: lvl,\n              _startsWithPDI: isPDI,\n              _endsWithIsolInit: isIsolInit\n            });\n          }\n        }\n      }\n      var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]\n      for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {\n        var run = levelRuns[runIdx];\n        if (!run._startsWithPDI || (run._startsWithPDI && !isolationPairs.has(run._start))) {\n          var seqRuns = [currentRun = run];\n          for (var pdiIndex = (void 0); currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;) {\n            for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {\n              if (levelRuns[i$4]._start === pdiIndex) {\n                seqRuns.push(currentRun = levelRuns[i$4]);\n                break\n              }\n            }\n          }\n          // build flat list of indices across all runs:\n          var seqIndices = [];\n          for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {\n            var run$1 = seqRuns[i$5];\n            for (var j = run$1._start; j <= run$1._end; j++) {\n              seqIndices.push(j);\n            }\n          }\n          // determine the sos/eos types:\n          var firstLevel = embedLevels[seqIndices[0]];\n          var prevLevel = paragraph.level;\n          for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {\n            if (!(charTypes[i$6] & BN_LIKE_TYPES)) { //5.2\n              prevLevel = embedLevels[i$6];\n              break\n            }\n          }\n          var lastIndex = seqIndices[seqIndices.length - 1];\n          var lastLevel = embedLevels[lastIndex];\n          var nextLevel = paragraph.level;\n          if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {\n            for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {\n              if (!(charTypes[i$7] & BN_LIKE_TYPES)) { //5.2\n                nextLevel = embedLevels[i$7];\n                break\n              }\n            }\n          }\n          isolatingRunSeqs.push({\n            _seqIndices: seqIndices,\n            _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,\n            _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L\n          });\n        }\n      }\n\n      // The next steps are done per isolating run sequence\n      for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {\n        var ref = isolatingRunSeqs[seqIdx];\n        var seqIndices$1 = ref._seqIndices;\n        var sosType = ref._sosType;\n        var eosType = ref._eosType;\n        /**\n         * All the level runs in an isolating run sequence have the same embedding level.\n         * \n         * DO NOT change any `embedLevels[i]` within the current scope.\n         */\n        var embedDirection = ((embedLevels[seqIndices$1[0]]) & 1) ? TYPE_R : TYPE_L;\n\n        // === 3.3.4 Resolving Weak Types ===\n\n        // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose\n        // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its\n        // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.\n        if (charTypeCounts.get(TYPE_NSM)) {\n          for (var si = 0; si < seqIndices$1.length; si++) {\n            var i$8 = seqIndices$1[si];\n            if (charTypes[i$8] & TYPE_NSM) {\n              var prevType = sosType;\n              for (var sj = si - 1; sj >= 0; sj--) {\n                if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) { //5.2 scan back to first non-BN\n                  prevType = charTypes[seqIndices$1[sj]];\n                  break\n                }\n              }\n              changeCharType(i$8, (prevType & (ISOLATE_INIT_TYPES | TYPE_PDI)) ? TYPE_ON : prevType);\n            }\n          }\n        }\n\n        // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)\n        // is found. If an AL is found, change the type of the European number to Arabic number.\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {\n            var i$9 = seqIndices$1[si$1];\n            if (charTypes[i$9] & TYPE_EN) {\n              for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {\n                var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];\n                if (prevCharType & STRONG_TYPES) {\n                  if (prevCharType === TYPE_AL) {\n                    changeCharType(i$9, TYPE_AN);\n                  }\n                  break\n                }\n              }\n            }\n          }\n        }\n\n        // W3. Change all ALs to R\n        if (charTypeCounts.get(TYPE_AL)) {\n          for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {\n            var i$10 = seqIndices$1[si$2];\n            if (charTypes[i$10] & TYPE_AL) {\n              changeCharType(i$10, TYPE_R);\n            }\n          }\n        }\n\n        // W4. A single European separator between two European numbers changes to a European number. A single common\n        // separator between two numbers of the same type changes to that type.\n        if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n          for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {\n            var i$11 = seqIndices$1[si$3];\n            if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {\n              var prevType$1 = 0, nextType = 0;\n              for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {\n                prevType$1 = charTypes[seqIndices$1[sj$2]];\n                if (!(prevType$1 & BN_LIKE_TYPES)) { //5.2\n                  break\n                }\n              }\n              for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {\n                nextType = charTypes[seqIndices$1[sj$3]];\n                if (!(nextType & BN_LIKE_TYPES)) { //5.2\n                  break\n                }\n              }\n              if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : (prevType$1 & (TYPE_EN | TYPE_AN)))) {\n                changeCharType(i$11, prevType$1);\n              }\n            }\n          }\n        }\n\n        // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {\n            var i$12 = seqIndices$1[si$4];\n            if (charTypes[i$12] & TYPE_EN) {\n              for (var sj$4 = si$4 - 1; sj$4 >= 0 && (charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES)); sj$4--) {\n                changeCharType(seqIndices$1[sj$4], TYPE_EN);\n              }\n              for (si$4++; si$4 < seqIndices$1.length && (charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN)); si$4++) {\n                if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {\n                  changeCharType(seqIndices$1[si$4], TYPE_EN);\n                }\n              }\n            }\n          }\n        }\n\n        // W6. Otherwise, separators and terminators change to Other Neutral.\n        if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n          for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {\n            var i$13 = seqIndices$1[si$5];\n            if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {\n              changeCharType(i$13, TYPE_ON);\n              // 5.2 transform adjacent BNs too:\n              for (var sj$5 = si$5 - 1; sj$5 >= 0 && (charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES); sj$5--) {\n                changeCharType(seqIndices$1[sj$5], TYPE_ON);\n              }\n              for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && (charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES); sj$6++) {\n                changeCharType(seqIndices$1[sj$6], TYPE_ON);\n              }\n            }\n          }\n        }\n\n        // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)\n        // is found. If an L is found, then change the type of the European number to L.\n        // NOTE: implemented in single forward pass for efficiency\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {\n            var i$14 = seqIndices$1[si$6];\n            var type = charTypes[i$14];\n            if (type & TYPE_EN) {\n              if (prevStrongType === TYPE_L) {\n                changeCharType(i$14, TYPE_L);\n              }\n            } else if (type & STRONG_TYPES) {\n              prevStrongType = type;\n            }\n          }\n        }\n\n        // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===\n\n        if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {\n          // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text\n          // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional\n          // types EN and AN are treated as R.\n          var R_TYPES_FOR_N_STEPS = (TYPE_R | TYPE_EN | TYPE_AN);\n          var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;\n\n          // * Identify the bracket pairs in the current isolating run sequence according to BD16.\n          var bracketPairs = [];\n          {\n            var openerStack = [];\n            for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {\n              // NOTE: for any potential bracket character we also test that it still carries a NI\n              // type, as that may have been changed earlier. This doesn't seem to be explicitly\n              // called out in the spec, but is required for passage of certain tests.\n              if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {\n                var char = string[seqIndices$1[si$7]];\n                var oppositeBracket = (void 0);\n                // Opening bracket\n                if (openingToClosingBracket(char) !== null) {\n                  if (openerStack.length < 63) {\n                    openerStack.push({ char: char, seqIndex: si$7 });\n                  } else {\n                    break\n                  }\n                }\n                // Closing bracket\n                else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {\n                  for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {\n                    var stackChar = openerStack[stackIdx].char;\n                    if (stackChar === oppositeBracket ||\n                      stackChar === closingToOpeningBracket(getCanonicalBracket(char)) ||\n                      openingToClosingBracket(getCanonicalBracket(stackChar)) === char\n                    ) {\n                      bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);\n                      openerStack.length = stackIdx; //pop the matching bracket and all following\n                      break\n                    }\n                  }\n                }\n              }\n            }\n            bracketPairs.sort(function (a, b) { return a[0] - b[0]; });\n          }\n          // * For each bracket-pair element in the list of pairs of text positions\n          for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {\n            var ref$1 = bracketPairs[pairIdx];\n            var openSeqIdx = ref$1[0];\n            var closeSeqIdx = ref$1[1];\n            // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.\n            // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both\n            // brackets in the pair to match the embedding direction.\n            var foundStrongType = false;\n            var useStrongType = 0;\n            for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {\n              var i$15 = seqIndices$1[si$8];\n              if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {\n                foundStrongType = true;\n                var lr = (charTypes[i$15] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                if (lr === embedDirection) {\n                  useStrongType = lr;\n                  break\n                }\n              }\n            }\n            // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test\n            // for an established context with a preceding strong type by checking backwards before the opening paired\n            // bracket until the first strong type (L, R, or sos) is found.\n            //    1. If the preceding strong type is also opposite the embedding direction, context is established, so\n            //    set the type for both brackets in the pair to that direction.\n            //    2. Otherwise set the type for both brackets in the pair to the embedding direction.\n            if (foundStrongType && !useStrongType) {\n              useStrongType = sosType;\n              for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {\n                var i$16 = seqIndices$1[si$9];\n                if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {\n                  var lr$1 = (charTypes[i$16] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  if (lr$1 !== embedDirection) {\n                    useStrongType = lr$1;\n                  } else {\n                    useStrongType = embedDirection;\n                  }\n                  break\n                }\n              }\n            }\n            if (useStrongType) {\n              charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;\n              // * Any number of characters that had original bidirectional character type NSM prior to the application\n              // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match\n              // the type of their preceding bracket.\n              if (useStrongType !== embedDirection) {\n                for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {\n                  if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {\n                    if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {\n                      charTypes[seqIndices$1[si$10]] = useStrongType;\n                    }\n                    break\n                  }\n                }\n              }\n              if (useStrongType !== embedDirection) {\n                for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {\n                  if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {\n                    if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {\n                      charTypes[seqIndices$1[si$11]] = useStrongType;\n                    }\n                    break\n                  }\n                }\n              }\n            }\n          }\n\n          // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the\n          // same direction.\n          // N2. Any remaining NIs take the embedding direction.\n          for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {\n            if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {\n              var niRunStart = si$12, niRunEnd = si$12;\n              var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L\n              for (var si2 = si$12 - 1; si2 >= 0; si2--) {\n                if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {\n                  niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs\n                } else {\n                  prevType$2 = (charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  break\n                }\n              }\n              var nextType$1 = eosType;\n              for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {\n                if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {\n                  niRunEnd = si2$1;\n                } else {\n                  nextType$1 = (charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  break\n                }\n              }\n              for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {\n                charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;\n              }\n              si$12 = niRunEnd;\n            }\n          }\n        }\n      }\n\n      // === 3.3.6 Resolving Implicit Levels ===\n\n      for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {\n        var level$3 = embedLevels[i$17];\n        var type$1 = charTypes[i$17];\n        // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\n        if (level$3 & 1) {\n          if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {\n            embedLevels[i$17]++;\n          }\n        }\n          // I1. For all characters with an even (left-to-right) embedding level, those of type R go up one level\n        // and those of type AN or EN go up two levels.\n        else {\n          if (type$1 & TYPE_R) {\n            embedLevels[i$17]++;\n          } else if (type$1 & (TYPE_AN | TYPE_EN)) {\n            embedLevels[i$17] += 2;\n          }\n        }\n\n        // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,\n        // and otherwise to the base level.\n        if (type$1 & BN_LIKE_TYPES) {\n          embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];\n        }\n\n        // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or\n        // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.\n        // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.\n        if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {\n          for (var j$1 = i$17; j$1 >= 0 && (getBidiCharType(string[j$1]) & TRAILING_TYPES); j$1--) {\n            embedLevels[j$1] = paragraph.level;\n          }\n        }\n      }\n    }\n\n    // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters\n    // according to section 3.4 Reordering Resolved Levels\n    return {\n      levels: embedLevels,\n      paragraphs: paragraphs\n    }\n\n    function determineAutoEmbedLevel (start, isFSI) {\n      // 3.3.1 P2 - P3\n      for (var i = start; i < string.length; i++) {\n        var charType = charTypes[i];\n        if (charType & (TYPE_R | TYPE_AL)) {\n          return 1\n        }\n        if ((charType & (TYPE_B | TYPE_L)) || (isFSI && charType === TYPE_PDI)) {\n          return 0\n        }\n        if (charType & ISOLATE_INIT_TYPES) {\n          var pdi = indexOfMatchingPDI(i);\n          i = pdi === -1 ? string.length : pdi;\n        }\n      }\n      return 0\n    }\n\n    function indexOfMatchingPDI (isolateStart) {\n      // 3.1.2 BD9\n      var isolationLevel = 1;\n      for (var i = isolateStart + 1; i < string.length; i++) {\n        var charType = charTypes[i];\n        if (charType & TYPE_B) {\n          break\n        }\n        if (charType & TYPE_PDI) {\n          if (--isolationLevel === 0) {\n            return i\n          }\n        } else if (charType & ISOLATE_INIT_TYPES) {\n          isolationLevel++;\n        }\n      }\n      return -1\n    }\n  }\n\n  // Bidi mirrored chars data, auto generated\n  var data = \"14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1\";\n\n  var mirrorMap;\n\n  function parse () {\n    if (!mirrorMap) {\n      //const start = performance.now()\n      var ref = parseCharacterMap(data, true);\n      var map = ref.map;\n      var reverseMap = ref.reverseMap;\n      // Combine both maps into one\n      reverseMap.forEach(function (value, key) {\n        map.set(key, value);\n      });\n      mirrorMap = map;\n      //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  function getMirroredCharacter (char) {\n    parse();\n    return mirrorMap.get(char) || null\n  }\n\n  /**\n   * Given a string and its resolved embedding levels, build a map of indices to replacement chars\n   * for any characters in right-to-left segments that have defined mirrored characters.\n   * @param string\n   * @param embeddingLevels\n   * @param [start]\n   * @param [end]\n   * @return {Map<number, string>}\n   */\n  function getMirroredCharactersMap(string, embeddingLevels, start, end) {\n    var strLen = string.length;\n    start = Math.max(0, start == null ? 0 : +start);\n    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n    var map = new Map();\n    for (var i = start; i <= end; i++) {\n      if (embeddingLevels[i] & 1) { //only odd (rtl) levels\n        var mirror = getMirroredCharacter(string[i]);\n        if (mirror !== null) {\n          map.set(i, mirror);\n        }\n      }\n    }\n    return map\n  }\n\n  /**\n   * Given a start and end denoting a single line within a string, and a set of precalculated\n   * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.\n   * @param {string} string - the full input string\n   * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels\n   * @param {number} [start] - first character in a subset of the full string\n   * @param {number} [end] - last character in a subset of the full string\n   * @return {number[][]} - the list of start/end segments that should be flipped, in order.\n   */\n  function getReorderSegments(string, embeddingLevelsResult, start, end) {\n    var strLen = string.length;\n    start = Math.max(0, start == null ? 0 : +start);\n    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n    var segments = [];\n    embeddingLevelsResult.paragraphs.forEach(function (paragraph) {\n      var lineStart = Math.max(start, paragraph.start);\n      var lineEnd = Math.min(end, paragraph.end);\n      if (lineStart < lineEnd) {\n        // Local slice for mutation\n        var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);\n\n        // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the\n        // end of the line to the paragraph level.\n        for (var i = lineEnd; i >= lineStart && (getBidiCharType(string[i]) & TRAILING_TYPES); i--) {\n          lineLevels[i] = paragraph.level;\n        }\n\n        // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels\n        // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.\n        var maxLevel = paragraph.level;\n        var minOddLevel = Infinity;\n        for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {\n          var level = lineLevels[i$1];\n          if (level > maxLevel) { maxLevel = level; }\n          if (level < minOddLevel) { minOddLevel = level | 1; }\n        }\n        for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {\n          for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {\n            if (lineLevels[i$2] >= lvl) {\n              var segStart = i$2;\n              while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {\n                i$2++;\n              }\n              if (i$2 > segStart) {\n                segments.push([segStart + lineStart, i$2 + lineStart]);\n              }\n            }\n          }\n        }\n      }\n    });\n    return segments\n  }\n\n  /**\n   * @param {string} string\n   * @param {GetEmbeddingLevelsResult} embedLevelsResult\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {string} the new string with bidi segments reordered\n   */\n  function getReorderedString(string, embedLevelsResult, start, end) {\n    var indices = getReorderedIndices(string, embedLevelsResult, start, end);\n    var chars = [].concat( string );\n    indices.forEach(function (charIndex, i) {\n      chars[i] = (\n        (embedLevelsResult.levels[charIndex] & 1) ? getMirroredCharacter(string[charIndex]) : null\n      ) || string[charIndex];\n    });\n    return chars.join('')\n  }\n\n  /**\n   * @param {string} string\n   * @param {GetEmbeddingLevelsResult} embedLevelsResult\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {number[]} an array with character indices in their new bidi order\n   */\n  function getReorderedIndices(string, embedLevelsResult, start, end) {\n    var segments = getReorderSegments(string, embedLevelsResult, start, end);\n    // Fill an array with indices\n    var indices = [];\n    for (var i = 0; i < string.length; i++) {\n      indices[i] = i;\n    }\n    // Reverse each segment in order\n    segments.forEach(function (ref) {\n      var start = ref[0];\n      var end = ref[1];\n\n      var slice = indices.slice(start, end + 1);\n      for (var i = slice.length; i--;) {\n        indices[end - i] = slice[i];\n      }\n    });\n    return indices\n  }\n\n  exports.closingToOpeningBracket = closingToOpeningBracket;\n  exports.getBidiCharType = getBidiCharType;\n  exports.getBidiCharTypeName = getBidiCharTypeName;\n  exports.getCanonicalBracket = getCanonicalBracket;\n  exports.getEmbeddingLevels = getEmbeddingLevels;\n  exports.getMirroredCharacter = getMirroredCharacter;\n  exports.getMirroredCharactersMap = getMirroredCharactersMap;\n  exports.getReorderSegments = getReorderSegments;\n  exports.getReorderedIndices = getReorderedIndices;\n  exports.getReorderedString = getReorderedString;\n  exports.openingToClosingBracket = openingToClosingBracket;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\nreturn bidi}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (bidiFactory);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL2JpZGktanMvZGlzdC9iaWRpLm1qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QywwQkFBMEI7QUFDdEU7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixJQUFJO0FBQ2pDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMEJBQTBCO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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ZSxXQUFXLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JpZGktanMvZGlzdC9iaWRpLm1qcz9jZjJiIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGJpZGlGYWN0b3J5KCkge1xudmFyIGJpZGkgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICAvLyBCaWRpIGNoYXJhY3RlciB0eXBlcyBkYXRhLCBhdXRvIGdlbmVyYXRlZFxuICB2YXIgREFUQSA9IHtcbiAgICBcIlJcIjogXCIxM2ssMWEsMiwzLDMsMisxaixjaCsxNixhKzEsNSsyLDIrbiw1LGEsNCw2KzE2LDQrMyxoKzFiLDRtbywxNzlxLDIrOSwyKzExLDJpOSs3eSwyKzY4LDQsMys0LDUrMTMsNCszLDIrNGssMysyOSw4K2NmLDF0Kzd6LHcrMTcsMyszbSwxdCszeiwxNm8xKzVyLDgrMzAsOCttYywyOSsxciwyOSs0diw3NSs3M1wiLFxuICAgIFwiRU5cIjogXCIxYys5LDNkKzEsNiwxODcrOSw1MTMsNCs1LDcrOSxzZitqLDE3NWgrOSxxdytxLDE2MWYrMWQsNHh0K2EsMjVpKzlcIixcbiAgICBcIkVTXCI6IFwiMTcsMiw2ZHArMSxmKzEsYXYsMTZ2cixteCsxLDRvLDJcIixcbiAgICBcIkVUXCI6IFwieisyLDNoKzMsYisxLHltLDNlKzEsMm8scDQrMSw4LDZ1LDdjLGc2LDF3YywxbjkrNCwzMCsxYiwybiw2ZCxxaHgrMSxoMG0sYSsxLDQ5KzIsNjMrMSw0KzEsNmJiKzMsMTJqalwiLFxuICAgIFwiQU5cIjogXCIxNm8rNSwyais5LDIrMSwzNSxlZCwxZmYyKzksODcrdVwiLFxuICAgIFwiQ1NcIjogXCIxOCwyKzEsYiwydSwxMmssNTV2LGwsMTd2MCwyLDMsNTMsMisxLGJcIixcbiAgICBcIkJcIjogXCJhLDMsZisyLDJ2LDY5MFwiLFxuICAgIFwiU1wiOiBcIjksMixrXCIsXG4gICAgXCJXU1wiOiBcImMsayw0ZjQsMXZrK2EsdSwxaiwzMzVcIixcbiAgICBcIk9OXCI6IFwieCsxLDQrNCxoKzUscis1LHIrMyx6LDUrMywyKzEsMisxLDUsMisyLDMrNCxvLHcsY2krMSw4K2QsMytkLDYrOCwyK2csMzkrMSw5LDYrMSwyLDMzLGI4LDMrMSwzYysxLDcrMSw1cixiLDdoKzMsc2ErNSwyLDNpKzYsamcrMyx1cis5LDJ2LGlqKzEsOWcrOSw3K2EsOG0sNCsxLDQ5K3gsMTR1LDIrMixjKzIsZSsyLGUrMixlKzEsaStuLGUrZSwyK3AsdSsyLGUrMiwzNisxLDIrMywyKzEsYiwyKzIsNis1LDIsMiwyLGgrMSw1KzQsNiszLDMrZiwxNisyLDUrM2wsMys4MSwxeStwLDIrNDAscSthLG0rMTMsMnIrY2gsMis5ZSw3NStoZiwzK3YsMisydyw2ZSs1LGYrNiw3NSsyYSwxYStwLDIrMmcsZCs1eCxyK2IsNiszLDQrbyxnLDYrMSw2KzIsMmsrMSw0LDJqLDVoK3osMW0rMSwxZStmLHQrMiwxZitlLGQrMyw0byszLDJzKzEsdyw1MzUrMXIsaDNsKzFpLDkzKzIsMnMsYisxLDNsK3gsMnYsNGcrMywyMSszLGt6KzEsZzV2KzEsNWEsais5LG4rdiwyLDMsMis4LDIrMSwzKzIsMiwzLDQ2KzEsNCs0LGgrNSxyKzUscithLDNoKzIsNCs2LGIrNCw3OCwxcisyNCw0K2MsNCwxaGIsZXkrNiwxMDMraiwxNmorYywxdXgrNyw1K2csZnNoLGpkcSsxdCw0LDU3KzJlLHAxLDFtLDFtLDFtLDFtLDRrdCsxLDdqKzE3LDUrMnIsZCtlLDMrZSwyK2UsMisxMCxtKzQsdywxbis1LDFxLDR6KzUsNGIrcmIsOStjLDQrYyw0KzM3LGQrMmcsOCtiLGwrYiw1KzFqLDkrOSw3KzEzLDkrdCwzKzEsMjcrM2MsMisyOSwyKzNxLGQrZCwzKzQsNCsyLDYrNixhK28sOCs2LGErMixlKzYsMTYrNDIsMisxaVwiLFxuICAgIFwiQk5cIjogXCIwKzgsNitkLDJzKzUsMitwLGUsNG05LDFrdCsyLDJiKzUsNSs1LDE3cTkrdiw3ayw2cCs4LDYrMSwxMTlkKzMsNDQwKzcsOTZzKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzc1LDZwKzJyeiwxYmVuKzEsMWVrZisxLDFla2YrMVwiLFxuICAgIFwiTlNNXCI6IFwibGMrMzMsN28rNiw3YysxOCwyLDIrMSwyKzEsMiwyMSthLDFkK2ssaCwydSs2LDMrNSwzKzEsMiszLDEwLHYrcSwyaythLDFuKzgsYSxwKzMsMis4LDIrMiwyKzQsMTgrMiwzYytlLDIrdiwxaywyLDUrNyw1LDQrNixiKzEsdSwxbiw1KzMsOSxsKzEsciwzKzEsMW0sNSsxLDUrMSwzKzIsNCx2KzEsNCxjKzEsMW0sNSs0LDIrMSw1LGwrMSxuKzUsMiwxbiwzLDIrMyw5LDgrMSxjKzEsdiwxcSxkLDFmLDQsMW0rMiw2KzIsMiszLDgrMSxjKzEsdSwxbixnKzEsbCsxLHQrMSwxbSsxLDUrMyw5LGwrMSx1LDIxLDgrMiwyLDJqLDMrNixkKzcsMnIsMys4LGMrNSwyMysxLHMsMiwyLDFrK2QsMis0LDIrMSw2K2EsMit6LGEsMnYrMywyKzUsMisxLDMrMSxxKzEsNSsyLGgrMyxlLDMrMSw3LGcsamsrMixxYisyLHUrMix1KzEsdisxLDF0KzEsMis2LDksMythLGEsMWErMiwzYysxLHosM2IrMiw1KzEsYSw3KzIsNjQrMSwzLDFuLDIrNiwyLDIsMys3LDcrOSwzLDFkK2csMXMrMywxZCwyKzQsMiw2LDE1KzgsZCsxLHgrMywzKzEsMisyLDFsLDIrMSw0LDIrMiwxbis3LDMrMSw0OSsyLDIrYywyKzYsNSw3LDQrMSw1aisxbCwyKzQsazErdywyZGIrMiwzeSwycCt2LGZmKzMsMzArMSxuOXgrMywyKzkseCsxLDI5KzEsN2wsNCw1LHErMSw2LDQ4KzEscitoLGUsMTMrNyxxK2EsMWIrMiwxZCwzKzMsMysxLDE0LDF3KzUsMysxLDMrMSxkLDksMWMsMWcsMisyLDMrMSw2KzEsMiwxNysxLDksNm4sMyw1LGZuNSxraStmLGgrZixyMiw2Yiw0Nis0LDFhZisyLDIrMSw2KzMsMTUrMiw1LDRtKzEsZnkrMyxhcysxLDRhK2EsNHgsMWorZSwxbCsyLDFlKzMsMysxLDF5KzIsMTErNCwyKzcsMXIsZCsxLDFoKzgsYiszLDMsMm8rMiwzLDIrMSw3LDRoLDQrNyxtKzEsMW0rMSw0LDEyKzYsNCs0LDVnKzcsMysyLDIsbywyZCs1LDIsNSsxLDIrMSw2biszLDcrMSwyKzEscysxLDJlKzcsMywyKzEsMnosMiwzKzUsMiwydSsyLDMrMywyKzQsNzgrOCwyKzEsNzUrMSwyLDUsNDErMywzKzEsNSx4KzUsMysxLDE1KzUsMyszLDksYSs1LDMrMiwxYitjLDIrMSxiYis2LDIrNSwyZCtsLDMrNiwyKzEsMisxLDNmKzUsNCwyKzEsMis2LDIsMjErMSw0LDIsOW8rMSxmMGMrNCwxbys2LHQ1LDFzKzMsMmEsZjVsKzEsNDN0KzIsaSs3LDMrNix2KzMsNDUrMiwxajArMWksNSsxZCw5LGYsbis0LDIrZSwxMXQrNiwyK2csMys2LDIrMSwyKzQsN2ErNixjNiszLDE1dCs2LDMyKzYsZ3poeSs2blwiLFxuICAgIFwiQUxcIjogXCIxNncsMywyLGUrMWIseisyLDIrMnMsZysxLDgrMSxiK20sMit0LHMrMmksYytlLDRoK2YsMWQrMWUsMWJ3ZStkcCwzKzN6LHgrYywyKzEsMzUrM3ksMnJtK3osNSs3LGIrNSxkdCtsLGMrdSwxN25sKzI3LDF0KzI3LDR4KzZuLDMrZFwiLFxuICAgIFwiTFJPXCI6IFwiNmN0XCIsXG4gICAgXCJSTE9cIjogXCI2Y3VcIixcbiAgICBcIkxSRVwiOiBcIjZjcVwiLFxuICAgIFwiUkxFXCI6IFwiNmNyXCIsXG4gICAgXCJQREZcIjogXCI2Y3NcIixcbiAgICBcIkxSSVwiOiBcIjZlZVwiLFxuICAgIFwiUkxJXCI6IFwiNmVmXCIsXG4gICAgXCJGU0lcIjogXCI2ZWdcIixcbiAgICBcIlBESVwiOiBcIjZlaFwiXG4gIH07XG5cbiAgdmFyIFRZUEVTID0ge307XG4gIHZhciBUWVBFU19UT19OQU1FUyA9IHt9O1xuICBUWVBFUy5MID0gMTsgLy9MIGlzIHRoZSBkZWZhdWx0XG4gIFRZUEVTX1RPX05BTUVTWzFdID0gJ0wnO1xuICBPYmplY3Qua2V5cyhEQVRBKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpKSB7XG4gICAgVFlQRVNbdHlwZV0gPSAxIDw8IChpICsgMSk7XG4gICAgVFlQRVNfVE9fTkFNRVNbVFlQRVNbdHlwZV1dID0gdHlwZTtcbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoVFlQRVMpO1xuXG4gIHZhciBJU09MQVRFX0lOSVRfVFlQRVMgPSBUWVBFUy5MUkkgfCBUWVBFUy5STEkgfCBUWVBFUy5GU0k7XG4gIHZhciBTVFJPTkdfVFlQRVMgPSBUWVBFUy5MIHwgVFlQRVMuUiB8IFRZUEVTLkFMO1xuICB2YXIgTkVVVFJBTF9JU09MQVRFX1RZUEVTID0gVFlQRVMuQiB8IFRZUEVTLlMgfCBUWVBFUy5XUyB8IFRZUEVTLk9OIHwgVFlQRVMuRlNJIHwgVFlQRVMuTFJJIHwgVFlQRVMuUkxJIHwgVFlQRVMuUERJO1xuICB2YXIgQk5fTElLRV9UWVBFUyA9IFRZUEVTLkJOIHwgVFlQRVMuUkxFIHwgVFlQRVMuTFJFIHwgVFlQRVMuUkxPIHwgVFlQRVMuTFJPIHwgVFlQRVMuUERGO1xuICB2YXIgVFJBSUxJTkdfVFlQRVMgPSBUWVBFUy5TIHwgVFlQRVMuV1MgfCBUWVBFUy5CIHwgSVNPTEFURV9JTklUX1RZUEVTIHwgVFlQRVMuUERJIHwgQk5fTElLRV9UWVBFUztcblxuICB2YXIgbWFwID0gbnVsbDtcblxuICBmdW5jdGlvbiBwYXJzZURhdGEgKCkge1xuICAgIGlmICghbWFwKSB7XG4gICAgICAvL2NvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCB0eXBlICkge1xuICAgICAgICBpZiAoREFUQS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgICAgICAgIHZhciBsYXN0Q29kZSA9IDA7XG4gICAgICAgICAgREFUQVt0eXBlXS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgcmVmID0gcmFuZ2Uuc3BsaXQoJysnKTtcbiAgICAgICAgICAgIHZhciBza2lwID0gcmVmWzBdO1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSByZWZbMV07XG4gICAgICAgICAgICBza2lwID0gcGFyc2VJbnQoc2tpcCwgMzYpO1xuICAgICAgICAgICAgc3RlcCA9IHN0ZXAgPyBwYXJzZUludChzdGVwLCAzNikgOiAwO1xuICAgICAgICAgICAgbWFwLnNldChsYXN0Q29kZSArPSBza2lwLCBUWVBFU1t0eXBlXSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ZXA7IGkrKykge1xuICAgICAgICAgICAgICBtYXAuc2V0KCsrbGFzdENvZGUsIFRZUEVTW3R5cGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgdHlwZSBpbiBEQVRBKSBsb29wKCB0eXBlICk7XG4gICAgICAvL2NvbnNvbGUubG9nKGBjaGFyIHR5cGVzIHBhcnNlZCBpbiAke3BlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnR9bXNgKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRCaWRpQ2hhclR5cGUgKGNoYXIpIHtcbiAgICBwYXJzZURhdGEoKTtcbiAgICByZXR1cm4gbWFwLmdldChjaGFyLmNvZGVQb2ludEF0KDApKSB8fCBUWVBFUy5MXG4gIH1cblxuICBmdW5jdGlvbiBnZXRCaWRpQ2hhclR5cGVOYW1lKGNoYXIpIHtcbiAgICByZXR1cm4gVFlQRVNfVE9fTkFNRVNbZ2V0QmlkaUNoYXJUeXBlKGNoYXIpXVxuICB9XG5cbiAgLy8gQmlkaSBicmFja2V0IHBhaXJzIGRhdGEsIGF1dG8gZ2VuZXJhdGVkXG4gIHZhciBkYXRhJDEgPSB7XG4gICAgXCJwYWlyc1wiOiBcIjE0PjEsMWU+Mix1PjIsMnd0PjEsMT4xLDFnZT4xLDF3cD4xLDFqPjEsZj4xLGhtPjEsMT4xLHU+MSx1Nj4xLDE+MSwrNSwyOD4xLHc+MSwxPjEsKzMsYjg+MSwxPjEsKzMsMT4zLC0xPi0xLDM+MSwxPjEsKzIsMXM+MSwxPjEseD4xLHRoPjEsMT4xLCsyLGRiPjEsMT4xLCszLDM+MSwxPjEsKzIsMTRxbT4xLDE+MSwrMSw0cT4xLDFlPjIsdT4yLDI+MSwrMVwiLFxuICAgIFwiY2Fub25pY2FsXCI6IFwiNmYxPi02ZHgsNmR5Pi02ZHgsNmVjPi02ZWQsNmVlPi02ZWQsNnd3PjJqaiwtMmppPjJqaiwxNHI0Pi0xZTdsLDFlN20+LTFlN2wsMWU3bT4tMWU1YywxZTVkPi0xZTViLDFlNWM+LTE0cXgsMTRxeT4tMTRxeCwxNHZuPi0xZWNnLDFlY2g+LTFlY2csMWVkdT4tMWVjZywxZWNpPi0xZWNnLDFlZGE+LTFlY2csMWVjaT4tMWVjZywxZWNpPi0xNjhxLDE2OHI+LTE2OHEsMTY4cz4tMTR5ZSwxNHlmPi0xNHllXCJcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGFuIHN0cmluZyB0aGF0IGhvbGRzIGVuY29kZWQgY29kZXBvaW50IG1hcHBpbmdzLCBlLmcuIGZvciBicmFja2V0IHBhaXJzIG9yXG4gICAqIG1pcnJvcmluZyBjaGFyYWN0ZXJzLCBhcyBlbmNvZGVkIGJ5IHNjcmlwdHMvZ2VuZXJhdGVCaWRpRGF0YS5qcy4gUmV0dXJucyBhbiBvYmplY3RcbiAgICogaG9sZGluZyB0aGUgYG1hcGAsIGFuZCBvcHRpb25hbGx5IGEgYHJldmVyc2VNYXBgIGlmIGBpbmNsdWRlUmV2ZXJzZTp0cnVlYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuY29kZWRTdHJpbmdcbiAgICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlUmV2ZXJzZSAtIHRydWUgaWYgeW91IHdhbnQgcmV2ZXJzZU1hcCBpbiB0aGUgb3V0cHV0XG4gICAqIEByZXR1cm4ge3ttYXA6IE1hcDxudW1iZXIsIG51bWJlcj4sIHJldmVyc2VNYXA/OiBNYXA8bnVtYmVyLCBudW1iZXI+fX1cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlQ2hhcmFjdGVyTWFwIChlbmNvZGVkU3RyaW5nLCBpbmNsdWRlUmV2ZXJzZSkge1xuICAgIHZhciByYWRpeCA9IDM2O1xuICAgIHZhciBsYXN0Q29kZSA9IDA7XG4gICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICB2YXIgcmV2ZXJzZU1hcCA9IGluY2x1ZGVSZXZlcnNlICYmIG5ldyBNYXAoKTtcbiAgICB2YXIgcHJldlBhaXI7XG4gICAgZW5jb2RlZFN0cmluZy5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gdmlzaXQoZW50cnkpIHtcbiAgICAgIGlmIChlbnRyeS5pbmRleE9mKCcrJykgIT09IC0xKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSArZW50cnk7IGktLTspIHtcbiAgICAgICAgICB2aXNpdChwcmV2UGFpcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZQYWlyID0gZW50cnk7XG4gICAgICAgIHZhciByZWYgPSBlbnRyeS5zcGxpdCgnPicpO1xuICAgICAgICB2YXIgYSA9IHJlZlswXTtcbiAgICAgICAgdmFyIGIgPSByZWZbMV07XG4gICAgICAgIGEgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChsYXN0Q29kZSArPSBwYXJzZUludChhLCByYWRpeCkpO1xuICAgICAgICBiID0gU3RyaW5nLmZyb21Db2RlUG9pbnQobGFzdENvZGUgKz0gcGFyc2VJbnQoYiwgcmFkaXgpKTtcbiAgICAgICAgbWFwLnNldChhLCBiKTtcbiAgICAgICAgaW5jbHVkZVJldmVyc2UgJiYgcmV2ZXJzZU1hcC5zZXQoYiwgYSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgbWFwOiBtYXAsIHJldmVyc2VNYXA6IHJldmVyc2VNYXAgfVxuICB9XG5cbiAgdmFyIG9wZW5Ub0Nsb3NlLCBjbG9zZVRvT3BlbiwgY2Fub25pY2FsO1xuXG4gIGZ1bmN0aW9uIHBhcnNlJDEgKCkge1xuICAgIGlmICghb3BlblRvQ2xvc2UpIHtcbiAgICAgIC8vY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgdmFyIHJlZiA9IHBhcnNlQ2hhcmFjdGVyTWFwKGRhdGEkMS5wYWlycywgdHJ1ZSk7XG4gICAgICB2YXIgbWFwID0gcmVmLm1hcDtcbiAgICAgIHZhciByZXZlcnNlTWFwID0gcmVmLnJldmVyc2VNYXA7XG4gICAgICBvcGVuVG9DbG9zZSA9IG1hcDtcbiAgICAgIGNsb3NlVG9PcGVuID0gcmV2ZXJzZU1hcDtcbiAgICAgIGNhbm9uaWNhbCA9IHBhcnNlQ2hhcmFjdGVyTWFwKGRhdGEkMS5jYW5vbmljYWwsIGZhbHNlKS5tYXA7XG4gICAgICAvL2NvbnNvbGUubG9nKGBicmFja2V0cyBwYXJzZWQgaW4gJHtwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0fW1zYClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvcGVuaW5nVG9DbG9zaW5nQnJhY2tldCAoY2hhcikge1xuICAgIHBhcnNlJDEoKTtcbiAgICByZXR1cm4gb3BlblRvQ2xvc2UuZ2V0KGNoYXIpIHx8IG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NpbmdUb09wZW5pbmdCcmFja2V0IChjaGFyKSB7XG4gICAgcGFyc2UkMSgpO1xuICAgIHJldHVybiBjbG9zZVRvT3Blbi5nZXQoY2hhcikgfHwgbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2Fub25pY2FsQnJhY2tldCAoY2hhcikge1xuICAgIHBhcnNlJDEoKTtcbiAgICByZXR1cm4gY2Fub25pY2FsLmdldChjaGFyKSB8fCBudWxsXG4gIH1cblxuICAvLyBMb2NhbCB0eXBlIGFsaWFzZXNcbiAgdmFyIFRZUEVfTCA9IFRZUEVTLkw7XG4gIHZhciBUWVBFX1IgPSBUWVBFUy5SO1xuICB2YXIgVFlQRV9FTiA9IFRZUEVTLkVOO1xuICB2YXIgVFlQRV9FUyA9IFRZUEVTLkVTO1xuICB2YXIgVFlQRV9FVCA9IFRZUEVTLkVUO1xuICB2YXIgVFlQRV9BTiA9IFRZUEVTLkFOO1xuICB2YXIgVFlQRV9DUyA9IFRZUEVTLkNTO1xuICB2YXIgVFlQRV9CID0gVFlQRVMuQjtcbiAgdmFyIFRZUEVfUyA9IFRZUEVTLlM7XG4gIHZhciBUWVBFX09OID0gVFlQRVMuT047XG4gIHZhciBUWVBFX0JOID0gVFlQRVMuQk47XG4gIHZhciBUWVBFX05TTSA9IFRZUEVTLk5TTTtcbiAgdmFyIFRZUEVfQUwgPSBUWVBFUy5BTDtcbiAgdmFyIFRZUEVfTFJPID0gVFlQRVMuTFJPO1xuICB2YXIgVFlQRV9STE8gPSBUWVBFUy5STE87XG4gIHZhciBUWVBFX0xSRSA9IFRZUEVTLkxSRTtcbiAgdmFyIFRZUEVfUkxFID0gVFlQRVMuUkxFO1xuICB2YXIgVFlQRV9QREYgPSBUWVBFUy5QREY7XG4gIHZhciBUWVBFX0xSSSA9IFRZUEVTLkxSSTtcbiAgdmFyIFRZUEVfUkxJID0gVFlQRVMuUkxJO1xuICB2YXIgVFlQRV9GU0kgPSBUWVBFUy5GU0k7XG4gIHZhciBUWVBFX1BESSA9IFRZUEVTLlBESTtcblxuICAvKipcbiAgICogQHR5cGVkZWYge29iamVjdH0gR2V0RW1iZWRkaW5nTGV2ZWxzUmVzdWx0XG4gICAqIEBwcm9wZXJ0eSB7e3N0YXJ0LCBlbmQsIGxldmVsfVtdfSBwYXJhZ3JhcGhzXG4gICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gbGV2ZWxzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFwcGxpZXMgdGhlIEJpZGlyZWN0aW9uYWwgQWxnb3JpdGhtIHRvIGEgc3RyaW5nLCByZXR1cm5pbmcgdGhlIHJlc29sdmVkIGVtYmVkZGluZyBsZXZlbHNcbiAgICogaW4gYSBzaW5nbGUgVWludDhBcnJheSBwbHVzIGEgbGlzdCBvZiBvYmplY3RzIGhvbGRpbmcgZWFjaCBwYXJhZ3JhcGgncyBzdGFydCBhbmQgZW5kIGluZGljZXMgYW5kIHJlc29sdmVkXG4gICAqIGJhc2UgZW1iZWRkaW5nIGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gVGhlIGlucHV0IHN0cmluZ1xuICAgKiBAcGFyYW0ge1wibHRyXCJ8XCJydGxcInxcImF1dG9cIn0gW2Jhc2VEaXJlY3Rpb25dIC0gVXNlIFwibHRyXCIgb3IgXCJydGxcIiB0byBmb3JjZSBhIGJhc2UgcGFyYWdyYXBoIGRpcmVjdGlvbixcbiAgICogICAgICAgIG90aGVyd2lzZSBhIGRpcmVjdGlvbiB3aWxsIGJlIGNob3NlbiBhdXRvbWF0aWNhbGx5IGZyb20gZWFjaCBwYXJhZ3JhcGgncyBjb250ZW50cy5cbiAgICogQHJldHVybiB7R2V0RW1iZWRkaW5nTGV2ZWxzUmVzdWx0fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0RW1iZWRkaW5nTGV2ZWxzIChzdHJpbmcsIGJhc2VEaXJlY3Rpb24pIHtcbiAgICB2YXIgTUFYX0RFUFRIID0gMTI1O1xuXG4gICAgLy8gU3RhcnQgYnkgbWFwcGluZyBhbGwgY2hhcmFjdGVycyB0byB0aGVpciB1bmljb2RlIHR5cGUsIGFzIGEgYml0bWFzayBpbnRlZ2VyXG4gICAgdmFyIGNoYXJUeXBlcyA9IG5ldyBVaW50MzJBcnJheShzdHJpbmcubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhclR5cGVzW2ldID0gZ2V0QmlkaUNoYXJUeXBlKHN0cmluZ1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIGNoYXJUeXBlQ291bnRzID0gbmV3IE1hcCgpOyAvL3dpbGwgYmUgY2xlYXJlZCBhdCBzdGFydCBvZiBlYWNoIHBhcmFncmFwaFxuICAgIGZ1bmN0aW9uIGNoYW5nZUNoYXJUeXBlKGksIHR5cGUpIHtcbiAgICAgIHZhciBvbGRUeXBlID0gY2hhclR5cGVzW2ldO1xuICAgICAgY2hhclR5cGVzW2ldID0gdHlwZTtcbiAgICAgIGNoYXJUeXBlQ291bnRzLnNldChvbGRUeXBlLCBjaGFyVHlwZUNvdW50cy5nZXQob2xkVHlwZSkgLSAxKTtcbiAgICAgIGlmIChvbGRUeXBlICYgTkVVVFJBTF9JU09MQVRFX1RZUEVTKSB7XG4gICAgICAgIGNoYXJUeXBlQ291bnRzLnNldChORVVUUkFMX0lTT0xBVEVfVFlQRVMsIGNoYXJUeXBlQ291bnRzLmdldChORVVUUkFMX0lTT0xBVEVfVFlQRVMpIC0gMSk7XG4gICAgICB9XG4gICAgICBjaGFyVHlwZUNvdW50cy5zZXQodHlwZSwgKGNoYXJUeXBlQ291bnRzLmdldCh0eXBlKSB8fCAwKSArIDEpO1xuICAgICAgaWYgKHR5cGUgJiBORVVUUkFMX0lTT0xBVEVfVFlQRVMpIHtcbiAgICAgICAgY2hhclR5cGVDb3VudHMuc2V0KE5FVVRSQUxfSVNPTEFURV9UWVBFUywgKGNoYXJUeXBlQ291bnRzLmdldChORVVUUkFMX0lTT0xBVEVfVFlQRVMpIHx8IDApICsgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVtYmVkTGV2ZWxzID0gbmV3IFVpbnQ4QXJyYXkoc3RyaW5nLmxlbmd0aCk7XG4gICAgdmFyIGlzb2xhdGlvblBhaXJzID0gbmV3IE1hcCgpOyAvL2luaXQtPnBkaSBhbmQgcGRpLT5pbml0XG5cbiAgICAvLyA9PT0gMy4zLjEgVGhlIFBhcmFncmFwaCBMZXZlbCA9PT1cbiAgICAvLyAzLjMuMSBQMTogU3BsaXQgdGhlIHRleHQgaW50byBwYXJhZ3JhcGhzXG4gICAgdmFyIHBhcmFncmFwaHMgPSBbXTsgLy8gW3tzdGFydCwgZW5kLCBsZXZlbH0sIC4uLl1cbiAgICB2YXIgcGFyYWdyYXBoID0gbnVsbDtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBzdHJpbmcubGVuZ3RoOyBpJDErKykge1xuICAgICAgaWYgKCFwYXJhZ3JhcGgpIHtcbiAgICAgICAgcGFyYWdyYXBocy5wdXNoKHBhcmFncmFwaCA9IHtcbiAgICAgICAgICBzdGFydDogaSQxLFxuICAgICAgICAgIGVuZDogc3RyaW5nLmxlbmd0aCAtIDEsXG4gICAgICAgICAgLy8gMy4zLjEgUDItUDM6IERldGVybWluZSB0aGUgcGFyYWdyYXBoIGxldmVsXG4gICAgICAgICAgbGV2ZWw6IGJhc2VEaXJlY3Rpb24gPT09ICdydGwnID8gMSA6IGJhc2VEaXJlY3Rpb24gPT09ICdsdHInID8gMCA6IGRldGVybWluZUF1dG9FbWJlZExldmVsKGkkMSwgZmFsc2UpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXJUeXBlc1tpJDFdICYgVFlQRV9CKSB7XG4gICAgICAgIHBhcmFncmFwaC5lbmQgPSBpJDE7XG4gICAgICAgIHBhcmFncmFwaCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIEZPUk1BVFRJTkdfVFlQRVMgPSBUWVBFX1JMRSB8IFRZUEVfTFJFIHwgVFlQRV9STE8gfCBUWVBFX0xSTyB8IElTT0xBVEVfSU5JVF9UWVBFUyB8IFRZUEVfUERJIHwgVFlQRV9QREYgfCBUWVBFX0I7XG4gICAgdmFyIG5leHRFdmVuID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4gKyAoKG4gJiAxKSA/IDEgOiAyKTsgfTtcbiAgICB2YXIgbmV4dE9kZCA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBuICsgKChuICYgMSkgPyAyIDogMSk7IH07XG5cbiAgICAvLyBFdmVyeXRoaW5nIGZyb20gaGVyZSBvbiB3aWxsIG9wZXJhdGUgcGVyIHBhcmFncmFwaC5cbiAgICBmb3IgKHZhciBwYXJhSWR4ID0gMDsgcGFyYUlkeCA8IHBhcmFncmFwaHMubGVuZ3RoOyBwYXJhSWR4KyspIHtcbiAgICAgIHBhcmFncmFwaCA9IHBhcmFncmFwaHNbcGFyYUlkeF07XG4gICAgICB2YXIgc3RhdHVzU3RhY2sgPSBbe1xuICAgICAgICBfbGV2ZWw6IHBhcmFncmFwaC5sZXZlbCxcbiAgICAgICAgX292ZXJyaWRlOiAwLCAvLzA9bmV1dHJhbCwgMT1MLCAyPVJcbiAgICAgICAgX2lzb2xhdGU6IDAgLy9ib29sXG4gICAgICB9XTtcbiAgICAgIHZhciBzdGFja1RvcCA9ICh2b2lkIDApO1xuICAgICAgdmFyIG92ZXJmbG93SXNvbGF0ZUNvdW50ID0gMDtcbiAgICAgIHZhciBvdmVyZmxvd0VtYmVkZGluZ0NvdW50ID0gMDtcbiAgICAgIHZhciB2YWxpZElzb2xhdGVDb3VudCA9IDA7XG4gICAgICBjaGFyVHlwZUNvdW50cy5jbGVhcigpO1xuXG4gICAgICAvLyA9PT0gMy4zLjIgRXhwbGljaXQgTGV2ZWxzIGFuZCBEaXJlY3Rpb25zID09PVxuICAgICAgZm9yICh2YXIgaSQyID0gcGFyYWdyYXBoLnN0YXJ0OyBpJDIgPD0gcGFyYWdyYXBoLmVuZDsgaSQyKyspIHtcbiAgICAgICAgdmFyIGNoYXJUeXBlID0gY2hhclR5cGVzW2kkMl07XG4gICAgICAgIHN0YWNrVG9wID0gc3RhdHVzU3RhY2tbc3RhdHVzU3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAgICAgLy8gU2V0IGluaXRpYWwgY291bnRzXG4gICAgICAgIGNoYXJUeXBlQ291bnRzLnNldChjaGFyVHlwZSwgKGNoYXJUeXBlQ291bnRzLmdldChjaGFyVHlwZSkgfHwgMCkgKyAxKTtcbiAgICAgICAgaWYgKGNoYXJUeXBlICYgTkVVVFJBTF9JU09MQVRFX1RZUEVTKSB7XG4gICAgICAgICAgY2hhclR5cGVDb3VudHMuc2V0KE5FVVRSQUxfSVNPTEFURV9UWVBFUywgKGNoYXJUeXBlQ291bnRzLmdldChORVVUUkFMX0lTT0xBVEVfVFlQRVMpIHx8IDApICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHBsaWNpdCBFbWJlZGRpbmdzOiAzLjMuMiBYMiAtIFgzXG4gICAgICAgIGlmIChjaGFyVHlwZSAmIEZPUk1BVFRJTkdfVFlQRVMpIHsgLy9wcmVmaWx0ZXIgYWxsIGZvcm1hdHRlcnNcbiAgICAgICAgICBpZiAoY2hhclR5cGUgJiAoVFlQRV9STEUgfCBUWVBFX0xSRSkpIHtcbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMl0gPSBzdGFja1RvcC5fbGV2ZWw7IC8vIDUuMlxuICAgICAgICAgICAgdmFyIGxldmVsID0gKGNoYXJUeXBlID09PSBUWVBFX1JMRSA/IG5leHRPZGQgOiBuZXh0RXZlbikoc3RhY2tUb3AuX2xldmVsKTtcbiAgICAgICAgICAgIGlmIChsZXZlbCA8PSBNQVhfREVQVEggJiYgIW92ZXJmbG93SXNvbGF0ZUNvdW50ICYmICFvdmVyZmxvd0VtYmVkZGluZ0NvdW50KSB7XG4gICAgICAgICAgICAgIHN0YXR1c1N0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIF9sZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICAgICAgX292ZXJyaWRlOiAwLFxuICAgICAgICAgICAgICAgIF9pc29sYXRlOiAwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghb3ZlcmZsb3dJc29sYXRlQ291bnQpIHtcbiAgICAgICAgICAgICAgb3ZlcmZsb3dFbWJlZGRpbmdDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEV4cGxpY2l0IE92ZXJyaWRlczogMy4zLjIgWDQgLSBYNVxuICAgICAgICAgIGVsc2UgaWYgKGNoYXJUeXBlICYgKFRZUEVfUkxPIHwgVFlQRV9MUk8pKSB7XG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDJdID0gc3RhY2tUb3AuX2xldmVsOyAvLyA1LjJcbiAgICAgICAgICAgIHZhciBsZXZlbCQxID0gKGNoYXJUeXBlID09PSBUWVBFX1JMTyA/IG5leHRPZGQgOiBuZXh0RXZlbikoc3RhY2tUb3AuX2xldmVsKTtcbiAgICAgICAgICAgIGlmIChsZXZlbCQxIDw9IE1BWF9ERVBUSCAmJiAhb3ZlcmZsb3dJc29sYXRlQ291bnQgJiYgIW92ZXJmbG93RW1iZWRkaW5nQ291bnQpIHtcbiAgICAgICAgICAgICAgc3RhdHVzU3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgX2xldmVsOiBsZXZlbCQxLFxuICAgICAgICAgICAgICAgIF9vdmVycmlkZTogKGNoYXJUeXBlICYgVFlQRV9STE8pID8gVFlQRV9SIDogVFlQRV9MLFxuICAgICAgICAgICAgICAgIF9pc29sYXRlOiAwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghb3ZlcmZsb3dJc29sYXRlQ291bnQpIHtcbiAgICAgICAgICAgICAgb3ZlcmZsb3dFbWJlZGRpbmdDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElzb2xhdGVzOiAzLjMuMiBYNWEgLSBYNWNcbiAgICAgICAgICBlbHNlIGlmIChjaGFyVHlwZSAmIElTT0xBVEVfSU5JVF9UWVBFUykge1xuICAgICAgICAgICAgLy8gWDVjIC0gRlNJIGJlY29tZXMgZWl0aGVyIFJMSSBvciBMUklcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZSAmIFRZUEVfRlNJKSB7XG4gICAgICAgICAgICAgIGNoYXJUeXBlID0gZGV0ZXJtaW5lQXV0b0VtYmVkTGV2ZWwoaSQyICsgMSwgdHJ1ZSkgPT09IDEgPyBUWVBFX1JMSSA6IFRZUEVfTFJJO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDJdID0gc3RhY2tUb3AuX2xldmVsO1xuICAgICAgICAgICAgaWYgKHN0YWNrVG9wLl9vdmVycmlkZSkge1xuICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDIsIHN0YWNrVG9wLl9vdmVycmlkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGV2ZWwkMiA9IChjaGFyVHlwZSA9PT0gVFlQRV9STEkgPyBuZXh0T2RkIDogbmV4dEV2ZW4pKHN0YWNrVG9wLl9sZXZlbCk7XG4gICAgICAgICAgICBpZiAobGV2ZWwkMiA8PSBNQVhfREVQVEggJiYgb3ZlcmZsb3dJc29sYXRlQ291bnQgPT09IDAgJiYgb3ZlcmZsb3dFbWJlZGRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICB2YWxpZElzb2xhdGVDb3VudCsrO1xuICAgICAgICAgICAgICBzdGF0dXNTdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICBfbGV2ZWw6IGxldmVsJDIsXG4gICAgICAgICAgICAgICAgX292ZXJyaWRlOiAwLFxuICAgICAgICAgICAgICAgIF9pc29sYXRlOiAxLFxuICAgICAgICAgICAgICAgIF9pc29sSW5pdEluZGV4OiBpJDJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdmVyZmxvd0lzb2xhdGVDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRlcm1pbmF0aW5nIElzb2xhdGVzOiAzLjMuMiBYNmFcbiAgICAgICAgICBlbHNlIGlmIChjaGFyVHlwZSAmIFRZUEVfUERJKSB7XG4gICAgICAgICAgICBpZiAob3ZlcmZsb3dJc29sYXRlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgIG92ZXJmbG93SXNvbGF0ZUNvdW50LS07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbGlkSXNvbGF0ZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICBvdmVyZmxvd0VtYmVkZGluZ0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgd2hpbGUgKCFzdGF0dXNTdGFja1tzdGF0dXNTdGFjay5sZW5ndGggLSAxXS5faXNvbGF0ZSkge1xuICAgICAgICAgICAgICAgIHN0YXR1c1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEFkZCB0byBpc29sYXRpb24gcGFpcnMgYmlkaXJlY3Rpb25hbCBtYXBwaW5nOlxuICAgICAgICAgICAgICB2YXIgaXNvbEluaXRJbmRleCA9IHN0YXR1c1N0YWNrW3N0YXR1c1N0YWNrLmxlbmd0aCAtIDFdLl9pc29sSW5pdEluZGV4O1xuICAgICAgICAgICAgICBpZiAoaXNvbEluaXRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXNvbGF0aW9uUGFpcnMuc2V0KGlzb2xJbml0SW5kZXgsIGkkMik7XG4gICAgICAgICAgICAgICAgaXNvbGF0aW9uUGFpcnMuc2V0KGkkMiwgaXNvbEluaXRJbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdHVzU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIHZhbGlkSXNvbGF0ZUNvdW50LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFja1RvcCA9IHN0YXR1c1N0YWNrW3N0YXR1c1N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQyXSA9IHN0YWNrVG9wLl9sZXZlbDtcbiAgICAgICAgICAgIGlmIChzdGFja1RvcC5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQyLCBzdGFja1RvcC5fb3ZlcnJpZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgLy8gVGVybWluYXRpbmcgRW1iZWRkaW5ncyBhbmQgT3ZlcnJpZGVzOiAzLjMuMiBYN1xuICAgICAgICAgIGVsc2UgaWYgKGNoYXJUeXBlICYgVFlQRV9QREYpIHtcbiAgICAgICAgICAgIGlmIChvdmVyZmxvd0lzb2xhdGVDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICBpZiAob3ZlcmZsb3dFbWJlZGRpbmdDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvd0VtYmVkZGluZ0NvdW50LS07XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YWNrVG9wLl9pc29sYXRlICYmIHN0YXR1c1N0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXNTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBzdGFja1RvcCA9IHN0YXR1c1N0YWNrW3N0YXR1c1N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDJdID0gc3RhY2tUb3AuX2xldmVsOyAvLyA1LjJcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFbmQgb2YgUGFyYWdyYXBoOiAzLjMuMiBYOFxuICAgICAgICAgIGVsc2UgaWYgKGNoYXJUeXBlICYgVFlQRV9CKSB7XG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDJdID0gcGFyYWdyYXBoLmxldmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vbi1mb3JtYXR0aW5nIGNoYXJhY3RlcnM6IDMuMy4yIFg2XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMl0gPSBzdGFja1RvcC5fbGV2ZWw7XG4gICAgICAgICAgLy8gTk9URTogVGhpcyBleGNsdXNpb24gb2YgQk4gc2VlbXMgdG8gZ28gYWdhaW5zdCB3aGF0IHNlY3Rpb24gNS4yIHNheXMsIGJ1dCBpcyByZXF1aXJlZCBmb3IgdGVzdCBwYXNzYWdlXG4gICAgICAgICAgaWYgKHN0YWNrVG9wLl9vdmVycmlkZSAmJiBjaGFyVHlwZSAhPT0gVFlQRV9CTikge1xuICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQyLCBzdGFja1RvcC5fb3ZlcnJpZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyA9PT0gMy4zLjMgUHJlcGFyYXRpb25zIGZvciBJbXBsaWNpdCBQcm9jZXNzaW5nID09PVxuXG4gICAgICAvLyBSZW1vdmUgYWxsIFJMRSwgTFJFLCBSTE8sIExSTywgUERGLCBhbmQgQk4gY2hhcmFjdGVyczogMy4zLjMgWDlcbiAgICAgIC8vIE5vdGU6IER1ZSB0byBzZWN0aW9uIDUuMiwgd2Ugd29uJ3QgcmVtb3ZlIHRoZW0sIGJ1dCB3ZSdsbCB1c2UgdGhlIEJOX0xJS0VfVFlQRVMgYml0c2V0IHRvXG4gICAgICAvLyBlYXNpbHkgaWdub3JlIHRoZW0gYWxsIGZyb20gaGVyZSBvbiBvdXQuXG5cbiAgICAgIC8vIDMuMy4zIFgxMFxuICAgICAgLy8gQ29tcHV0ZSB0aGUgc2V0IG9mIGlzb2xhdGluZyBydW4gc2VxdWVuY2VzIGFzIHNwZWNpZmllZCBieSBCRDEzXG4gICAgICB2YXIgbGV2ZWxSdW5zID0gW107XG4gICAgICB2YXIgY3VycmVudFJ1biA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpJDMgPSBwYXJhZ3JhcGguc3RhcnQ7IGkkMyA8PSBwYXJhZ3JhcGguZW5kOyBpJDMrKykge1xuICAgICAgICB2YXIgY2hhclR5cGUkMSA9IGNoYXJUeXBlc1tpJDNdO1xuICAgICAgICBpZiAoIShjaGFyVHlwZSQxICYgQk5fTElLRV9UWVBFUykpIHtcbiAgICAgICAgICB2YXIgbHZsID0gZW1iZWRMZXZlbHNbaSQzXTtcbiAgICAgICAgICB2YXIgaXNJc29sSW5pdCA9IGNoYXJUeXBlJDEgJiBJU09MQVRFX0lOSVRfVFlQRVM7XG4gICAgICAgICAgdmFyIGlzUERJID0gY2hhclR5cGUkMSA9PT0gVFlQRV9QREk7XG4gICAgICAgICAgaWYgKGN1cnJlbnRSdW4gJiYgbHZsID09PSBjdXJyZW50UnVuLl9sZXZlbCkge1xuICAgICAgICAgICAgY3VycmVudFJ1bi5fZW5kID0gaSQzO1xuICAgICAgICAgICAgY3VycmVudFJ1bi5fZW5kc1dpdGhJc29sSW5pdCA9IGlzSXNvbEluaXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldmVsUnVucy5wdXNoKGN1cnJlbnRSdW4gPSB7XG4gICAgICAgICAgICAgIF9zdGFydDogaSQzLFxuICAgICAgICAgICAgICBfZW5kOiBpJDMsXG4gICAgICAgICAgICAgIF9sZXZlbDogbHZsLFxuICAgICAgICAgICAgICBfc3RhcnRzV2l0aFBESTogaXNQREksXG4gICAgICAgICAgICAgIF9lbmRzV2l0aElzb2xJbml0OiBpc0lzb2xJbml0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpc29sYXRpbmdSdW5TZXFzID0gW107IC8vIFt7c2VxSW5kaWNlczogW10sIHNvc1R5cGU6IEx8UiwgZW9zVHlwZTogTHxSfV1cbiAgICAgIGZvciAodmFyIHJ1bklkeCA9IDA7IHJ1bklkeCA8IGxldmVsUnVucy5sZW5ndGg7IHJ1bklkeCsrKSB7XG4gICAgICAgIHZhciBydW4gPSBsZXZlbFJ1bnNbcnVuSWR4XTtcbiAgICAgICAgaWYgKCFydW4uX3N0YXJ0c1dpdGhQREkgfHwgKHJ1bi5fc3RhcnRzV2l0aFBESSAmJiAhaXNvbGF0aW9uUGFpcnMuaGFzKHJ1bi5fc3RhcnQpKSkge1xuICAgICAgICAgIHZhciBzZXFSdW5zID0gW2N1cnJlbnRSdW4gPSBydW5dO1xuICAgICAgICAgIGZvciAodmFyIHBkaUluZGV4ID0gKHZvaWQgMCk7IGN1cnJlbnRSdW4gJiYgY3VycmVudFJ1bi5fZW5kc1dpdGhJc29sSW5pdCAmJiAocGRpSW5kZXggPSBpc29sYXRpb25QYWlycy5nZXQoY3VycmVudFJ1bi5fZW5kKSkgIT0gbnVsbDspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkkNCA9IHJ1bklkeCArIDE7IGkkNCA8IGxldmVsUnVucy5sZW5ndGg7IGkkNCsrKSB7XG4gICAgICAgICAgICAgIGlmIChsZXZlbFJ1bnNbaSQ0XS5fc3RhcnQgPT09IHBkaUluZGV4KSB7XG4gICAgICAgICAgICAgICAgc2VxUnVucy5wdXNoKGN1cnJlbnRSdW4gPSBsZXZlbFJ1bnNbaSQ0XSk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBidWlsZCBmbGF0IGxpc3Qgb2YgaW5kaWNlcyBhY3Jvc3MgYWxsIHJ1bnM6XG4gICAgICAgICAgdmFyIHNlcUluZGljZXMgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpJDUgPSAwOyBpJDUgPCBzZXFSdW5zLmxlbmd0aDsgaSQ1KyspIHtcbiAgICAgICAgICAgIHZhciBydW4kMSA9IHNlcVJ1bnNbaSQ1XTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBydW4kMS5fc3RhcnQ7IGogPD0gcnVuJDEuX2VuZDsgaisrKSB7XG4gICAgICAgICAgICAgIHNlcUluZGljZXMucHVzaChqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBzb3MvZW9zIHR5cGVzOlxuICAgICAgICAgIHZhciBmaXJzdExldmVsID0gZW1iZWRMZXZlbHNbc2VxSW5kaWNlc1swXV07XG4gICAgICAgICAgdmFyIHByZXZMZXZlbCA9IHBhcmFncmFwaC5sZXZlbDtcbiAgICAgICAgICBmb3IgKHZhciBpJDYgPSBzZXFJbmRpY2VzWzBdIC0gMTsgaSQ2ID49IDA7IGkkNi0tKSB7XG4gICAgICAgICAgICBpZiAoIShjaGFyVHlwZXNbaSQ2XSAmIEJOX0xJS0VfVFlQRVMpKSB7IC8vNS4yXG4gICAgICAgICAgICAgIHByZXZMZXZlbCA9IGVtYmVkTGV2ZWxzW2kkNl07XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsYXN0SW5kZXggPSBzZXFJbmRpY2VzW3NlcUluZGljZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgdmFyIGxhc3RMZXZlbCA9IGVtYmVkTGV2ZWxzW2xhc3RJbmRleF07XG4gICAgICAgICAgdmFyIG5leHRMZXZlbCA9IHBhcmFncmFwaC5sZXZlbDtcbiAgICAgICAgICBpZiAoIShjaGFyVHlwZXNbbGFzdEluZGV4XSAmIElTT0xBVEVfSU5JVF9UWVBFUykpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkkNyA9IGxhc3RJbmRleCArIDE7IGkkNyA8PSBwYXJhZ3JhcGguZW5kOyBpJDcrKykge1xuICAgICAgICAgICAgICBpZiAoIShjaGFyVHlwZXNbaSQ3XSAmIEJOX0xJS0VfVFlQRVMpKSB7IC8vNS4yXG4gICAgICAgICAgICAgICAgbmV4dExldmVsID0gZW1iZWRMZXZlbHNbaSQ3XTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzb2xhdGluZ1J1blNlcXMucHVzaCh7XG4gICAgICAgICAgICBfc2VxSW5kaWNlczogc2VxSW5kaWNlcyxcbiAgICAgICAgICAgIF9zb3NUeXBlOiBNYXRoLm1heChwcmV2TGV2ZWwsIGZpcnN0TGV2ZWwpICUgMiA/IFRZUEVfUiA6IFRZUEVfTCxcbiAgICAgICAgICAgIF9lb3NUeXBlOiBNYXRoLm1heChuZXh0TGV2ZWwsIGxhc3RMZXZlbCkgJSAyID8gVFlQRV9SIDogVFlQRV9MXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIG5leHQgc3RlcHMgYXJlIGRvbmUgcGVyIGlzb2xhdGluZyBydW4gc2VxdWVuY2VcbiAgICAgIGZvciAodmFyIHNlcUlkeCA9IDA7IHNlcUlkeCA8IGlzb2xhdGluZ1J1blNlcXMubGVuZ3RoOyBzZXFJZHgrKykge1xuICAgICAgICB2YXIgcmVmID0gaXNvbGF0aW5nUnVuU2Vxc1tzZXFJZHhdO1xuICAgICAgICB2YXIgc2VxSW5kaWNlcyQxID0gcmVmLl9zZXFJbmRpY2VzO1xuICAgICAgICB2YXIgc29zVHlwZSA9IHJlZi5fc29zVHlwZTtcbiAgICAgICAgdmFyIGVvc1R5cGUgPSByZWYuX2Vvc1R5cGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgdGhlIGxldmVsIHJ1bnMgaW4gYW4gaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZSBoYXZlIHRoZSBzYW1lIGVtYmVkZGluZyBsZXZlbC5cbiAgICAgICAgICogXG4gICAgICAgICAqIERPIE5PVCBjaGFuZ2UgYW55IGBlbWJlZExldmVsc1tpXWAgd2l0aGluIHRoZSBjdXJyZW50IHNjb3BlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGVtYmVkRGlyZWN0aW9uID0gKChlbWJlZExldmVsc1tzZXFJbmRpY2VzJDFbMF1dKSAmIDEpID8gVFlQRV9SIDogVFlQRV9MO1xuXG4gICAgICAgIC8vID09PSAzLjMuNCBSZXNvbHZpbmcgV2VhayBUeXBlcyA9PT1cblxuICAgICAgICAvLyBXMSArIDUuMi4gU2VhcmNoIGJhY2t3YXJkIGZyb20gZWFjaCBOU00gdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZSB3aG9zZVxuICAgICAgICAvLyBiaWRpcmVjdGlvbmFsIHR5cGUgaXMgbm90IEJOLCBhbmQgc2V0IHRoZSBOU00gdG8gT04gaWYgaXQgaXMgYW4gaXNvbGF0ZSBpbml0aWF0b3Igb3IgUERJLCBhbmQgdG8gaXRzXG4gICAgICAgIC8vIHR5cGUgb3RoZXJ3aXNlLiBJZiB0aGUgTlNNIGlzIHRoZSBmaXJzdCBub24tQk4gY2hhcmFjdGVyLCBjaGFuZ2UgdGhlIE5TTSB0byB0aGUgdHlwZSBvZiBzb3MuXG4gICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9OU00pKSB7XG4gICAgICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpKyspIHtcbiAgICAgICAgICAgIHZhciBpJDggPSBzZXFJbmRpY2VzJDFbc2ldO1xuICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tpJDhdICYgVFlQRV9OU00pIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZUeXBlID0gc29zVHlwZTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2ogPSBzaSAtIDE7IHNqID49IDA7IHNqLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIShjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqXV0gJiBCTl9MSUtFX1RZUEVTKSkgeyAvLzUuMiBzY2FuIGJhY2sgdG8gZmlyc3Qgbm9uLUJOXG4gICAgICAgICAgICAgICAgICBwcmV2VHlwZSA9IGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2pdXTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkOCwgKHByZXZUeXBlICYgKElTT0xBVEVfSU5JVF9UWVBFUyB8IFRZUEVfUERJKSkgPyBUWVBFX09OIDogcHJldlR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmQgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcylcbiAgICAgICAgLy8gaXMgZm91bmQuIElmIGFuIEFMIGlzIGZvdW5kLCBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBBcmFiaWMgbnVtYmVyLlxuICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfRU4pKSB7XG4gICAgICAgICAgZm9yICh2YXIgc2kkMSA9IDA7IHNpJDEgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQxKyspIHtcbiAgICAgICAgICAgIHZhciBpJDkgPSBzZXFJbmRpY2VzJDFbc2kkMV07XG4gICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkOV0gJiBUWVBFX0VOKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIHNqJDEgPSBzaSQxIC0gMTsgc2okMSA+PSAtMTsgc2okMS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZDaGFyVHlwZSA9IHNqJDEgPT09IC0xID8gc29zVHlwZSA6IGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2okMV1dO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2Q2hhclR5cGUgJiBTVFJPTkdfVFlQRVMpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q2hhclR5cGUgPT09IFRZUEVfQUwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQ5LCBUWVBFX0FOKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVzMuIENoYW5nZSBhbGwgQUxzIHRvIFJcbiAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0FMKSkge1xuICAgICAgICAgIGZvciAodmFyIHNpJDIgPSAwOyBzaSQyIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkMisrKSB7XG4gICAgICAgICAgICB2YXIgaSQxMCA9IHNlcUluZGljZXMkMVtzaSQyXTtcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQxMF0gJiBUWVBFX0FMKSB7XG4gICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkMTAsIFRZUEVfUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVzQuIEEgc2luZ2xlIEV1cm9wZWFuIHNlcGFyYXRvciBiZXR3ZWVuIHR3byBFdXJvcGVhbiBudW1iZXJzIGNoYW5nZXMgdG8gYSBFdXJvcGVhbiBudW1iZXIuIEEgc2luZ2xlIGNvbW1vblxuICAgICAgICAvLyBzZXBhcmF0b3IgYmV0d2VlbiB0d28gbnVtYmVycyBvZiB0aGUgc2FtZSB0eXBlIGNoYW5nZXMgdG8gdGhhdCB0eXBlLlxuICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfRVMpIHx8IGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0NTKSkge1xuICAgICAgICAgIGZvciAodmFyIHNpJDMgPSAxOyBzaSQzIDwgc2VxSW5kaWNlcyQxLmxlbmd0aCAtIDE7IHNpJDMrKykge1xuICAgICAgICAgICAgdmFyIGkkMTEgPSBzZXFJbmRpY2VzJDFbc2kkM107XG4gICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkMTFdICYgKFRZUEVfRVMgfCBUWVBFX0NTKSkge1xuICAgICAgICAgICAgICB2YXIgcHJldlR5cGUkMSA9IDAsIG5leHRUeXBlID0gMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2okMiA9IHNpJDMgLSAxOyBzaiQyID49IDA7IHNqJDItLSkge1xuICAgICAgICAgICAgICAgIHByZXZUeXBlJDEgPSBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqJDJdXTtcbiAgICAgICAgICAgICAgICBpZiAoIShwcmV2VHlwZSQxICYgQk5fTElLRV9UWVBFUykpIHsgLy81LjJcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIHNqJDMgPSBzaSQzICsgMTsgc2okMyA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNqJDMrKykge1xuICAgICAgICAgICAgICAgIG5leHRUeXBlID0gY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaiQzXV07XG4gICAgICAgICAgICAgICAgaWYgKCEobmV4dFR5cGUgJiBCTl9MSUtFX1RZUEVTKSkgeyAvLzUuMlxuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHByZXZUeXBlJDEgPT09IG5leHRUeXBlICYmIChjaGFyVHlwZXNbaSQxMV0gPT09IFRZUEVfRVMgPyBwcmV2VHlwZSQxID09PSBUWVBFX0VOIDogKHByZXZUeXBlJDEgJiAoVFlQRV9FTiB8IFRZUEVfQU4pKSkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDExLCBwcmV2VHlwZSQxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFc1LiBBIHNlcXVlbmNlIG9mIEV1cm9wZWFuIHRlcm1pbmF0b3JzIGFkamFjZW50IHRvIEV1cm9wZWFuIG51bWJlcnMgY2hhbmdlcyB0byBhbGwgRXVyb3BlYW4gbnVtYmVycy5cbiAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0VOKSkge1xuICAgICAgICAgIGZvciAodmFyIHNpJDQgPSAwOyBzaSQ0IDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkNCsrKSB7XG4gICAgICAgICAgICB2YXIgaSQxMiA9IHNlcUluZGljZXMkMVtzaSQ0XTtcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQxMl0gJiBUWVBFX0VOKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIHNqJDQgPSBzaSQ0IC0gMTsgc2okNCA+PSAwICYmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqJDRdXSAmIChUWVBFX0VUIHwgQk5fTElLRV9UWVBFUykpOyBzaiQ0LS0pIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShzZXFJbmRpY2VzJDFbc2okNF0sIFRZUEVfRU4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoc2kkNCsrOyBzaSQ0IDwgc2VxSW5kaWNlcyQxLmxlbmd0aCAmJiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaSQ0XV0gJiAoVFlQRV9FVCB8IEJOX0xJS0VfVFlQRVMgfCBUWVBFX0VOKSk7IHNpJDQrKykge1xuICAgICAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDRdXSAhPT0gVFlQRV9FTikge1xuICAgICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoc2VxSW5kaWNlcyQxW3NpJDRdLCBUWVBFX0VOKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXIgTmV1dHJhbC5cbiAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0VUKSB8fCBjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9FUykgfHwgY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfQ1MpKSB7XG4gICAgICAgICAgZm9yICh2YXIgc2kkNSA9IDA7IHNpJDUgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQ1KyspIHtcbiAgICAgICAgICAgIHZhciBpJDEzID0gc2VxSW5kaWNlcyQxW3NpJDVdO1xuICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tpJDEzXSAmIChUWVBFX0VUIHwgVFlQRV9FUyB8IFRZUEVfQ1MpKSB7XG4gICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkMTMsIFRZUEVfT04pO1xuICAgICAgICAgICAgICAvLyA1LjIgdHJhbnNmb3JtIGFkamFjZW50IEJOcyB0b286XG4gICAgICAgICAgICAgIGZvciAodmFyIHNqJDUgPSBzaSQ1IC0gMTsgc2okNSA+PSAwICYmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqJDVdXSAmIEJOX0xJS0VfVFlQRVMpOyBzaiQ1LS0pIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShzZXFJbmRpY2VzJDFbc2okNV0sIFRZUEVfT04pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIHNqJDYgPSBzaSQ1ICsgMTsgc2okNiA8IHNlcUluZGljZXMkMS5sZW5ndGggJiYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2okNl1dICYgQk5fTElLRV9UWVBFUyk7IHNqJDYrKykge1xuICAgICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKHNlcUluZGljZXMkMVtzaiQ2XSwgVFlQRV9PTik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXNy4gU2VhcmNoIGJhY2t3YXJkIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlciB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIG9yIHNvcylcbiAgICAgICAgLy8gaXMgZm91bmQuIElmIGFuIEwgaXMgZm91bmQsIHRoZW4gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gTC5cbiAgICAgICAgLy8gTk9URTogaW1wbGVtZW50ZWQgaW4gc2luZ2xlIGZvcndhcmQgcGFzcyBmb3IgZWZmaWNpZW5jeVxuICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfRU4pKSB7XG4gICAgICAgICAgZm9yICh2YXIgc2kkNiA9IDAsIHByZXZTdHJvbmdUeXBlID0gc29zVHlwZTsgc2kkNiA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDYrKykge1xuICAgICAgICAgICAgdmFyIGkkMTQgPSBzZXFJbmRpY2VzJDFbc2kkNl07XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGNoYXJUeXBlc1tpJDE0XTtcbiAgICAgICAgICAgIGlmICh0eXBlICYgVFlQRV9FTikge1xuICAgICAgICAgICAgICBpZiAocHJldlN0cm9uZ1R5cGUgPT09IFRZUEVfTCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkMTQsIFRZUEVfTCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSAmIFNUUk9OR19UWVBFUykge1xuICAgICAgICAgICAgICBwcmV2U3Ryb25nVHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gPT09IDMuMy41IFJlc29sdmluZyBOZXV0cmFsIGFuZCBJc29sYXRlIEZvcm1hdHRpbmcgVHlwZXMgPT09XG5cbiAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChORVVUUkFMX0lTT0xBVEVfVFlQRVMpKSB7XG4gICAgICAgICAgLy8gTjAuIFByb2Nlc3MgYnJhY2tldCBwYWlycyBpbiBhbiBpc29sYXRpbmcgcnVuIHNlcXVlbmNlIHNlcXVlbnRpYWxseSBpbiB0aGUgbG9naWNhbCBvcmRlciBvZiB0aGUgdGV4dFxuICAgICAgICAgIC8vIHBvc2l0aW9ucyBvZiB0aGUgb3BlbmluZyBwYWlyZWQgYnJhY2tldHMgdXNpbmcgdGhlIGxvZ2ljIGdpdmVuIGJlbG93LiBXaXRoaW4gdGhpcyBzY29wZSwgYmlkaXJlY3Rpb25hbFxuICAgICAgICAgIC8vIHR5cGVzIEVOIGFuZCBBTiBhcmUgdHJlYXRlZCBhcyBSLlxuICAgICAgICAgIHZhciBSX1RZUEVTX0ZPUl9OX1NURVBTID0gKFRZUEVfUiB8IFRZUEVfRU4gfCBUWVBFX0FOKTtcbiAgICAgICAgICB2YXIgU1RST05HX1RZUEVTX0ZPUl9OX1NURVBTID0gUl9UWVBFU19GT1JfTl9TVEVQUyB8IFRZUEVfTDtcblxuICAgICAgICAgIC8vICogSWRlbnRpZnkgdGhlIGJyYWNrZXQgcGFpcnMgaW4gdGhlIGN1cnJlbnQgaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZSBhY2NvcmRpbmcgdG8gQkQxNi5cbiAgICAgICAgICB2YXIgYnJhY2tldFBhaXJzID0gW107XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIG9wZW5lclN0YWNrID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBzaSQ3ID0gMDsgc2kkNyA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDcrKykge1xuICAgICAgICAgICAgICAvLyBOT1RFOiBmb3IgYW55IHBvdGVudGlhbCBicmFja2V0IGNoYXJhY3RlciB3ZSBhbHNvIHRlc3QgdGhhdCBpdCBzdGlsbCBjYXJyaWVzIGEgTklcbiAgICAgICAgICAgICAgLy8gdHlwZSwgYXMgdGhhdCBtYXkgaGF2ZSBiZWVuIGNoYW5nZWQgZWFybGllci4gVGhpcyBkb2Vzbid0IHNlZW0gdG8gYmUgZXhwbGljaXRseVxuICAgICAgICAgICAgICAvLyBjYWxsZWQgb3V0IGluIHRoZSBzcGVjLCBidXQgaXMgcmVxdWlyZWQgZm9yIHBhc3NhZ2Ugb2YgY2VydGFpbiB0ZXN0cy5cbiAgICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkN11dICYgTkVVVFJBTF9JU09MQVRFX1RZUEVTKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXIgPSBzdHJpbmdbc2VxSW5kaWNlcyQxW3NpJDddXTtcbiAgICAgICAgICAgICAgICB2YXIgb3Bwb3NpdGVCcmFja2V0ID0gKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgLy8gT3BlbmluZyBicmFja2V0XG4gICAgICAgICAgICAgICAgaWYgKG9wZW5pbmdUb0Nsb3NpbmdCcmFja2V0KGNoYXIpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAob3BlbmVyU3RhY2subGVuZ3RoIDwgNjMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbmVyU3RhY2sucHVzaCh7IGNoYXI6IGNoYXIsIHNlcUluZGV4OiBzaSQ3IH0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2xvc2luZyBicmFja2V0XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKG9wcG9zaXRlQnJhY2tldCA9IGNsb3NpbmdUb09wZW5pbmdCcmFja2V0KGNoYXIpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc3RhY2tJZHggPSBvcGVuZXJTdGFjay5sZW5ndGggLSAxOyBzdGFja0lkeCA+PSAwOyBzdGFja0lkeC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFja0NoYXIgPSBvcGVuZXJTdGFja1tzdGFja0lkeF0uY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrQ2hhciA9PT0gb3Bwb3NpdGVCcmFja2V0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgc3RhY2tDaGFyID09PSBjbG9zaW5nVG9PcGVuaW5nQnJhY2tldChnZXRDYW5vbmljYWxCcmFja2V0KGNoYXIpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIG9wZW5pbmdUb0Nsb3NpbmdCcmFja2V0KGdldENhbm9uaWNhbEJyYWNrZXQoc3RhY2tDaGFyKSkgPT09IGNoYXJcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYnJhY2tldFBhaXJzLnB1c2goW29wZW5lclN0YWNrW3N0YWNrSWR4XS5zZXFJbmRleCwgc2kkN10pO1xuICAgICAgICAgICAgICAgICAgICAgIG9wZW5lclN0YWNrLmxlbmd0aCA9IHN0YWNrSWR4OyAvL3BvcCB0aGUgbWF0Y2hpbmcgYnJhY2tldCBhbmQgYWxsIGZvbGxvd2luZ1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyYWNrZXRQYWlycy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzBdIC0gYlswXTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vICogRm9yIGVhY2ggYnJhY2tldC1wYWlyIGVsZW1lbnQgaW4gdGhlIGxpc3Qgb2YgcGFpcnMgb2YgdGV4dCBwb3NpdGlvbnNcbiAgICAgICAgICBmb3IgKHZhciBwYWlySWR4ID0gMDsgcGFpcklkeCA8IGJyYWNrZXRQYWlycy5sZW5ndGg7IHBhaXJJZHgrKykge1xuICAgICAgICAgICAgdmFyIHJlZiQxID0gYnJhY2tldFBhaXJzW3BhaXJJZHhdO1xuICAgICAgICAgICAgdmFyIG9wZW5TZXFJZHggPSByZWYkMVswXTtcbiAgICAgICAgICAgIHZhciBjbG9zZVNlcUlkeCA9IHJlZiQxWzFdO1xuICAgICAgICAgICAgLy8gYS4gSW5zcGVjdCB0aGUgYmlkaXJlY3Rpb25hbCB0eXBlcyBvZiB0aGUgY2hhcmFjdGVycyBlbmNsb3NlZCB3aXRoaW4gdGhlIGJyYWNrZXQgcGFpci5cbiAgICAgICAgICAgIC8vIGIuIElmIGFueSBzdHJvbmcgdHlwZSAoZWl0aGVyIEwgb3IgUikgbWF0Y2hpbmcgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24gaXMgZm91bmQsIHNldCB0aGUgdHlwZSBmb3IgYm90aFxuICAgICAgICAgICAgLy8gYnJhY2tldHMgaW4gdGhlIHBhaXIgdG8gbWF0Y2ggdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24uXG4gICAgICAgICAgICB2YXIgZm91bmRTdHJvbmdUeXBlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgdXNlU3Ryb25nVHlwZSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBzaSQ4ID0gb3BlblNlcUlkeCArIDE7IHNpJDggPCBjbG9zZVNlcUlkeDsgc2kkOCsrKSB7XG4gICAgICAgICAgICAgIHZhciBpJDE1ID0gc2VxSW5kaWNlcyQxW3NpJDhdO1xuICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkMTVdICYgU1RST05HX1RZUEVTX0ZPUl9OX1NURVBTKSB7XG4gICAgICAgICAgICAgICAgZm91bmRTdHJvbmdUeXBlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbHIgPSAoY2hhclR5cGVzW2kkMTVdICYgUl9UWVBFU19GT1JfTl9TVEVQUykgPyBUWVBFX1IgOiBUWVBFX0w7XG4gICAgICAgICAgICAgICAgaWYgKGxyID09PSBlbWJlZERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgdXNlU3Ryb25nVHlwZSA9IGxyO1xuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGMuIE90aGVyd2lzZSwgaWYgdGhlcmUgaXMgYSBzdHJvbmcgdHlwZSBpdCBtdXN0IGJlIG9wcG9zaXRlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLiBUaGVyZWZvcmUsIHRlc3RcbiAgICAgICAgICAgIC8vIGZvciBhbiBlc3RhYmxpc2hlZCBjb250ZXh0IHdpdGggYSBwcmVjZWRpbmcgc3Ryb25nIHR5cGUgYnkgY2hlY2tpbmcgYmFja3dhcmRzIGJlZm9yZSB0aGUgb3BlbmluZyBwYWlyZWRcbiAgICAgICAgICAgIC8vIGJyYWNrZXQgdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChMLCBSLCBvciBzb3MpIGlzIGZvdW5kLlxuICAgICAgICAgICAgLy8gICAgMS4gSWYgdGhlIHByZWNlZGluZyBzdHJvbmcgdHlwZSBpcyBhbHNvIG9wcG9zaXRlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLCBjb250ZXh0IGlzIGVzdGFibGlzaGVkLCBzb1xuICAgICAgICAgICAgLy8gICAgc2V0IHRoZSB0eXBlIGZvciBib3RoIGJyYWNrZXRzIGluIHRoZSBwYWlyIHRvIHRoYXQgZGlyZWN0aW9uLlxuICAgICAgICAgICAgLy8gICAgMi4gT3RoZXJ3aXNlIHNldCB0aGUgdHlwZSBmb3IgYm90aCBicmFja2V0cyBpbiB0aGUgcGFpciB0byB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbiAgICAgICAgICAgIGlmIChmb3VuZFN0cm9uZ1R5cGUgJiYgIXVzZVN0cm9uZ1R5cGUpIHtcbiAgICAgICAgICAgICAgdXNlU3Ryb25nVHlwZSA9IHNvc1R5cGU7XG4gICAgICAgICAgICAgIGZvciAodmFyIHNpJDkgPSBvcGVuU2VxSWR4IC0gMTsgc2kkOSA+PSAwOyBzaSQ5LS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaSQxNiA9IHNlcUluZGljZXMkMVtzaSQ5XTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkMTZdICYgU1RST05HX1RZUEVTX0ZPUl9OX1NURVBTKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbHIkMSA9IChjaGFyVHlwZXNbaSQxNl0gJiBSX1RZUEVTX0ZPUl9OX1NURVBTKSA/IFRZUEVfUiA6IFRZUEVfTDtcbiAgICAgICAgICAgICAgICAgIGlmIChsciQxICE9PSBlbWJlZERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB1c2VTdHJvbmdUeXBlID0gbHIkMTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZVN0cm9uZ1R5cGUgPSBlbWJlZERpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlU3Ryb25nVHlwZSkge1xuICAgICAgICAgICAgICBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW29wZW5TZXFJZHhdXSA9IGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbY2xvc2VTZXFJZHhdXSA9IHVzZVN0cm9uZ1R5cGU7XG4gICAgICAgICAgICAgIC8vICogQW55IG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgaGFkIG9yaWdpbmFsIGJpZGlyZWN0aW9uYWwgY2hhcmFjdGVyIHR5cGUgTlNNIHByaW9yIHRvIHRoZSBhcHBsaWNhdGlvblxuICAgICAgICAgICAgICAvLyBvZiBXMSB0aGF0IGltbWVkaWF0ZWx5IGZvbGxvdyBhIHBhaXJlZCBicmFja2V0IHdoaWNoIGNoYW5nZWQgdG8gTCBvciBSIHVuZGVyIE4wIHNob3VsZCBjaGFuZ2UgdG8gbWF0Y2hcbiAgICAgICAgICAgICAgLy8gdGhlIHR5cGUgb2YgdGhlaXIgcHJlY2VkaW5nIGJyYWNrZXQuXG4gICAgICAgICAgICAgIGlmICh1c2VTdHJvbmdUeXBlICE9PSBlbWJlZERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHNpJDEwID0gb3BlblNlcUlkeCArIDE7IHNpJDEwIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkMTArKykge1xuICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaSQxMF1dICYgQk5fTElLRV9UWVBFUykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldEJpZGlDaGFyVHlwZShzdHJpbmdbc2VxSW5kaWNlcyQxW3NpJDEwXV0pICYgVFlQRV9OU00pIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDEwXV0gPSB1c2VTdHJvbmdUeXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh1c2VTdHJvbmdUeXBlICE9PSBlbWJlZERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHNpJDExID0gY2xvc2VTZXFJZHggKyAxOyBzaSQxMSA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDExKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkMTFdXSAmIEJOX0xJS0VfVFlQRVMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRCaWRpQ2hhclR5cGUoc3RyaW5nW3NlcUluZGljZXMkMVtzaSQxMV1dKSAmIFRZUEVfTlNNKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaSQxMV1dID0gdXNlU3Ryb25nVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE4xLiBBIHNlcXVlbmNlIG9mIE5JcyB0YWtlcyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGVcbiAgICAgICAgICAvLyBzYW1lIGRpcmVjdGlvbi5cbiAgICAgICAgICAvLyBOMi4gQW55IHJlbWFpbmluZyBOSXMgdGFrZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbiAgICAgICAgICBmb3IgKHZhciBzaSQxMiA9IDA7IHNpJDEyIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkMTIrKykge1xuICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkMTJdXSAmIE5FVVRSQUxfSVNPTEFURV9UWVBFUykge1xuICAgICAgICAgICAgICB2YXIgbmlSdW5TdGFydCA9IHNpJDEyLCBuaVJ1bkVuZCA9IHNpJDEyO1xuICAgICAgICAgICAgICB2YXIgcHJldlR5cGUkMiA9IHNvc1R5cGU7IC8vc2kgPT09IDAgPyBzb3NUeXBlIDogKGNoYXJUeXBlc1tzZXFJbmRpY2VzW3NpIC0gMV1dICYgUl9UWVBFU19GT1JfTl9TVEVQUykgPyBUWVBFX1IgOiBUWVBFX0xcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2kyID0gc2kkMTIgLSAxOyBzaTIgPj0gMDsgc2kyLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaTJdXSAmIEJOX0xJS0VfVFlQRVMpIHtcbiAgICAgICAgICAgICAgICAgIG5pUnVuU3RhcnQgPSBzaTI7IC8vNS4yIHRyZWF0IEJOcyBhZGphY2VudCB0byBOSXMgYXMgTklzXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHByZXZUeXBlJDIgPSAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaTJdXSAmIFJfVFlQRVNfRk9SX05fU1RFUFMpID8gVFlQRV9SIDogVFlQRV9MO1xuICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIG5leHRUeXBlJDEgPSBlb3NUeXBlO1xuICAgICAgICAgICAgICBmb3IgKHZhciBzaTIkMSA9IHNpJDEyICsgMTsgc2kyJDEgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaTIkMSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kyJDFdXSAmIChORVVUUkFMX0lTT0xBVEVfVFlQRVMgfCBCTl9MSUtFX1RZUEVTKSkge1xuICAgICAgICAgICAgICAgICAgbmlSdW5FbmQgPSBzaTIkMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbmV4dFR5cGUkMSA9IChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpMiQxXV0gJiBSX1RZUEVTX0ZPUl9OX1NURVBTKSA/IFRZUEVfUiA6IFRZUEVfTDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAodmFyIHNqJDcgPSBuaVJ1blN0YXJ0OyBzaiQ3IDw9IG5pUnVuRW5kOyBzaiQ3KyspIHtcbiAgICAgICAgICAgICAgICBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqJDddXSA9IHByZXZUeXBlJDIgPT09IG5leHRUeXBlJDEgPyBwcmV2VHlwZSQyIDogZW1iZWREaXJlY3Rpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2kkMTIgPSBuaVJ1bkVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gPT09IDMuMy42IFJlc29sdmluZyBJbXBsaWNpdCBMZXZlbHMgPT09XG5cbiAgICAgIGZvciAodmFyIGkkMTcgPSBwYXJhZ3JhcGguc3RhcnQ7IGkkMTcgPD0gcGFyYWdyYXBoLmVuZDsgaSQxNysrKSB7XG4gICAgICAgIHZhciBsZXZlbCQzID0gZW1iZWRMZXZlbHNbaSQxN107XG4gICAgICAgIHZhciB0eXBlJDEgPSBjaGFyVHlwZXNbaSQxN107XG4gICAgICAgIC8vIEkyLiBGb3IgYWxsIGNoYXJhY3RlcnMgd2l0aCBhbiBvZGQgKHJpZ2h0LXRvLWxlZnQpIGVtYmVkZGluZyBsZXZlbCwgdGhvc2Ugb2YgdHlwZSBMLCBFTiBvciBBTiBnbyB1cCBvbmUgbGV2ZWwuXG4gICAgICAgIGlmIChsZXZlbCQzICYgMSkge1xuICAgICAgICAgIGlmICh0eXBlJDEgJiAoVFlQRV9MIHwgVFlQRV9FTiB8IFRZUEVfQU4pKSB7XG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDE3XSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAgIC8vIEkxLiBGb3IgYWxsIGNoYXJhY3RlcnMgd2l0aCBhbiBldmVuIChsZWZ0LXRvLXJpZ2h0KSBlbWJlZGRpbmcgbGV2ZWwsIHRob3NlIG9mIHR5cGUgUiBnbyB1cCBvbmUgbGV2ZWxcbiAgICAgICAgLy8gYW5kIHRob3NlIG9mIHR5cGUgQU4gb3IgRU4gZ28gdXAgdHdvIGxldmVscy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGUkMSAmIFRZUEVfUikge1xuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQxN10rKztcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUkMSAmIChUWVBFX0FOIHwgVFlQRV9FTikpIHtcbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMTddICs9IDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNS4yOiBSZXNvbHZlIGFueSBMUkUsIFJMRSwgTFJPLCBSTE8sIFBERiwgb3IgQk4gdG8gdGhlIGxldmVsIG9mIHRoZSBwcmVjZWRpbmcgY2hhcmFjdGVyIGlmIHRoZXJlIGlzIG9uZSxcbiAgICAgICAgLy8gYW5kIG90aGVyd2lzZSB0byB0aGUgYmFzZSBsZXZlbC5cbiAgICAgICAgaWYgKHR5cGUkMSAmIEJOX0xJS0VfVFlQRVMpIHtcbiAgICAgICAgICBlbWJlZExldmVsc1tpJDE3XSA9IGkkMTcgPT09IDAgPyBwYXJhZ3JhcGgubGV2ZWwgOiBlbWJlZExldmVsc1tpJDE3IC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLjQgTDEuMS00OiBSZXNldCB0aGUgZW1iZWRkaW5nIGxldmVsIG9mIHNlZ21lbnQvcGFyYWdyYXBoIHNlcGFyYXRvcnMsIGFuZCBhbnkgc2VxdWVuY2Ugb2Ygd2hpdGVzcGFjZSBvclxuICAgICAgICAvLyBpc29sYXRlIGZvcm1hdHRpbmcgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlbSBvciB0aGUgZW5kIG9mIHRoZSBwYXJhZ3JhcGgsIHRvIHRoZSBwYXJhZ3JhcGggbGV2ZWwuXG4gICAgICAgIC8vIE5PVEU6IHRoaXMgd2lsbCBhbHNvIG5lZWQgdG8gYmUgYXBwbGllZCB0byBlYWNoIGluZGl2aWR1YWwgbGluZSBlbmRpbmcgYWZ0ZXIgbGluZSB3cmFwcGluZyBvY2N1cnMuXG4gICAgICAgIGlmIChpJDE3ID09PSBwYXJhZ3JhcGguZW5kIHx8IGdldEJpZGlDaGFyVHlwZShzdHJpbmdbaSQxN10pICYgKFRZUEVfUyB8IFRZUEVfQikpIHtcbiAgICAgICAgICBmb3IgKHZhciBqJDEgPSBpJDE3OyBqJDEgPj0gMCAmJiAoZ2V0QmlkaUNoYXJUeXBlKHN0cmluZ1tqJDFdKSAmIFRSQUlMSU5HX1RZUEVTKTsgaiQxLS0pIHtcbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2okMV0gPSBwYXJhZ3JhcGgubGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRE9ORSEgVGhlIHJlc29sdmVkIGxldmVscyBjYW4gdGhlbiBiZSB1c2VkLCBhZnRlciBsaW5lIHdyYXBwaW5nLCB0byBmbGlwIHJ1bnMgb2YgY2hhcmFjdGVyc1xuICAgIC8vIGFjY29yZGluZyB0byBzZWN0aW9uIDMuNCBSZW9yZGVyaW5nIFJlc29sdmVkIExldmVsc1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbHM6IGVtYmVkTGV2ZWxzLFxuICAgICAgcGFyYWdyYXBoczogcGFyYWdyYXBoc1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRldGVybWluZUF1dG9FbWJlZExldmVsIChzdGFydCwgaXNGU0kpIHtcbiAgICAgIC8vIDMuMy4xIFAyIC0gUDNcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhclR5cGUgPSBjaGFyVHlwZXNbaV07XG4gICAgICAgIGlmIChjaGFyVHlwZSAmIChUWVBFX1IgfCBUWVBFX0FMKSkge1xuICAgICAgICAgIHJldHVybiAxXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjaGFyVHlwZSAmIChUWVBFX0IgfCBUWVBFX0wpKSB8fCAoaXNGU0kgJiYgY2hhclR5cGUgPT09IFRZUEVfUERJKSkge1xuICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJUeXBlICYgSVNPTEFURV9JTklUX1RZUEVTKSB7XG4gICAgICAgICAgdmFyIHBkaSA9IGluZGV4T2ZNYXRjaGluZ1BESShpKTtcbiAgICAgICAgICBpID0gcGRpID09PSAtMSA/IHN0cmluZy5sZW5ndGggOiBwZGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5kZXhPZk1hdGNoaW5nUERJIChpc29sYXRlU3RhcnQpIHtcbiAgICAgIC8vIDMuMS4yIEJEOVxuICAgICAgdmFyIGlzb2xhdGlvbkxldmVsID0gMTtcbiAgICAgIGZvciAodmFyIGkgPSBpc29sYXRlU3RhcnQgKyAxOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyVHlwZSA9IGNoYXJUeXBlc1tpXTtcbiAgICAgICAgaWYgKGNoYXJUeXBlICYgVFlQRV9CKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhclR5cGUgJiBUWVBFX1BESSkge1xuICAgICAgICAgIGlmICgtLWlzb2xhdGlvbkxldmVsID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaGFyVHlwZSAmIElTT0xBVEVfSU5JVF9UWVBFUykge1xuICAgICAgICAgIGlzb2xhdGlvbkxldmVsKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgfVxuXG4gIC8vIEJpZGkgbWlycm9yZWQgY2hhcnMgZGF0YSwgYXV0byBnZW5lcmF0ZWRcbiAgdmFyIGRhdGEgPSBcIjE0PjEsaj4yLHQ+Mix1PjIsMWE+ZywydjM+MSwxPjEsMWdlPjEsMXdkPjEsYj4xLDFqPjEsZj4xLGFpPjMsLTI+MywrMSw4PjFrMCwtMWpxPjF5NywtMXk2PjFoZiwtMWhlPjFoNiwtMWg1PjFoYSwtMWg4PjFxaSwtMXB1PjEsNj4zdSwtM3M+Nyw2PjEsMT4xLGY+MSwxPjEsKzIsMz4xLDE+MSwrMTMsND4xLDE+MSw2PjFlbywtMWVlPjEsMz4xbWcsLTFtZT4xbWssLTFtaj4xbWksLTFtZz4xbWksLTFtZD4xLDE+MSwrMiwxPjEwaywtMTAzPjEsMT4xLDQ+MSw1PjEsMT4xLCsxMCwzPjEsMT44LC03PjgsKzEsLTY+NywrMSxhPjEsMT4xLHU+MSx1Nj4xLDE+MSwrNSwyNj4xLDE+MSwyPjEsMj4yLDg+MSw3PjEsND4xLDE+MSwrNSxiOD4xLDE+MSwrMywxPjMsLTI+MSwyPjEsMT4xLCsyLGM+MSwzPjEsMT4xLCsyLGg+MSwzPjEsYT4xLDE+MSwyPjEsMz4xLDE+MSxkPjEsZj4xLDM+MSwxYT4xLDE+MSw2PjEsNz4xLDEzPjEsaz4xLDE+MSwrMTksND4xLDE+MSwrMiwyPjEsMT4xLCsxOCxtPjEsYT4xLDE+MSxsaz4xLDE+MSw0PjEsMj4xLGY+MSwzPjEsMT4xLCszLGRiPjEsMT4xLCszLDM+MSwxPjEsKzIsMTRxbT4xLDE+MSwrMSw2PjEsNGo+MSxqPjIsdD4yLHU+MiwyPjEsKzFcIjtcblxuICB2YXIgbWlycm9yTWFwO1xuXG4gIGZ1bmN0aW9uIHBhcnNlICgpIHtcbiAgICBpZiAoIW1pcnJvck1hcCkge1xuICAgICAgLy9jb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICB2YXIgcmVmID0gcGFyc2VDaGFyYWN0ZXJNYXAoZGF0YSwgdHJ1ZSk7XG4gICAgICB2YXIgbWFwID0gcmVmLm1hcDtcbiAgICAgIHZhciByZXZlcnNlTWFwID0gcmVmLnJldmVyc2VNYXA7XG4gICAgICAvLyBDb21iaW5lIGJvdGggbWFwcyBpbnRvIG9uZVxuICAgICAgcmV2ZXJzZU1hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIG1pcnJvck1hcCA9IG1hcDtcbiAgICAgIC8vY29uc29sZS5sb2coYG1pcnJvcmVkIGNoYXJzIHBhcnNlZCBpbiAke3BlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnR9bXNgKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1pcnJvcmVkQ2hhcmFjdGVyIChjaGFyKSB7XG4gICAgcGFyc2UoKTtcbiAgICByZXR1cm4gbWlycm9yTWFwLmdldChjaGFyKSB8fCBudWxsXG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBzdHJpbmcgYW5kIGl0cyByZXNvbHZlZCBlbWJlZGRpbmcgbGV2ZWxzLCBidWlsZCBhIG1hcCBvZiBpbmRpY2VzIHRvIHJlcGxhY2VtZW50IGNoYXJzXG4gICAqIGZvciBhbnkgY2hhcmFjdGVycyBpbiByaWdodC10by1sZWZ0IHNlZ21lbnRzIHRoYXQgaGF2ZSBkZWZpbmVkIG1pcnJvcmVkIGNoYXJhY3RlcnMuXG4gICAqIEBwYXJhbSBzdHJpbmdcbiAgICogQHBhcmFtIGVtYmVkZGluZ0xldmVsc1xuICAgKiBAcGFyYW0gW3N0YXJ0XVxuICAgKiBAcGFyYW0gW2VuZF1cbiAgICogQHJldHVybiB7TWFwPG51bWJlciwgc3RyaW5nPn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldE1pcnJvcmVkQ2hhcmFjdGVyc01hcChzdHJpbmcsIGVtYmVkZGluZ0xldmVscywgc3RhcnQsIGVuZCkge1xuICAgIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnQgPT0gbnVsbCA/IDAgOiArc3RhcnQpO1xuICAgIGVuZCA9IE1hdGgubWluKHN0ckxlbiAtIDEsIGVuZCA9PSBudWxsID8gc3RyTGVuIC0gMSA6ICtlbmQpO1xuXG4gICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgIGlmIChlbWJlZGRpbmdMZXZlbHNbaV0gJiAxKSB7IC8vb25seSBvZGQgKHJ0bCkgbGV2ZWxzXG4gICAgICAgIHZhciBtaXJyb3IgPSBnZXRNaXJyb3JlZENoYXJhY3RlcihzdHJpbmdbaV0pO1xuICAgICAgICBpZiAobWlycm9yICE9PSBudWxsKSB7XG4gICAgICAgICAgbWFwLnNldChpLCBtaXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXBcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIHN0YXJ0IGFuZCBlbmQgZGVub3RpbmcgYSBzaW5nbGUgbGluZSB3aXRoaW4gYSBzdHJpbmcsIGFuZCBhIHNldCBvZiBwcmVjYWxjdWxhdGVkXG4gICAqIGJpZGkgZW1iZWRkaW5nIGxldmVscywgcHJvZHVjZSBhIGxpc3Qgb2Ygc2VnbWVudHMgd2hvc2Ugb3JkZXJpbmcgc2hvdWxkIGJlIGZsaXBwZWQsIGluIHNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gdGhlIGZ1bGwgaW5wdXQgc3RyaW5nXG4gICAqIEBwYXJhbSB7R2V0RW1iZWRkaW5nTGV2ZWxzUmVzdWx0fSBlbWJlZGRpbmdMZXZlbHNSZXN1bHQgLSB0aGUgcmVzdWx0IG9iamVjdCBmcm9tIGdldEVtYmVkZGluZ0xldmVsc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XSAtIGZpcnN0IGNoYXJhY3RlciBpbiBhIHN1YnNldCBvZiB0aGUgZnVsbCBzdHJpbmdcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdIC0gbGFzdCBjaGFyYWN0ZXIgaW4gYSBzdWJzZXQgb2YgdGhlIGZ1bGwgc3RyaW5nXG4gICAqIEByZXR1cm4ge251bWJlcltdW119IC0gdGhlIGxpc3Qgb2Ygc3RhcnQvZW5kIHNlZ21lbnRzIHRoYXQgc2hvdWxkIGJlIGZsaXBwZWQsIGluIG9yZGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UmVvcmRlclNlZ21lbnRzKHN0cmluZywgZW1iZWRkaW5nTGV2ZWxzUmVzdWx0LCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGg7XG4gICAgc3RhcnQgPSBNYXRoLm1heCgwLCBzdGFydCA9PSBudWxsID8gMCA6ICtzdGFydCk7XG4gICAgZW5kID0gTWF0aC5taW4oc3RyTGVuIC0gMSwgZW5kID09IG51bGwgPyBzdHJMZW4gLSAxIDogK2VuZCk7XG5cbiAgICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgICBlbWJlZGRpbmdMZXZlbHNSZXN1bHQucGFyYWdyYXBocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhZ3JhcGgpIHtcbiAgICAgIHZhciBsaW5lU3RhcnQgPSBNYXRoLm1heChzdGFydCwgcGFyYWdyYXBoLnN0YXJ0KTtcbiAgICAgIHZhciBsaW5lRW5kID0gTWF0aC5taW4oZW5kLCBwYXJhZ3JhcGguZW5kKTtcbiAgICAgIGlmIChsaW5lU3RhcnQgPCBsaW5lRW5kKSB7XG4gICAgICAgIC8vIExvY2FsIHNsaWNlIGZvciBtdXRhdGlvblxuICAgICAgICB2YXIgbGluZUxldmVscyA9IGVtYmVkZGluZ0xldmVsc1Jlc3VsdC5sZXZlbHMuc2xpY2UobGluZVN0YXJ0LCBsaW5lRW5kICsgMSk7XG5cbiAgICAgICAgLy8gMy40IEwxLjQ6IFJlc2V0IGFueSBzZXF1ZW5jZSBvZiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgYW5kL29yIGlzb2xhdGUgZm9ybWF0dGluZyBjaGFyYWN0ZXJzIGF0IHRoZVxuICAgICAgICAvLyBlbmQgb2YgdGhlIGxpbmUgdG8gdGhlIHBhcmFncmFwaCBsZXZlbC5cbiAgICAgICAgZm9yICh2YXIgaSA9IGxpbmVFbmQ7IGkgPj0gbGluZVN0YXJ0ICYmIChnZXRCaWRpQ2hhclR5cGUoc3RyaW5nW2ldKSAmIFRSQUlMSU5HX1RZUEVTKTsgaS0tKSB7XG4gICAgICAgICAgbGluZUxldmVsc1tpXSA9IHBhcmFncmFwaC5sZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEwyLiBGcm9tIHRoZSBoaWdoZXN0IGxldmVsIGZvdW5kIGluIHRoZSB0ZXh0IHRvIHRoZSBsb3dlc3Qgb2RkIGxldmVsIG9uIGVhY2ggbGluZSwgaW5jbHVkaW5nIGludGVybWVkaWF0ZSBsZXZlbHNcbiAgICAgICAgLy8gbm90IGFjdHVhbGx5IHByZXNlbnQgaW4gdGhlIHRleHQsIHJldmVyc2UgYW55IGNvbnRpZ3VvdXMgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyB0aGF0IGFyZSBhdCB0aGF0IGxldmVsIG9yIGhpZ2hlci5cbiAgICAgICAgdmFyIG1heExldmVsID0gcGFyYWdyYXBoLmxldmVsO1xuICAgICAgICB2YXIgbWluT2RkTGV2ZWwgPSBJbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGluZUxldmVscy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgdmFyIGxldmVsID0gbGluZUxldmVsc1tpJDFdO1xuICAgICAgICAgIGlmIChsZXZlbCA+IG1heExldmVsKSB7IG1heExldmVsID0gbGV2ZWw7IH1cbiAgICAgICAgICBpZiAobGV2ZWwgPCBtaW5PZGRMZXZlbCkgeyBtaW5PZGRMZXZlbCA9IGxldmVsIHwgMTsgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGx2bCA9IG1heExldmVsOyBsdmwgPj0gbWluT2RkTGV2ZWw7IGx2bC0tKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgbGluZUxldmVscy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICBpZiAobGluZUxldmVsc1tpJDJdID49IGx2bCkge1xuICAgICAgICAgICAgICB2YXIgc2VnU3RhcnQgPSBpJDI7XG4gICAgICAgICAgICAgIHdoaWxlIChpJDIgKyAxIDwgbGluZUxldmVscy5sZW5ndGggJiYgbGluZUxldmVsc1tpJDIgKyAxXSA+PSBsdmwpIHtcbiAgICAgICAgICAgICAgICBpJDIrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaSQyID4gc2VnU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKFtzZWdTdGFydCArIGxpbmVTdGFydCwgaSQyICsgbGluZVN0YXJ0XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VnbWVudHNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAqIEBwYXJhbSB7R2V0RW1iZWRkaW5nTGV2ZWxzUmVzdWx0fSBlbWJlZExldmVsc1Jlc3VsdFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF1cbiAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgbmV3IHN0cmluZyB3aXRoIGJpZGkgc2VnbWVudHMgcmVvcmRlcmVkXG4gICAqL1xuICBmdW5jdGlvbiBnZXRSZW9yZGVyZWRTdHJpbmcoc3RyaW5nLCBlbWJlZExldmVsc1Jlc3VsdCwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBpbmRpY2VzID0gZ2V0UmVvcmRlcmVkSW5kaWNlcyhzdHJpbmcsIGVtYmVkTGV2ZWxzUmVzdWx0LCBzdGFydCwgZW5kKTtcbiAgICB2YXIgY2hhcnMgPSBbXS5jb25jYXQoIHN0cmluZyApO1xuICAgIGluZGljZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hhckluZGV4LCBpKSB7XG4gICAgICBjaGFyc1tpXSA9IChcbiAgICAgICAgKGVtYmVkTGV2ZWxzUmVzdWx0LmxldmVsc1tjaGFySW5kZXhdICYgMSkgPyBnZXRNaXJyb3JlZENoYXJhY3RlcihzdHJpbmdbY2hhckluZGV4XSkgOiBudWxsXG4gICAgICApIHx8IHN0cmluZ1tjaGFySW5kZXhdO1xuICAgIH0pO1xuICAgIHJldHVybiBjaGFycy5qb2luKCcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICogQHBhcmFtIHtHZXRFbWJlZGRpbmdMZXZlbHNSZXN1bHR9IGVtYmVkTGV2ZWxzUmVzdWx0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXVxuICAgKiBAcmV0dXJuIHtudW1iZXJbXX0gYW4gYXJyYXkgd2l0aCBjaGFyYWN0ZXIgaW5kaWNlcyBpbiB0aGVpciBuZXcgYmlkaSBvcmRlclxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UmVvcmRlcmVkSW5kaWNlcyhzdHJpbmcsIGVtYmVkTGV2ZWxzUmVzdWx0LCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHNlZ21lbnRzID0gZ2V0UmVvcmRlclNlZ21lbnRzKHN0cmluZywgZW1iZWRMZXZlbHNSZXN1bHQsIHN0YXJ0LCBlbmQpO1xuICAgIC8vIEZpbGwgYW4gYXJyYXkgd2l0aCBpbmRpY2VzXG4gICAgdmFyIGluZGljZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaW5kaWNlc1tpXSA9IGk7XG4gICAgfVxuICAgIC8vIFJldmVyc2UgZWFjaCBzZWdtZW50IGluIG9yZGVyXG4gICAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICB2YXIgc3RhcnQgPSByZWZbMF07XG4gICAgICB2YXIgZW5kID0gcmVmWzFdO1xuXG4gICAgICB2YXIgc2xpY2UgPSBpbmRpY2VzLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKTtcbiAgICAgIGZvciAodmFyIGkgPSBzbGljZS5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgaW5kaWNlc1tlbmQgLSBpXSA9IHNsaWNlW2ldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpbmRpY2VzXG4gIH1cblxuICBleHBvcnRzLmNsb3NpbmdUb09wZW5pbmdCcmFja2V0ID0gY2xvc2luZ1RvT3BlbmluZ0JyYWNrZXQ7XG4gIGV4cG9ydHMuZ2V0QmlkaUNoYXJUeXBlID0gZ2V0QmlkaUNoYXJUeXBlO1xuICBleHBvcnRzLmdldEJpZGlDaGFyVHlwZU5hbWUgPSBnZXRCaWRpQ2hhclR5cGVOYW1lO1xuICBleHBvcnRzLmdldENhbm9uaWNhbEJyYWNrZXQgPSBnZXRDYW5vbmljYWxCcmFja2V0O1xuICBleHBvcnRzLmdldEVtYmVkZGluZ0xldmVscyA9IGdldEVtYmVkZGluZ0xldmVscztcbiAgZXhwb3J0cy5nZXRNaXJyb3JlZENoYXJhY3RlciA9IGdldE1pcnJvcmVkQ2hhcmFjdGVyO1xuICBleHBvcnRzLmdldE1pcnJvcmVkQ2hhcmFjdGVyc01hcCA9IGdldE1pcnJvcmVkQ2hhcmFjdGVyc01hcDtcbiAgZXhwb3J0cy5nZXRSZW9yZGVyU2VnbWVudHMgPSBnZXRSZW9yZGVyU2VnbWVudHM7XG4gIGV4cG9ydHMuZ2V0UmVvcmRlcmVkSW5kaWNlcyA9IGdldFJlb3JkZXJlZEluZGljZXM7XG4gIGV4cG9ydHMuZ2V0UmVvcmRlcmVkU3RyaW5nID0gZ2V0UmVvcmRlcmVkU3RyaW5nO1xuICBleHBvcnRzLm9wZW5pbmdUb0Nsb3NpbmdCcmFja2V0ID0gb3BlbmluZ1RvQ2xvc2luZ0JyYWNrZXQ7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZXhwb3J0cztcblxufSh7fSkpO1xucmV0dXJuIGJpZGl9XG5cbmV4cG9ydCBkZWZhdWx0IGJpZGlGYWN0b3J5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/bidi-js/dist/bidi.mjs\n"));

/***/ }),

/***/ "(app-client)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ SDFGenerator; }\n/* harmony export */ });\nfunction SDFGenerator() {\nvar exports = (function (exports) {\n\n  /**\n   * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnQuadraticBezier (x0, y0, x1, y1, x2, y2, t, pointOut) {\n    var t2 = 1 - t;\n    pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;\n    pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;\n  }\n\n  /**\n   * Find the point on a cubic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnCubicBezier (x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {\n    var t2 = 1 - t;\n    pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;\n    pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;\n  }\n\n  /**\n   * Parse a path string into its constituent line/curve commands, invoking a callback for each.\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(\n   *   command: 'L'|'Q'|'C',\n   *   startX: number,\n   *   startY: number,\n   *   endX: number,\n   *   endY: number,\n   *   ctrl1X?: number,\n   *   ctrl1Y?: number,\n   *   ctrl2X?: number,\n   *   ctrl2Y?: number\n   * )} commandCallback - A callback function that will be called once for each parsed path command, passing the\n   *                      command identifier (only L/Q/C commands) and its numeric arguments.\n   */\n  function forEachPathCommand(pathString, commandCallback) {\n    var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;\n    var match, firstX, firstY, prevX, prevY;\n    while ((match = segmentRE.exec(pathString))) {\n      var args = match[2]\n        .replace(/^\\s*|\\s*$/g, '')\n        .split(/[,\\s]+/)\n        .map(function (v) { return parseFloat(v); });\n      switch (match[1]) {\n        case 'M':\n          prevX = firstX = args[0];\n          prevY = firstY = args[1];\n          break\n        case 'L':\n          if (args[0] !== prevX || args[1] !== prevY) { // yup, some fonts have zero-length line commands\n            commandCallback('L', prevX, prevY, (prevX = args[0]), (prevY = args[1]));\n          }\n          break\n        case 'Q': {\n          commandCallback('Q', prevX, prevY, (prevX = args[2]), (prevY = args[3]), args[0], args[1]);\n          break\n        }\n        case 'C': {\n          commandCallback('C', prevX, prevY, (prevX = args[4]), (prevY = args[5]), args[0], args[1], args[2], args[3]);\n          break\n        }\n        case 'Z':\n          if (prevX !== firstX || prevY !== firstY) {\n            commandCallback('L', prevX, prevY, firstX, firstY);\n          }\n          break\n      }\n    }\n  }\n\n  /**\n   * Convert a path string to a series of straight line segments\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback\n   *        function that will be called once for every line segment\n   * @param {number} [curvePoints] - How many straight line segments to use when approximating a\n   *        bezier curve in the path. Defaults to 16.\n   */\n  function pathToLineSegments (pathString, segmentCallback, curvePoints) {\n    if ( curvePoints === void 0 ) curvePoints = 16;\n\n    var tempPoint = { x: 0, y: 0 };\n    forEachPathCommand(pathString, function (command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {\n      switch (command) {\n        case 'L':\n          segmentCallback(startX, startY, endX, endY);\n          break\n        case 'Q': {\n          var prevCurveX = startX;\n          var prevCurveY = startY;\n          for (var i = 1; i < curvePoints; i++) {\n            pointOnQuadraticBezier(\n              startX, startY,\n              ctrl1X, ctrl1Y,\n              endX, endY,\n              i / (curvePoints - 1),\n              tempPoint\n            );\n            segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);\n            prevCurveX = tempPoint.x;\n            prevCurveY = tempPoint.y;\n          }\n          break\n        }\n        case 'C': {\n          var prevCurveX$1 = startX;\n          var prevCurveY$1 = startY;\n          for (var i$1 = 1; i$1 < curvePoints; i$1++) {\n            pointOnCubicBezier(\n              startX, startY,\n              ctrl1X, ctrl1Y,\n              ctrl2X, ctrl2Y,\n              endX, endY,\n              i$1 / (curvePoints - 1),\n              tempPoint\n            );\n            segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);\n            prevCurveX$1 = tempPoint.x;\n            prevCurveY$1 = tempPoint.y;\n          }\n          break\n        }\n      }\n    });\n  }\n\n  var viewportQuadVertex = \"precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n  var copyTexFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}\";\n\n  var cache = new WeakMap();\n\n  var glContextParams = {\n    premultipliedAlpha: false,\n    preserveDrawingBuffer: true,\n    antialias: false,\n    depth: false,\n  };\n\n  /**\n   * This is a little helper library for WebGL. It assists with state management for a GL context.\n   * It's pretty tightly wrapped to the needs of this package, not very general-purpose.\n   *\n   * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap\n   * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback\n   */\n  function withWebGLContext (glOrCanvas, callback) {\n    var gl = glOrCanvas.getContext ? glOrCanvas.getContext('webgl', glContextParams) : glOrCanvas;\n    var wrapper = cache.get(gl);\n    if (!wrapper) {\n      var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n      var extensions = {};\n      var programs = {};\n      var textures = {};\n      var textureUnit = -1;\n      var framebufferStack = [];\n\n      gl.canvas.addEventListener('webglcontextlost', function (e) {\n        handleContextLoss();\n        e.preventDefault();\n      }, false);\n\n      function getExtension (name) {\n        var ext = extensions[name];\n        if (!ext) {\n          ext = extensions[name] = gl.getExtension(name);\n          if (!ext) {\n            throw new Error((name + \" not supported\"))\n          }\n        }\n        return ext\n      }\n\n      function compileShader (src, type) {\n        var shader = gl.createShader(type);\n        gl.shaderSource(shader, src);\n        gl.compileShader(shader);\n        // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\n        // if (!status && !gl.isContextLost()) {\n        //   throw new Error(gl.getShaderInfoLog(shader).trim())\n        // }\n        return shader\n      }\n\n      function withProgram (name, vert, frag, func) {\n        if (!programs[name]) {\n          var attributes = {};\n          var uniforms = {};\n          var program = gl.createProgram();\n          gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));\n          gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));\n          gl.linkProgram(program);\n\n          programs[name] = {\n            program: program,\n            transaction: function transaction (func) {\n              gl.useProgram(program);\n              func({\n                setUniform: function setUniform (type, name) {\n                  var values = [], len = arguments.length - 2;\n                  while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];\n\n                  var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));\n                  gl[(\"uniform\" + type)].apply(gl, [ uniformLoc ].concat( values ));\n                },\n\n                setAttribute: function setAttribute (name, size, usage, instancingDivisor, data) {\n                  var attr = attributes[name];\n                  if (!attr) {\n                    attr = attributes[name] = {\n                      buf: gl.createBuffer(), // TODO should we destroy our buffers?\n                      loc: gl.getAttribLocation(program, name),\n                      data: null\n                    };\n                  }\n                  gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);\n                  gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);\n                  gl.enableVertexAttribArray(attr.loc);\n                  if (isWebGL2) {\n                    gl.vertexAttribDivisor(attr.loc, instancingDivisor);\n                  } else {\n                    getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(attr.loc, instancingDivisor);\n                  }\n                  if (data !== attr.data) {\n                    gl.bufferData(gl.ARRAY_BUFFER, data, usage);\n                    attr.data = data;\n                  }\n                }\n              });\n            }\n          };\n        }\n\n        programs[name].transaction(func);\n      }\n\n      function withTexture (name, func) {\n        textureUnit++;\n        try {\n          gl.activeTexture(gl.TEXTURE0 + textureUnit);\n          var texture = textures[name];\n          if (!texture) {\n            texture = textures[name] = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n          }\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          func(texture, textureUnit);\n        } finally {\n          textureUnit--;\n        }\n      }\n\n      function withTextureFramebuffer (texture, textureUnit, func) {\n        var framebuffer = gl.createFramebuffer();\n        framebufferStack.push(framebuffer);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.activeTexture(gl.TEXTURE0 + textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n        try {\n          func(framebuffer);\n        } finally {\n          gl.deleteFramebuffer(framebuffer);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);\n        }\n      }\n\n      function handleContextLoss () {\n        extensions = {};\n        programs = {};\n        textures = {};\n        textureUnit = -1;\n        framebufferStack.length = 0;\n      }\n\n      cache.set(gl, wrapper = {\n        gl: gl,\n        isWebGL2: isWebGL2,\n        getExtension: getExtension,\n        withProgram: withProgram,\n        withTexture: withTexture,\n        withTextureFramebuffer: withTextureFramebuffer,\n        handleContextLoss: handleContextLoss,\n      });\n    }\n    callback(wrapper);\n  }\n\n\n  function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {\n    if ( channels === void 0 ) channels = 15;\n    if ( framebuffer === void 0 ) framebuffer = null;\n\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var withProgram = ref.withProgram;\n      var withTexture = ref.withTexture;\n\n      withTexture('copy', function (tex, texUnit) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n        withProgram('copy', viewportQuadVertex, copyTexFragment, function (ref) {\n          var setUniform = ref.setUniform;\n          var setAttribute = ref.setAttribute;\n\n          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));\n          setUniform('1i', 'image', texUnit);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);\n          gl.disable(gl.BLEND);\n          gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);\n          gl.viewport(x, y, width, height);\n          gl.scissor(x, y, width, height);\n          gl.drawArrays(gl.TRIANGLES, 0, 3);\n        });\n      });\n    });\n  }\n\n  /**\n   * Resizing a canvas clears its contents; this utility copies the previous contents over.\n   * @param canvas\n   * @param newWidth\n   * @param newHeight\n   */\n  function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {\n    var width = canvas.width;\n    var height = canvas.height;\n    withWebGLContext(canvas, function (ref) {\n      var gl = ref.gl;\n\n      var data = new Uint8Array(width * height * 4);\n      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      canvas.width = newWidth;\n      canvas.height = newHeight;\n      renderImageData(gl, data, 0, 0, width, height);\n    });\n  }\n\n  var webglUtils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    withWebGLContext: withWebGLContext,\n    renderImageData: renderImageData,\n    resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing\n  });\n\n  function generate$2 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n    var textureData = new Uint8Array(sdfWidth * sdfHeight);\n\n    var viewBoxWidth = viewBox[2] - viewBox[0];\n    var viewBoxHeight = viewBox[3] - viewBox[1];\n\n    // Decompose all paths into straight line segments and add them to an index\n    var segments = [];\n    pathToLineSegments(path, function (x1, y1, x2, y2) {\n      segments.push({\n        x1: x1, y1: y1, x2: x2, y2: y2,\n        minX: Math.min(x1, x2),\n        minY: Math.min(y1, y2),\n        maxX: Math.max(x1, x2),\n        maxY: Math.max(y1, y2)\n      });\n    });\n\n    // Sort segments by maxX, this will let us short-circuit some loops below\n    segments.sort(function (a, b) { return a.maxX - b.maxX; });\n\n    // For each target SDF texel, find the distance from its center to its nearest line segment,\n    // map that distance to an alpha value, and write that alpha to the texel\n    for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {\n      for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {\n        var signedDist = findNearestSignedDistance(\n          viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,\n          viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight\n        );\n\n        // Use an exponential scale to ensure the texels very near the glyph path have adequate\n        // precision, while allowing the distance field to cover the entire texture, given that\n        // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam\n        var alpha = Math.pow((1 - Math.abs(signedDist) / maxDistance), sdfExponent) / 2;\n        if (signedDist < 0) {\n          alpha = 1 - alpha;\n        }\n\n        alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp\n        textureData[sdfY * sdfWidth + sdfX] = alpha;\n      }\n    }\n\n    return textureData\n\n    /**\n     * For a given x/y, search the index for the closest line segment and return\n     * its signed distance. Negative = inside, positive = outside, zero = on edge\n     * @param x\n     * @param y\n     * @returns {number}\n     */\n    function findNearestSignedDistance (x, y) {\n      var closestDistSq = Infinity;\n      var closestDist = Infinity;\n\n      for (var i = segments.length; i--;) {\n        var seg = segments[i];\n        if (seg.maxX + closestDist <= x) { break } //sorting by maxX means no more can be closer, so we can short-circuit\n        if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {\n          var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);\n          if (distSq < closestDistSq) {\n            closestDistSq = distSq;\n            closestDist = Math.sqrt(closestDistSq);\n          }\n        }\n      }\n\n      // Flip to negative distance if inside the poly\n      if (isPointInPoly(x, y)) {\n        closestDist = -closestDist;\n      }\n      return closestDist\n    }\n\n    /**\n     * Determine whether the given point lies inside or outside the glyph. Uses a simple\n     * winding-number ray casting algorithm using a ray pointing east from the point.\n     */\n    function isPointInPoly (x, y) {\n      var winding = 0;\n      for (var i = segments.length; i--;) {\n        var seg = segments[i];\n        if (seg.maxX <= x) { break } //sorting by maxX means no more can cross, so we can short-circuit\n        var intersects = ((seg.y1 > y) !== (seg.y2 > y)) && (x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1);\n        if (intersects) {\n          winding += seg.y1 < seg.y2 ? 1 : -1;\n        }\n      }\n      return winding !== 0\n    }\n  }\n\n  function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n  }\n\n  function generateIntoFramebuffer$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);\n    // Expand single-channel data to rbga\n    var rgbaData = new Uint8Array(data.length * 4);\n    for (var i = 0; i < data.length; i++) {\n      rgbaData[i * 4 + channel] = data[i];\n    }\n    renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << (3 - channel), framebuffer);\n  }\n\n  /**\n   * Find the absolute distance from a point to a line segment at closest approach\n   */\n  function absSquareDistanceToLineSegment (x, y, lineX0, lineY0, lineX1, lineY1) {\n    var ldx = lineX1 - lineX0;\n    var ldy = lineY1 - lineY0;\n    var lengthSq = ldx * ldx + ldy * ldy;\n    var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;\n    var dx = x - (lineX0 + t * ldx);\n    var dy = y - (lineY0 + t * ldy);\n    return dx * dx + dy * dy\n  }\n\n  var javascript = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    generate: generate$2,\n    generateIntoCanvas: generateIntoCanvas$2,\n    generateIntoFramebuffer: generateIntoFramebuffer$1\n  });\n\n  var mainVertex = \"precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n  var mainFragment = \"precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}\";\n\n  var postFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}\";\n\n  // Single triangle covering viewport\n  var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);\n\n  var implicitContext = null;\n  var isTestingSupport = false;\n  var NULL_OBJECT = {};\n  var supportByCanvas = new WeakMap(); // canvas -> bool\n\n  function validateSupport (glOrCanvas) {\n    if (!isTestingSupport && !isSupported(glOrCanvas)) {\n      throw new Error('WebGL generation not supported')\n    }\n  }\n\n  function generate$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( glOrCanvas === void 0 ) glOrCanvas = null;\n\n    if (!glOrCanvas) {\n      glOrCanvas = implicitContext;\n      if (!glOrCanvas) {\n        var canvas = typeof OffscreenCanvas === 'function'\n          ? new OffscreenCanvas(1, 1)\n          : typeof document !== 'undefined'\n            ? document.createElement('canvas')\n            : null;\n        if (!canvas) {\n          throw new Error('OffscreenCanvas or DOM canvas not supported')\n        }\n        glOrCanvas = implicitContext = canvas.getContext('webgl', { depth: false });\n      }\n    }\n\n    validateSupport(glOrCanvas);\n\n    var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari\n\n    // Render into a background texture framebuffer\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var withTexture = ref.withTexture;\n      var withTextureFramebuffer = ref.withTextureFramebuffer;\n\n      withTexture('readable', function (texture, textureUnit) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n        withTextureFramebuffer(texture, textureUnit, function (framebuffer) {\n          generateIntoFramebuffer(\n            sdfWidth,\n            sdfHeight,\n            path,\n            viewBox,\n            maxDistance,\n            sdfExponent,\n            gl,\n            framebuffer,\n            0,\n            0,\n            0 // red channel\n          );\n          gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);\n        });\n      });\n    });\n\n    // Throw away all but the red channel\n    var data = new Uint8Array(sdfWidth * sdfHeight);\n    for (var i = 0, j = 0; i < rgbaData.length; i += 4) {\n      data[j++] = rgbaData[i];\n    }\n\n    return data\n  }\n\n  function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n  }\n\n  function generateIntoFramebuffer (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    // Verify support\n    validateSupport(glOrCanvas);\n\n    // Compute path segments\n    var lineSegmentCoords = [];\n    pathToLineSegments(path, function (x1, y1, x2, y2) {\n      lineSegmentCoords.push(x1, y1, x2, y2);\n    });\n    lineSegmentCoords = new Float32Array(lineSegmentCoords);\n\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var isWebGL2 = ref.isWebGL2;\n      var getExtension = ref.getExtension;\n      var withProgram = ref.withProgram;\n      var withTexture = ref.withTexture;\n      var withTextureFramebuffer = ref.withTextureFramebuffer;\n      var handleContextLoss = ref.handleContextLoss;\n\n      withTexture('rawDistances', function (intermediateTexture, intermediateTextureUnit) {\n        if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {\n          gl.texImage2D(\n            gl.TEXTURE_2D, 0, gl.RGBA,\n            intermediateTexture._lastWidth = sdfWidth,\n            intermediateTexture._lastHeight = sdfHeight,\n            0, gl.RGBA, gl.UNSIGNED_BYTE, null\n          );\n        }\n\n        // Unsigned distance pass\n        withProgram('main', mainVertex, mainFragment, function (ref) {\n          var setAttribute = ref.setAttribute;\n          var setUniform = ref.setUniform;\n\n          // Init extensions\n          var instancingExtension = !isWebGL2 && getExtension('ANGLE_instanced_arrays');\n          var blendMinMaxExtension = !isWebGL2 && getExtension('EXT_blend_minmax');\n\n          // Init/update attributes\n          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n          setAttribute('aLineSegment', 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);\n\n          // Init/update uniforms\n          setUniform.apply(void 0, [ '4f', 'uGlyphBounds' ].concat( viewBox ));\n          setUniform('1f', 'uMaxDistance', maxDistance);\n          setUniform('1f', 'uExponent', sdfExponent);\n\n          // Render initial unsigned distance / winding number info to a texture\n          withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function (framebuffer) {\n            gl.enable(gl.BLEND);\n            gl.colorMask(true, true, true, true);\n            gl.viewport(0, 0, sdfWidth, sdfHeight);\n            gl.scissor(0, 0, sdfWidth, sdfHeight);\n            gl.blendFunc(gl.ONE, gl.ONE);\n            // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a \"winding number\".\n            // Alpha holds the closest (MAX) unsigned distance.\n            gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            if (isWebGL2) {\n              gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n            } else {\n              instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n            }\n            // Debug\n            // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)\n            // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)\n            // console.log('intermediate texture data: ', debug)\n          });\n        });\n\n        // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.\n        withProgram('post', viewportQuadVertex, postFragment, function (program) {\n          program.setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n          program.setUniform('1i', 'tex', intermediateTextureUnit);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n          gl.disable(gl.BLEND);\n          gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);\n          gl.viewport(x, y, sdfWidth, sdfHeight);\n          gl.scissor(x, y, sdfWidth, sdfHeight);\n          gl.drawArrays(gl.TRIANGLES, 0, 3);\n        });\n      });\n\n      // Handle context loss occurring during any of the above calls\n      if (gl.isContextLost()) {\n        handleContextLoss();\n        throw new Error('webgl context lost')\n      }\n    });\n  }\n\n  function isSupported (glOrCanvas) {\n    var key = (!glOrCanvas || glOrCanvas === implicitContext) ? NULL_OBJECT : (glOrCanvas.canvas || glOrCanvas);\n    var supported = supportByCanvas.get(key);\n    if (supported === undefined) {\n      isTestingSupport = true;\n      var failReason = null;\n      try {\n        // Since we can't detect all failure modes up front, let's just do a trial run of a\n        // simple path and compare what we get back to the correct expected result. This will\n        // also serve to prime the shader compilation.\n        var expectedResult = [\n          97, 106, 97, 61,\n          99, 137, 118, 80,\n          80, 118, 137, 99,\n          61, 97, 106, 97\n        ];\n        var testResult = generate$1(\n          4,\n          4,\n          'M8,8L16,8L24,24L16,24Z',\n          [0, 0, 32, 32],\n          24,\n          1,\n          glOrCanvas\n        );\n        supported = testResult && expectedResult.length === testResult.length &&\n          testResult.every(function (val, i) { return val === expectedResult[i]; });\n        if (!supported) {\n          failReason = 'bad trial run results';\n          console.info(expectedResult, testResult);\n        }\n      } catch (err) {\n        // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?\n        supported = false;\n        failReason = err.message;\n      }\n      if (failReason) {\n        console.warn('WebGL SDF generation not supported:', failReason);\n      }\n      isTestingSupport = false;\n      supportByCanvas.set(key, supported);\n    }\n    return supported\n  }\n\n  var webgl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    generate: generate$1,\n    generateIntoCanvas: generateIntoCanvas$1,\n    generateIntoFramebuffer: generateIntoFramebuffer,\n    isSupported: isSupported\n  });\n\n  /**\n   * Generate an SDF texture image for a 2D path.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @return {Uint8Array}\n   */\n  function generate(\n    sdfWidth,\n    sdfHeight,\n    path,\n    viewBox,\n    maxDistance,\n    sdfExponent\n  ) {\n    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n    try {\n      return generate$1.apply(webgl, arguments)\n    } catch(e) {\n      console.info('WebGL SDF generation failed, falling back to JS', e);\n      return generate$2.apply(javascript, arguments)\n    }\n  }\n\n  /**\n   * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position\n   * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels\n   * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.\n   *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results\n   *        due to shared GL context state, this canvas should be dedicated to use by this library alone.\n   * @param {number} x - the x position at which to render the SDF.\n   * @param {number} y - the y position at which to render the SDF.\n   * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.\n   * @return {Uint8Array}\n   */\n  function generateIntoCanvas(\n    sdfWidth,\n    sdfHeight,\n    path,\n    viewBox,\n    maxDistance,\n    sdfExponent,\n    canvas,\n    x,\n    y,\n    channel\n  ) {\n    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    try {\n      return generateIntoCanvas$1.apply(webgl, arguments)\n    } catch(e) {\n      console.info('WebGL SDF generation failed, falling back to JS', e);\n      return generateIntoCanvas$2.apply(javascript, arguments)\n    }\n  }\n\n  exports.forEachPathCommand = forEachPathCommand;\n  exports.generate = generate;\n  exports.generateIntoCanvas = generateIntoCanvas;\n  exports.javascript = javascript;\n  exports.pathToLineSegments = pathToLineSegments;\n  exports.webgl = webgl;\n  exports.webglUtils = webglUtils;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\nreturn exports\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL3dlYmdsLXNkZi1nZW5lcmF0b3IvZGlzdC93ZWJnbC1zZGYtZ2VuZXJhdG9yLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUSwrQ0FBK0M7QUFDcEUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRLCtDQUErQztBQUNwRSxhQUFhLHNEQUFzRDtBQUNuRTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxrREFBa0QsbUJBQW1CLGlCQUFpQixZQUFZLFFBQVEseURBQXlEOztBQUVuSywrQ0FBK0Msc0JBQXNCLGlCQUFpQixZQUFZLGlDQUFpQzs7QUFFbkk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4REFBOEQ7QUFDNUUsY0FBYyxFQUFFLHNGQUFzRixZQUFZO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0Esb0NBQW9DLHlCQUF5Qjs7QUFFN0Q7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEMseUJBQXlCLGtCQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLElBQUk7QUFDeEM7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSTtBQUN4QztBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsMENBQTBDLDBCQUEwQixtQkFBbUIsNEJBQTRCLDBCQUEwQixzQkFBc0IsWUFBWSwwQkFBMEIsa0RBQWtELHlEQUF5RDs7QUFFcFQsNENBQTRDLDBCQUEwQiwyQkFBMkIsd0JBQXdCLDBCQUEwQixzQkFBc0IseURBQXlELHlCQUF5QixpQ0FBaUMseUVBQXlFLDRCQUE0QiwrQkFBK0IsWUFBWSxzQkFBc0IsZ0JBQWdCLDZDQUE2QyxrRUFBa0UsMEZBQTBGLHdEQUF3RCxpR0FBaUc7O0FBRXB6Qiw0Q0FBNEMsc0JBQXNCLGlCQUFpQixZQUFZLDhCQUE4Qiw2QkFBNkIseUNBQXlDLHdCQUF3Qjs7QUFFM047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsY0FBYztBQUNsRjtBQUNBOztBQUVBOztBQUVBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG1DQUFtQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUSxxREFBcUQ7QUFDMUUsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUSwyRkFBMkY7QUFDaEg7QUFDQSxhQUFhLFFBQVEsOEVBQThFO0FBQ25HO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVEscURBQXFEO0FBQzFFLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVEsMkZBQTJGO0FBQ2hIO0FBQ0EsYUFBYSxRQUFRLDhFQUE4RTtBQUNuRztBQUNBLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELGFBQWE7O0FBRTlEOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy93ZWJnbC1zZGYtZ2VuZXJhdG9yL2Rpc3Qvd2ViZ2wtc2RmLWdlbmVyYXRvci5tanM/ODYzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBTREZHZW5lcmF0b3IoKSB7XG52YXIgZXhwb3J0cyA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBwb2ludCBvbiBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUgYXQgdCB3aGVyZSB0IGlzIGluIHRoZSByYW5nZSBbMCwgMV1cbiAgICovXG4gIGZ1bmN0aW9uIHBvaW50T25RdWFkcmF0aWNCZXppZXIgKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHQsIHBvaW50T3V0KSB7XG4gICAgdmFyIHQyID0gMSAtIHQ7XG4gICAgcG9pbnRPdXQueCA9IHQyICogdDIgKiB4MCArIDIgKiB0MiAqIHQgKiB4MSArIHQgKiB0ICogeDI7XG4gICAgcG9pbnRPdXQueSA9IHQyICogdDIgKiB5MCArIDIgKiB0MiAqIHQgKiB5MSArIHQgKiB0ICogeTI7XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgcG9pbnQgb24gYSBjdWJpYyBiZXppZXIgY3VydmUgYXQgdCB3aGVyZSB0IGlzIGluIHRoZSByYW5nZSBbMCwgMV1cbiAgICovXG4gIGZ1bmN0aW9uIHBvaW50T25DdWJpY0JlemllciAoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0LCBwb2ludE91dCkge1xuICAgIHZhciB0MiA9IDEgLSB0O1xuICAgIHBvaW50T3V0LnggPSB0MiAqIHQyICogdDIgKiB4MCArIDMgKiB0MiAqIHQyICogdCAqIHgxICsgMyAqIHQyICogdCAqIHQgKiB4MiArIHQgKiB0ICogdCAqIHgzO1xuICAgIHBvaW50T3V0LnkgPSB0MiAqIHQyICogdDIgKiB5MCArIDMgKiB0MiAqIHQyICogdCAqIHkxICsgMyAqIHQyICogdCAqIHQgKiB5MiArIHQgKiB0ICogdCAqIHkzO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgcGF0aCBzdHJpbmcgaW50byBpdHMgY29uc3RpdHVlbnQgbGluZS9jdXJ2ZSBjb21tYW5kcywgaW52b2tpbmcgYSBjYWxsYmFjayBmb3IgZWFjaC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmcgLSBBbiBTVkctbGlrZSBwYXRoIHN0cmluZyB0byBwYXJzZTsgc2hvdWxkIG9ubHkgY29udGFpbiBjb21tYW5kczogTS9ML1EvQy9aXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oXG4gICAqICAgY29tbWFuZDogJ0wnfCdRJ3wnQycsXG4gICAqICAgc3RhcnRYOiBudW1iZXIsXG4gICAqICAgc3RhcnRZOiBudW1iZXIsXG4gICAqICAgZW5kWDogbnVtYmVyLFxuICAgKiAgIGVuZFk6IG51bWJlcixcbiAgICogICBjdHJsMVg/OiBudW1iZXIsXG4gICAqICAgY3RybDFZPzogbnVtYmVyLFxuICAgKiAgIGN0cmwyWD86IG51bWJlcixcbiAgICogICBjdHJsMlk/OiBudW1iZXJcbiAgICogKX0gY29tbWFuZENhbGxiYWNrIC0gQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgZm9yIGVhY2ggcGFyc2VkIHBhdGggY29tbWFuZCwgcGFzc2luZyB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgY29tbWFuZCBpZGVudGlmaWVyIChvbmx5IEwvUS9DIGNvbW1hbmRzKSBhbmQgaXRzIG51bWVyaWMgYXJndW1lbnRzLlxuICAgKi9cbiAgZnVuY3Rpb24gZm9yRWFjaFBhdGhDb21tYW5kKHBhdGhTdHJpbmcsIGNvbW1hbmRDYWxsYmFjaykge1xuICAgIHZhciBzZWdtZW50UkUgPSAvKFtNTFFDWl0pKFteTUxRQ1pdKikvZztcbiAgICB2YXIgbWF0Y2gsIGZpcnN0WCwgZmlyc3RZLCBwcmV2WCwgcHJldlk7XG4gICAgd2hpbGUgKChtYXRjaCA9IHNlZ21lbnRSRS5leGVjKHBhdGhTdHJpbmcpKSkge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaFsyXVxuICAgICAgICAucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpXG4gICAgICAgIC5zcGxpdCgvWyxcXHNdKy8pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHBhcnNlRmxvYXQodik7IH0pO1xuICAgICAgc3dpdGNoIChtYXRjaFsxXSkge1xuICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICBwcmV2WCA9IGZpcnN0WCA9IGFyZ3NbMF07XG4gICAgICAgICAgcHJldlkgPSBmaXJzdFkgPSBhcmdzWzFdO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgIGlmIChhcmdzWzBdICE9PSBwcmV2WCB8fCBhcmdzWzFdICE9PSBwcmV2WSkgeyAvLyB5dXAsIHNvbWUgZm9udHMgaGF2ZSB6ZXJvLWxlbmd0aCBsaW5lIGNvbW1hbmRzXG4gICAgICAgICAgICBjb21tYW5kQ2FsbGJhY2soJ0wnLCBwcmV2WCwgcHJldlksIChwcmV2WCA9IGFyZ3NbMF0pLCAocHJldlkgPSBhcmdzWzFdKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ1EnOiB7XG4gICAgICAgICAgY29tbWFuZENhbGxiYWNrKCdRJywgcHJldlgsIHByZXZZLCAocHJldlggPSBhcmdzWzJdKSwgKHByZXZZID0gYXJnc1szXSksIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnQyc6IHtcbiAgICAgICAgICBjb21tYW5kQ2FsbGJhY2soJ0MnLCBwcmV2WCwgcHJldlksIChwcmV2WCA9IGFyZ3NbNF0pLCAocHJldlkgPSBhcmdzWzVdKSwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICBpZiAocHJldlggIT09IGZpcnN0WCB8fCBwcmV2WSAhPT0gZmlyc3RZKSB7XG4gICAgICAgICAgICBjb21tYW5kQ2FsbGJhY2soJ0wnLCBwcmV2WCwgcHJldlksIGZpcnN0WCwgZmlyc3RZKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIHBhdGggc3RyaW5nIHRvIGEgc2VyaWVzIG9mIHN0cmFpZ2h0IGxpbmUgc2VnbWVudHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmcgLSBBbiBTVkctbGlrZSBwYXRoIHN0cmluZyB0byBwYXJzZTsgc2hvdWxkIG9ubHkgY29udGFpbiBjb21tYW5kczogTS9ML1EvQy9aXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oeDE6bnVtYmVyLCB5MTpudW1iZXIsIHgyOm51bWJlciwgeTI6bnVtYmVyKX0gc2VnbWVudENhbGxiYWNrIC0gQSBjYWxsYmFja1xuICAgKiAgICAgICAgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBldmVyeSBsaW5lIHNlZ21lbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjdXJ2ZVBvaW50c10gLSBIb3cgbWFueSBzdHJhaWdodCBsaW5lIHNlZ21lbnRzIHRvIHVzZSB3aGVuIGFwcHJveGltYXRpbmcgYVxuICAgKiAgICAgICAgYmV6aWVyIGN1cnZlIGluIHRoZSBwYXRoLiBEZWZhdWx0cyB0byAxNi5cbiAgICovXG4gIGZ1bmN0aW9uIHBhdGhUb0xpbmVTZWdtZW50cyAocGF0aFN0cmluZywgc2VnbWVudENhbGxiYWNrLCBjdXJ2ZVBvaW50cykge1xuICAgIGlmICggY3VydmVQb2ludHMgPT09IHZvaWQgMCApIGN1cnZlUG9pbnRzID0gMTY7XG5cbiAgICB2YXIgdGVtcFBvaW50ID0geyB4OiAwLCB5OiAwIH07XG4gICAgZm9yRWFjaFBhdGhDb21tYW5kKHBhdGhTdHJpbmcsIGZ1bmN0aW9uIChjb21tYW5kLCBzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSwgY3RybDFYLCBjdHJsMVksIGN0cmwyWCwgY3RybDJZKSB7XG4gICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgc2VnbWVudENhbGxiYWNrKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdRJzoge1xuICAgICAgICAgIHZhciBwcmV2Q3VydmVYID0gc3RhcnRYO1xuICAgICAgICAgIHZhciBwcmV2Q3VydmVZID0gc3RhcnRZO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY3VydmVQb2ludHM7IGkrKykge1xuICAgICAgICAgICAgcG9pbnRPblF1YWRyYXRpY0JlemllcihcbiAgICAgICAgICAgICAgc3RhcnRYLCBzdGFydFksXG4gICAgICAgICAgICAgIGN0cmwxWCwgY3RybDFZLFxuICAgICAgICAgICAgICBlbmRYLCBlbmRZLFxuICAgICAgICAgICAgICBpIC8gKGN1cnZlUG9pbnRzIC0gMSksXG4gICAgICAgICAgICAgIHRlbXBQb2ludFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNlZ21lbnRDYWxsYmFjayhwcmV2Q3VydmVYLCBwcmV2Q3VydmVZLCB0ZW1wUG9pbnQueCwgdGVtcFBvaW50LnkpO1xuICAgICAgICAgICAgcHJldkN1cnZlWCA9IHRlbXBQb2ludC54O1xuICAgICAgICAgICAgcHJldkN1cnZlWSA9IHRlbXBQb2ludC55O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0MnOiB7XG4gICAgICAgICAgdmFyIHByZXZDdXJ2ZVgkMSA9IHN0YXJ0WDtcbiAgICAgICAgICB2YXIgcHJldkN1cnZlWSQxID0gc3RhcnRZO1xuICAgICAgICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IGN1cnZlUG9pbnRzOyBpJDErKykge1xuICAgICAgICAgICAgcG9pbnRPbkN1YmljQmV6aWVyKFxuICAgICAgICAgICAgICBzdGFydFgsIHN0YXJ0WSxcbiAgICAgICAgICAgICAgY3RybDFYLCBjdHJsMVksXG4gICAgICAgICAgICAgIGN0cmwyWCwgY3RybDJZLFxuICAgICAgICAgICAgICBlbmRYLCBlbmRZLFxuICAgICAgICAgICAgICBpJDEgLyAoY3VydmVQb2ludHMgLSAxKSxcbiAgICAgICAgICAgICAgdGVtcFBvaW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2VnbWVudENhbGxiYWNrKHByZXZDdXJ2ZVgkMSwgcHJldkN1cnZlWSQxLCB0ZW1wUG9pbnQueCwgdGVtcFBvaW50LnkpO1xuICAgICAgICAgICAgcHJldkN1cnZlWCQxID0gdGVtcFBvaW50Lng7XG4gICAgICAgICAgICBwcmV2Q3VydmVZJDEgPSB0ZW1wUG9pbnQueTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHZpZXdwb3J0UXVhZFZlcnRleCA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O2F0dHJpYnV0ZSB2ZWMyIGFVVjt2YXJ5aW5nIHZlYzIgdlVWO3ZvaWQgbWFpbigpe3ZVVj1hVVY7Z2xfUG9zaXRpb249dmVjNChtaXgodmVjMigtMS4wKSx2ZWMyKDEuMCksYVVWKSwwLjAsMS4wKTt9XCI7XG5cbiAgdmFyIGNvcHlUZXhGcmFnbWVudCA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O3VuaWZvcm0gc2FtcGxlcjJEIHRleDt2YXJ5aW5nIHZlYzIgdlVWO3ZvaWQgbWFpbigpe2dsX0ZyYWdDb2xvcj10ZXh0dXJlMkQodGV4LHZVVik7fVwiO1xuXG4gIHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgdmFyIGdsQ29udGV4dFBhcmFtcyA9IHtcbiAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlLFxuICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZSxcbiAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgIGRlcHRoOiBmYWxzZSxcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGxpdHRsZSBoZWxwZXIgbGlicmFyeSBmb3IgV2ViR0wuIEl0IGFzc2lzdHMgd2l0aCBzdGF0ZSBtYW5hZ2VtZW50IGZvciBhIEdMIGNvbnRleHQuXG4gICAqIEl0J3MgcHJldHR5IHRpZ2h0bHkgd3JhcHBlZCB0byB0aGUgbmVlZHMgb2YgdGhpcyBwYWNrYWdlLCBub3QgdmVyeSBnZW5lcmFsLXB1cnBvc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7IFdlYkdMUmVuZGVyaW5nQ29udGV4dCB8IEhUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzIH0gZ2xPckNhbnZhcyAtIHRoZSBHTCBjb250ZXh0IHRvIHdyYXBcbiAgICogQHBhcmFtIHsgKHtnbCwgZ2V0RXh0ZW5zaW9uLCB3aXRoUHJvZ3JhbSwgd2l0aFRleHR1cmUsIHdpdGhUZXh0dXJlRnJhbWVidWZmZXIsIGhhbmRsZUNvbnRleHRMb3NzfSkgPT4gdm9pZCB9IGNhbGxiYWNrXG4gICAqL1xuICBmdW5jdGlvbiB3aXRoV2ViR0xDb250ZXh0IChnbE9yQ2FudmFzLCBjYWxsYmFjaykge1xuICAgIHZhciBnbCA9IGdsT3JDYW52YXMuZ2V0Q29udGV4dCA/IGdsT3JDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBnbENvbnRleHRQYXJhbXMpIDogZ2xPckNhbnZhcztcbiAgICB2YXIgd3JhcHBlciA9IGNhY2hlLmdldChnbCk7XG4gICAgaWYgKCF3cmFwcGVyKSB7XG4gICAgICB2YXIgaXNXZWJHTDIgPSB0eXBlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICAgICAgdmFyIGV4dGVuc2lvbnMgPSB7fTtcbiAgICAgIHZhciBwcm9ncmFtcyA9IHt9O1xuICAgICAgdmFyIHRleHR1cmVzID0ge307XG4gICAgICB2YXIgdGV4dHVyZVVuaXQgPSAtMTtcbiAgICAgIHZhciBmcmFtZWJ1ZmZlclN0YWNrID0gW107XG5cbiAgICAgIGdsLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaGFuZGxlQ29udGV4dExvc3MoKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRFeHRlbnNpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGV4dCA9IGV4dGVuc2lvbnNbbmFtZV07XG4gICAgICAgIGlmICghZXh0KSB7XG4gICAgICAgICAgZXh0ID0gZXh0ZW5zaW9uc1tuYW1lXSA9IGdsLmdldEV4dGVuc2lvbihuYW1lKTtcbiAgICAgICAgICBpZiAoIWV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChuYW1lICsgXCIgbm90IHN1cHBvcnRlZFwiKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dFxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjb21waWxlU2hhZGVyIChzcmMsIHR5cGUpIHtcbiAgICAgICAgdmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc3JjKTtcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgICAgICAvLyBjb25zdCBzdGF0dXMgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUylcbiAgICAgICAgLy8gaWYgKCFzdGF0dXMgJiYgIWdsLmlzQ29udGV4dExvc3QoKSkge1xuICAgICAgICAvLyAgIHRocm93IG5ldyBFcnJvcihnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikudHJpbSgpKVxuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiBzaGFkZXJcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gd2l0aFByb2dyYW0gKG5hbWUsIHZlcnQsIGZyYWcsIGZ1bmMpIHtcbiAgICAgICAgaWYgKCFwcm9ncmFtc1tuYW1lXSkge1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgdmFyIHVuaWZvcm1zID0ge307XG4gICAgICAgICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGNvbXBpbGVTaGFkZXIodmVydCwgZ2wuVkVSVEVYX1NIQURFUikpO1xuICAgICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBjb21waWxlU2hhZGVyKGZyYWcsIGdsLkZSQUdNRU5UX1NIQURFUikpO1xuICAgICAgICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgICAgICAgcHJvZ3JhbXNbbmFtZV0gPSB7XG4gICAgICAgICAgICBwcm9ncmFtOiBwcm9ncmFtLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IGZ1bmN0aW9uIHRyYW5zYWN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgICAgICAgIGZ1bmMoe1xuICAgICAgICAgICAgICAgIHNldFVuaWZvcm06IGZ1bmN0aW9uIHNldFVuaWZvcm0gKHR5cGUsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoIGxlbi0tID4gMCApIHZhbHVlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDIgXTtcblxuICAgICAgICAgICAgICAgICAgdmFyIHVuaWZvcm1Mb2MgPSB1bmlmb3Jtc1tuYW1lXSB8fCAodW5pZm9ybXNbbmFtZV0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSkpO1xuICAgICAgICAgICAgICAgICAgZ2xbKFwidW5pZm9ybVwiICsgdHlwZSldLmFwcGx5KGdsLCBbIHVuaWZvcm1Mb2MgXS5jb25jYXQoIHZhbHVlcyApKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgc2V0QXR0cmlidXRlOiBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5hbWUsIHNpemUsIHVzYWdlLCBpbnN0YW5jaW5nRGl2aXNvciwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgaWYgKCFhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHIgPSBhdHRyaWJ1dGVzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICAgIGJ1ZjogZ2wuY3JlYXRlQnVmZmVyKCksIC8vIFRPRE8gc2hvdWxkIHdlIGRlc3Ryb3kgb3VyIGJ1ZmZlcnM/XG4gICAgICAgICAgICAgICAgICAgICAgbG9jOiBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYXR0ci5idWYpO1xuICAgICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyLmxvYywgc2l6ZSwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHIubG9jKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1dlYkdMMikge1xuICAgICAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHIubG9jLCBpbnN0YW5jaW5nRGl2aXNvcik7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRFeHRlbnNpb24oJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKS52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoYXR0ci5sb2MsIGluc3RhbmNpbmdEaXZpc29yKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChkYXRhICE9PSBhdHRyLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIHVzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgYXR0ci5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBwcm9ncmFtc1tuYW1lXS50cmFuc2FjdGlvbihmdW5jKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gd2l0aFRleHR1cmUgKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgdGV4dHVyZVVuaXQrKztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4dHVyZVVuaXQpO1xuICAgICAgICAgIHZhciB0ZXh0dXJlID0gdGV4dHVyZXNbbmFtZV07XG4gICAgICAgICAgaWYgKCF0ZXh0dXJlKSB7XG4gICAgICAgICAgICB0ZXh0dXJlID0gdGV4dHVyZXNbbmFtZV0gPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICAgICAgZnVuYyh0ZXh0dXJlLCB0ZXh0dXJlVW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGV4dHVyZVVuaXQtLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyICh0ZXh0dXJlLCB0ZXh0dXJlVW5pdCwgZnVuYykge1xuICAgICAgICB2YXIgZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICBmcmFtZWJ1ZmZlclN0YWNrLnB1c2goZnJhbWVidWZmZXIpO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVVbml0KTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgMCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZnVuYyhmcmFtZWJ1ZmZlcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoZnJhbWVidWZmZXIpO1xuICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXJTdGFja1stLWZyYW1lYnVmZmVyU3RhY2subGVuZ3RoIC0gMV0gfHwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGFuZGxlQ29udGV4dExvc3MgKCkge1xuICAgICAgICBleHRlbnNpb25zID0ge307XG4gICAgICAgIHByb2dyYW1zID0ge307XG4gICAgICAgIHRleHR1cmVzID0ge307XG4gICAgICAgIHRleHR1cmVVbml0ID0gLTE7XG4gICAgICAgIGZyYW1lYnVmZmVyU3RhY2subGVuZ3RoID0gMDtcbiAgICAgIH1cblxuICAgICAgY2FjaGUuc2V0KGdsLCB3cmFwcGVyID0ge1xuICAgICAgICBnbDogZ2wsXG4gICAgICAgIGlzV2ViR0wyOiBpc1dlYkdMMixcbiAgICAgICAgZ2V0RXh0ZW5zaW9uOiBnZXRFeHRlbnNpb24sXG4gICAgICAgIHdpdGhQcm9ncmFtOiB3aXRoUHJvZ3JhbSxcbiAgICAgICAgd2l0aFRleHR1cmU6IHdpdGhUZXh0dXJlLFxuICAgICAgICB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyOiB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyLFxuICAgICAgICBoYW5kbGVDb250ZXh0TG9zczogaGFuZGxlQ29udGV4dExvc3MsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY2FsbGJhY2sod3JhcHBlcik7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHJlbmRlckltYWdlRGF0YShnbE9yQ2FudmFzLCBpbWFnZURhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGNoYW5uZWxzLCBmcmFtZWJ1ZmZlcikge1xuICAgIGlmICggY2hhbm5lbHMgPT09IHZvaWQgMCApIGNoYW5uZWxzID0gMTU7XG4gICAgaWYgKCBmcmFtZWJ1ZmZlciA9PT0gdm9pZCAwICkgZnJhbWVidWZmZXIgPSBudWxsO1xuXG4gICAgd2l0aFdlYkdMQ29udGV4dChnbE9yQ2FudmFzLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICB2YXIgZ2wgPSByZWYuZ2w7XG4gICAgICB2YXIgd2l0aFByb2dyYW0gPSByZWYud2l0aFByb2dyYW07XG4gICAgICB2YXIgd2l0aFRleHR1cmUgPSByZWYud2l0aFRleHR1cmU7XG5cbiAgICAgIHdpdGhUZXh0dXJlKCdjb3B5JywgZnVuY3Rpb24gKHRleCwgdGV4VW5pdCkge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHdpZHRoLCBoZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGltYWdlRGF0YSk7XG4gICAgICAgIHdpdGhQcm9ncmFtKCdjb3B5Jywgdmlld3BvcnRRdWFkVmVydGV4LCBjb3B5VGV4RnJhZ21lbnQsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICB2YXIgc2V0VW5pZm9ybSA9IHJlZi5zZXRVbmlmb3JtO1xuICAgICAgICAgIHZhciBzZXRBdHRyaWJ1dGUgPSByZWYuc2V0QXR0cmlidXRlO1xuXG4gICAgICAgICAgc2V0QXR0cmlidXRlKCdhVVYnLCAyLCBnbC5TVEFUSUNfRFJBVywgMCwgbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMiwgMCwgMCwgMl0pKTtcbiAgICAgICAgICBzZXRVbmlmb3JtKCcxaScsICdpbWFnZScsIHRleFVuaXQpO1xuICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgfHwgbnVsbCk7XG4gICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgZ2wuY29sb3JNYXNrKGNoYW5uZWxzICYgOCwgY2hhbm5lbHMgJiA0LCBjaGFubmVscyAmIDIsIGNoYW5uZWxzICYgMSk7XG4gICAgICAgICAgZ2wudmlld3BvcnQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgZ2wuc2Npc3Nvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgMyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzaXppbmcgYSBjYW52YXMgY2xlYXJzIGl0cyBjb250ZW50czsgdGhpcyB1dGlsaXR5IGNvcGllcyB0aGUgcHJldmlvdXMgY29udGVudHMgb3Zlci5cbiAgICogQHBhcmFtIGNhbnZhc1xuICAgKiBAcGFyYW0gbmV3V2lkdGhcbiAgICogQHBhcmFtIG5ld0hlaWdodFxuICAgKi9cbiAgZnVuY3Rpb24gcmVzaXplV2ViR0xDYW52YXNXaXRob3V0Q2xlYXJpbmcoY2FudmFzLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7XG4gICAgdmFyIHdpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgIHdpdGhXZWJHTENvbnRleHQoY2FudmFzLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICB2YXIgZ2wgPSByZWYuZ2w7XG5cbiAgICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZGF0YSk7XG4gICAgICBjYW52YXMud2lkdGggPSBuZXdXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICByZW5kZXJJbWFnZURhdGEoZ2wsIGRhdGEsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHdlYmdsVXRpbHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIHdpdGhXZWJHTENvbnRleHQ6IHdpdGhXZWJHTENvbnRleHQsXG4gICAgcmVuZGVySW1hZ2VEYXRhOiByZW5kZXJJbWFnZURhdGEsXG4gICAgcmVzaXplV2ViR0xDYW52YXNXaXRob3V0Q2xlYXJpbmc6IHJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlJDIgKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCkge1xuICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcblxuICAgIHZhciB0ZXh0dXJlRGF0YSA9IG5ldyBVaW50OEFycmF5KHNkZldpZHRoICogc2RmSGVpZ2h0KTtcblxuICAgIHZhciB2aWV3Qm94V2lkdGggPSB2aWV3Qm94WzJdIC0gdmlld0JveFswXTtcbiAgICB2YXIgdmlld0JveEhlaWdodCA9IHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdO1xuXG4gICAgLy8gRGVjb21wb3NlIGFsbCBwYXRocyBpbnRvIHN0cmFpZ2h0IGxpbmUgc2VnbWVudHMgYW5kIGFkZCB0aGVtIHRvIGFuIGluZGV4XG4gICAgdmFyIHNlZ21lbnRzID0gW107XG4gICAgcGF0aFRvTGluZVNlZ21lbnRzKHBhdGgsIGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgIHgxOiB4MSwgeTE6IHkxLCB4MjogeDIsIHkyOiB5MixcbiAgICAgICAgbWluWDogTWF0aC5taW4oeDEsIHgyKSxcbiAgICAgICAgbWluWTogTWF0aC5taW4oeTEsIHkyKSxcbiAgICAgICAgbWF4WDogTWF0aC5tYXgoeDEsIHgyKSxcbiAgICAgICAgbWF4WTogTWF0aC5tYXgoeTEsIHkyKVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBTb3J0IHNlZ21lbnRzIGJ5IG1heFgsIHRoaXMgd2lsbCBsZXQgdXMgc2hvcnQtY2lyY3VpdCBzb21lIGxvb3BzIGJlbG93XG4gICAgc2VnbWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5tYXhYIC0gYi5tYXhYOyB9KTtcblxuICAgIC8vIEZvciBlYWNoIHRhcmdldCBTREYgdGV4ZWwsIGZpbmQgdGhlIGRpc3RhbmNlIGZyb20gaXRzIGNlbnRlciB0byBpdHMgbmVhcmVzdCBsaW5lIHNlZ21lbnQsXG4gICAgLy8gbWFwIHRoYXQgZGlzdGFuY2UgdG8gYW4gYWxwaGEgdmFsdWUsIGFuZCB3cml0ZSB0aGF0IGFscGhhIHRvIHRoZSB0ZXhlbFxuICAgIGZvciAodmFyIHNkZlggPSAwOyBzZGZYIDwgc2RmV2lkdGg7IHNkZlgrKykge1xuICAgICAgZm9yICh2YXIgc2RmWSA9IDA7IHNkZlkgPCBzZGZIZWlnaHQ7IHNkZlkrKykge1xuICAgICAgICB2YXIgc2lnbmVkRGlzdCA9IGZpbmROZWFyZXN0U2lnbmVkRGlzdGFuY2UoXG4gICAgICAgICAgdmlld0JveFswXSArIHZpZXdCb3hXaWR0aCAqIChzZGZYICsgMC41KSAvIHNkZldpZHRoLFxuICAgICAgICAgIHZpZXdCb3hbMV0gKyB2aWV3Qm94SGVpZ2h0ICogKHNkZlkgKyAwLjUpIC8gc2RmSGVpZ2h0XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gVXNlIGFuIGV4cG9uZW50aWFsIHNjYWxlIHRvIGVuc3VyZSB0aGUgdGV4ZWxzIHZlcnkgbmVhciB0aGUgZ2x5cGggcGF0aCBoYXZlIGFkZXF1YXRlXG4gICAgICAgIC8vIHByZWNpc2lvbiwgd2hpbGUgYWxsb3dpbmcgdGhlIGRpc3RhbmNlIGZpZWxkIHRvIGNvdmVyIHRoZSBlbnRpcmUgdGV4dHVyZSwgZ2l2ZW4gdGhhdFxuICAgICAgICAvLyB0aGVyZSBhcmUgb25seSA4IGJpdHMgYXZhaWxhYmxlLiBGb3JtdWxhIHZpc3VhbGl6ZWQ6IGh0dHBzOi8vd3d3LmRlc21vcy5jb20vY2FsY3VsYXRvci91aWFxNWFxaWFtXG4gICAgICAgIHZhciBhbHBoYSA9IE1hdGgucG93KCgxIC0gTWF0aC5hYnMoc2lnbmVkRGlzdCkgLyBtYXhEaXN0YW5jZSksIHNkZkV4cG9uZW50KSAvIDI7XG4gICAgICAgIGlmIChzaWduZWREaXN0IDwgMCkge1xuICAgICAgICAgIGFscGhhID0gMSAtIGFscGhhO1xuICAgICAgICB9XG5cbiAgICAgICAgYWxwaGEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQoYWxwaGEgKiAyNTUpKSk7IC8vY2xhbXBcbiAgICAgICAgdGV4dHVyZURhdGFbc2RmWSAqIHNkZldpZHRoICsgc2RmWF0gPSBhbHBoYTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dHVyZURhdGFcblxuICAgIC8qKlxuICAgICAqIEZvciBhIGdpdmVuIHgveSwgc2VhcmNoIHRoZSBpbmRleCBmb3IgdGhlIGNsb3Nlc3QgbGluZSBzZWdtZW50IGFuZCByZXR1cm5cbiAgICAgKiBpdHMgc2lnbmVkIGRpc3RhbmNlLiBOZWdhdGl2ZSA9IGluc2lkZSwgcG9zaXRpdmUgPSBvdXRzaWRlLCB6ZXJvID0gb24gZWRnZVxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmROZWFyZXN0U2lnbmVkRGlzdGFuY2UgKHgsIHkpIHtcbiAgICAgIHZhciBjbG9zZXN0RGlzdFNxID0gSW5maW5pdHk7XG4gICAgICB2YXIgY2xvc2VzdERpc3QgPSBJbmZpbml0eTtcblxuICAgICAgZm9yICh2YXIgaSA9IHNlZ21lbnRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICB2YXIgc2VnID0gc2VnbWVudHNbaV07XG4gICAgICAgIGlmIChzZWcubWF4WCArIGNsb3Nlc3REaXN0IDw9IHgpIHsgYnJlYWsgfSAvL3NvcnRpbmcgYnkgbWF4WCBtZWFucyBubyBtb3JlIGNhbiBiZSBjbG9zZXIsIHNvIHdlIGNhbiBzaG9ydC1jaXJjdWl0XG4gICAgICAgIGlmICh4ICsgY2xvc2VzdERpc3QgPiBzZWcubWluWCAmJiB5IC0gY2xvc2VzdERpc3QgPCBzZWcubWF4WSAmJiB5ICsgY2xvc2VzdERpc3QgPiBzZWcubWluWSkge1xuICAgICAgICAgIHZhciBkaXN0U3EgPSBhYnNTcXVhcmVEaXN0YW5jZVRvTGluZVNlZ21lbnQoeCwgeSwgc2VnLngxLCBzZWcueTEsIHNlZy54Miwgc2VnLnkyKTtcbiAgICAgICAgICBpZiAoZGlzdFNxIDwgY2xvc2VzdERpc3RTcSkge1xuICAgICAgICAgICAgY2xvc2VzdERpc3RTcSA9IGRpc3RTcTtcbiAgICAgICAgICAgIGNsb3Nlc3REaXN0ID0gTWF0aC5zcXJ0KGNsb3Nlc3REaXN0U3EpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGbGlwIHRvIG5lZ2F0aXZlIGRpc3RhbmNlIGlmIGluc2lkZSB0aGUgcG9seVxuICAgICAgaWYgKGlzUG9pbnRJblBvbHkoeCwgeSkpIHtcbiAgICAgICAgY2xvc2VzdERpc3QgPSAtY2xvc2VzdERpc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvc2VzdERpc3RcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgZ2l2ZW4gcG9pbnQgbGllcyBpbnNpZGUgb3Igb3V0c2lkZSB0aGUgZ2x5cGguIFVzZXMgYSBzaW1wbGVcbiAgICAgKiB3aW5kaW5nLW51bWJlciByYXkgY2FzdGluZyBhbGdvcml0aG0gdXNpbmcgYSByYXkgcG9pbnRpbmcgZWFzdCBmcm9tIHRoZSBwb2ludC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1BvaW50SW5Qb2x5ICh4LCB5KSB7XG4gICAgICB2YXIgd2luZGluZyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gc2VnbWVudHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIHZhciBzZWcgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgaWYgKHNlZy5tYXhYIDw9IHgpIHsgYnJlYWsgfSAvL3NvcnRpbmcgYnkgbWF4WCBtZWFucyBubyBtb3JlIGNhbiBjcm9zcywgc28gd2UgY2FuIHNob3J0LWNpcmN1aXRcbiAgICAgICAgdmFyIGludGVyc2VjdHMgPSAoKHNlZy55MSA+IHkpICE9PSAoc2VnLnkyID4geSkpICYmICh4IDwgKHNlZy54MiAtIHNlZy54MSkgKiAoeSAtIHNlZy55MSkgLyAoc2VnLnkyIC0gc2VnLnkxKSArIHNlZy54MSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3RzKSB7XG4gICAgICAgICAgd2luZGluZyArPSBzZWcueTEgPCBzZWcueTIgPyAxIDogLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB3aW5kaW5nICE9PSAwXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVJbnRvQ2FudmFzJDIoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwpIHtcbiAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG4gICAgaWYgKCB4ID09PSB2b2lkIDAgKSB4ID0gMDtcbiAgICBpZiAoIHkgPT09IHZvaWQgMCApIHkgPSAwO1xuICAgIGlmICggY2hhbm5lbCA9PT0gdm9pZCAwICkgY2hhbm5lbCA9IDA7XG5cbiAgICBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlciQxKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgY2FudmFzLCBudWxsLCB4LCB5LCBjaGFubmVsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyJDEgKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgZ2xPckNhbnZhcywgZnJhbWVidWZmZXIsIHgsIHksIGNoYW5uZWwpIHtcbiAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG4gICAgaWYgKCB4ID09PSB2b2lkIDAgKSB4ID0gMDtcbiAgICBpZiAoIHkgPT09IHZvaWQgMCApIHkgPSAwO1xuICAgIGlmICggY2hhbm5lbCA9PT0gdm9pZCAwICkgY2hhbm5lbCA9IDA7XG5cbiAgICB2YXIgZGF0YSA9IGdlbmVyYXRlJDIoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50KTtcbiAgICAvLyBFeHBhbmQgc2luZ2xlLWNoYW5uZWwgZGF0YSB0byByYmdhXG4gICAgdmFyIHJnYmFEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKiA0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJnYmFEYXRhW2kgKiA0ICsgY2hhbm5lbF0gPSBkYXRhW2ldO1xuICAgIH1cbiAgICByZW5kZXJJbWFnZURhdGEoZ2xPckNhbnZhcywgcmdiYURhdGEsIHgsIHksIHNkZldpZHRoLCBzZGZIZWlnaHQsIDEgPDwgKDMgLSBjaGFubmVsKSwgZnJhbWVidWZmZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIGFic29sdXRlIGRpc3RhbmNlIGZyb20gYSBwb2ludCB0byBhIGxpbmUgc2VnbWVudCBhdCBjbG9zZXN0IGFwcHJvYWNoXG4gICAqL1xuICBmdW5jdGlvbiBhYnNTcXVhcmVEaXN0YW5jZVRvTGluZVNlZ21lbnQgKHgsIHksIGxpbmVYMCwgbGluZVkwLCBsaW5lWDEsIGxpbmVZMSkge1xuICAgIHZhciBsZHggPSBsaW5lWDEgLSBsaW5lWDA7XG4gICAgdmFyIGxkeSA9IGxpbmVZMSAtIGxpbmVZMDtcbiAgICB2YXIgbGVuZ3RoU3EgPSBsZHggKiBsZHggKyBsZHkgKiBsZHk7XG4gICAgdmFyIHQgPSBsZW5ndGhTcSA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsICgoeCAtIGxpbmVYMCkgKiBsZHggKyAoeSAtIGxpbmVZMCkgKiBsZHkpIC8gbGVuZ3RoU3EpKSA6IDA7XG4gICAgdmFyIGR4ID0geCAtIChsaW5lWDAgKyB0ICogbGR4KTtcbiAgICB2YXIgZHkgPSB5IC0gKGxpbmVZMCArIHQgKiBsZHkpO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeVxuICB9XG5cbiAgdmFyIGphdmFzY3JpcHQgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdlbmVyYXRlOiBnZW5lcmF0ZSQyLFxuICAgIGdlbmVyYXRlSW50b0NhbnZhczogZ2VuZXJhdGVJbnRvQ2FudmFzJDIsXG4gICAgZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXI6IGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyJDFcbiAgfSk7XG5cbiAgdmFyIG1haW5WZXJ0ZXggPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDt1bmlmb3JtIHZlYzQgdUdseXBoQm91bmRzO2F0dHJpYnV0ZSB2ZWMyIGFVVjthdHRyaWJ1dGUgdmVjNCBhTGluZVNlZ21lbnQ7dmFyeWluZyB2ZWM0IHZMaW5lU2VnbWVudDt2YXJ5aW5nIHZlYzIgdkdseXBoWFk7dm9pZCBtYWluKCl7dkxpbmVTZWdtZW50PWFMaW5lU2VnbWVudDt2R2x5cGhYWT1taXgodUdseXBoQm91bmRzLnh5LHVHbHlwaEJvdW5kcy56dyxhVVYpO2dsX1Bvc2l0aW9uPXZlYzQobWl4KHZlYzIoLTEuMCksdmVjMigxLjApLGFVViksMC4wLDEuMCk7fVwiO1xuXG4gIHZhciBtYWluRnJhZ21lbnQgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDt1bmlmb3JtIHZlYzQgdUdseXBoQm91bmRzO3VuaWZvcm0gZmxvYXQgdU1heERpc3RhbmNlO3VuaWZvcm0gZmxvYXQgdUV4cG9uZW50O3ZhcnlpbmcgdmVjNCB2TGluZVNlZ21lbnQ7dmFyeWluZyB2ZWMyIHZHbHlwaFhZO2Zsb2F0IGFic0Rpc3RUb1NlZ21lbnQodmVjMiBwb2ludCx2ZWMyIGxpbmVBLHZlYzIgbGluZUIpe3ZlYzIgbGluZURpcj1saW5lQi1saW5lQTtmbG9hdCBsZW5TcT1kb3QobGluZURpcixsaW5lRGlyKTtmbG9hdCB0PWxlblNxPT0wLjAgPyAwLjAgOiBjbGFtcChkb3QocG9pbnQtbGluZUEsbGluZURpcikvbGVuU3EsMC4wLDEuMCk7dmVjMiBsaW5lUHQ9bGluZUErdCpsaW5lRGlyO3JldHVybiBkaXN0YW5jZShwb2ludCxsaW5lUHQpO312b2lkIG1haW4oKXt2ZWM0IHNlZz12TGluZVNlZ21lbnQ7dmVjMiBwPXZHbHlwaFhZO2Zsb2F0IGRpc3Q9YWJzRGlzdFRvU2VnbWVudChwLHNlZy54eSxzZWcuencpO2Zsb2F0IHZhbD1wb3coMS4wLWNsYW1wKGRpc3QvdU1heERpc3RhbmNlLDAuMCwxLjApLHVFeHBvbmVudCkqMC41O2Jvb2wgY3Jvc3Npbmc9KHNlZy55PnAueSE9c2VnLnc+cC55KSYmKHAueDwoc2VnLnotc2VnLngpKihwLnktc2VnLnkpLyhzZWcudy1zZWcueSkrc2VnLngpO2Jvb2wgY3Jvc3NpbmdVcD1jcm9zc2luZyYmdkxpbmVTZWdtZW50Lnk8dkxpbmVTZWdtZW50Lnc7Z2xfRnJhZ0NvbG9yPXZlYzQoY3Jvc3NpbmdVcCA/IDEuMC8yNTUuMCA6IDAuMCxjcm9zc2luZyYmIWNyb3NzaW5nVXAgPyAxLjAvMjU1LjAgOiAwLjAsMC4wLHZhbCk7fVwiO1xuXG4gIHZhciBwb3N0RnJhZ21lbnQgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDt1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7dmFyeWluZyB2ZWMyIHZVVjt2b2lkIG1haW4oKXt2ZWM0IGNvbG9yPXRleHR1cmUyRCh0ZXgsdlVWKTtib29sIGluc2lkZT1jb2xvci5yIT1jb2xvci5nO2Zsb2F0IHZhbD1pbnNpZGUgPyAxLjAtY29sb3IuYSA6IGNvbG9yLmE7Z2xfRnJhZ0NvbG9yPXZlYzQodmFsKTt9XCI7XG5cbiAgLy8gU2luZ2xlIHRyaWFuZ2xlIGNvdmVyaW5nIHZpZXdwb3J0XG4gIHZhciB2aWV3cG9ydFVWcyA9IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDIsIDAsIDAsIDJdKTtcblxuICB2YXIgaW1wbGljaXRDb250ZXh0ID0gbnVsbDtcbiAgdmFyIGlzVGVzdGluZ1N1cHBvcnQgPSBmYWxzZTtcbiAgdmFyIE5VTExfT0JKRUNUID0ge307XG4gIHZhciBzdXBwb3J0QnlDYW52YXMgPSBuZXcgV2Vha01hcCgpOyAvLyBjYW52YXMgLT4gYm9vbFxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlU3VwcG9ydCAoZ2xPckNhbnZhcykge1xuICAgIGlmICghaXNUZXN0aW5nU3VwcG9ydCAmJiAhaXNTdXBwb3J0ZWQoZ2xPckNhbnZhcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wgZ2VuZXJhdGlvbiBub3Qgc3VwcG9ydGVkJylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZSQxIChzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGdsT3JDYW52YXMpIHtcbiAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG4gICAgaWYgKCBnbE9yQ2FudmFzID09PSB2b2lkIDAgKSBnbE9yQ2FudmFzID0gbnVsbDtcblxuICAgIGlmICghZ2xPckNhbnZhcykge1xuICAgICAgZ2xPckNhbnZhcyA9IGltcGxpY2l0Q29udGV4dDtcbiAgICAgIGlmICghZ2xPckNhbnZhcykge1xuICAgICAgICB2YXIgY2FudmFzID0gdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKVxuICAgICAgICAgIDogdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2Zmc2NyZWVuQ2FudmFzIG9yIERPTSBjYW52YXMgbm90IHN1cHBvcnRlZCcpXG4gICAgICAgIH1cbiAgICAgICAgZ2xPckNhbnZhcyA9IGltcGxpY2l0Q29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIHsgZGVwdGg6IGZhbHNlIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlU3VwcG9ydChnbE9yQ2FudmFzKTtcblxuICAgIHZhciByZ2JhRGF0YSA9IG5ldyBVaW50OEFycmF5KHNkZldpZHRoICogc2RmSGVpZ2h0ICogNCk7IC8vbm90IFVpbnQ4Q2xhbXBlZEFycmF5LCBjdXogU2FmYXJpXG5cbiAgICAvLyBSZW5kZXIgaW50byBhIGJhY2tncm91bmQgdGV4dHVyZSBmcmFtZWJ1ZmZlclxuICAgIHdpdGhXZWJHTENvbnRleHQoZ2xPckNhbnZhcywgZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIGdsID0gcmVmLmdsO1xuICAgICAgdmFyIHdpdGhUZXh0dXJlID0gcmVmLndpdGhUZXh0dXJlO1xuICAgICAgdmFyIHdpdGhUZXh0dXJlRnJhbWVidWZmZXIgPSByZWYud2l0aFRleHR1cmVGcmFtZWJ1ZmZlcjtcblxuICAgICAgd2l0aFRleHR1cmUoJ3JlYWRhYmxlJywgZnVuY3Rpb24gKHRleHR1cmUsIHRleHR1cmVVbml0KSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgc2RmV2lkdGgsIHNkZkhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cbiAgICAgICAgd2l0aFRleHR1cmVGcmFtZWJ1ZmZlcih0ZXh0dXJlLCB0ZXh0dXJlVW5pdCwgZnVuY3Rpb24gKGZyYW1lYnVmZmVyKSB7XG4gICAgICAgICAgZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIoXG4gICAgICAgICAgICBzZGZXaWR0aCxcbiAgICAgICAgICAgIHNkZkhlaWdodCxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICB2aWV3Qm94LFxuICAgICAgICAgICAgbWF4RGlzdGFuY2UsXG4gICAgICAgICAgICBzZGZFeHBvbmVudCxcbiAgICAgICAgICAgIGdsLFxuICAgICAgICAgICAgZnJhbWVidWZmZXIsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAgLy8gcmVkIGNoYW5uZWxcbiAgICAgICAgICApO1xuICAgICAgICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgc2RmV2lkdGgsIHNkZkhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcmdiYURhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gVGhyb3cgYXdheSBhbGwgYnV0IHRoZSByZWQgY2hhbm5lbFxuICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoc2RmV2lkdGggKiBzZGZIZWlnaHQpO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IHJnYmFEYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBkYXRhW2orK10gPSByZ2JhRGF0YVtpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVJbnRvQ2FudmFzJDEoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwpIHtcbiAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG4gICAgaWYgKCB4ID09PSB2b2lkIDAgKSB4ID0gMDtcbiAgICBpZiAoIHkgPT09IHZvaWQgMCApIHkgPSAwO1xuICAgIGlmICggY2hhbm5lbCA9PT0gdm9pZCAwICkgY2hhbm5lbCA9IDA7XG5cbiAgICBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlcihzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGNhbnZhcywgbnVsbCwgeCwgeSwgY2hhbm5lbCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlciAoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBnbE9yQ2FudmFzLCBmcmFtZWJ1ZmZlciwgeCwgeSwgY2hhbm5lbCkge1xuICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcbiAgICBpZiAoIHggPT09IHZvaWQgMCApIHggPSAwO1xuICAgIGlmICggeSA9PT0gdm9pZCAwICkgeSA9IDA7XG4gICAgaWYgKCBjaGFubmVsID09PSB2b2lkIDAgKSBjaGFubmVsID0gMDtcblxuICAgIC8vIFZlcmlmeSBzdXBwb3J0XG4gICAgdmFsaWRhdGVTdXBwb3J0KGdsT3JDYW52YXMpO1xuXG4gICAgLy8gQ29tcHV0ZSBwYXRoIHNlZ21lbnRzXG4gICAgdmFyIGxpbmVTZWdtZW50Q29vcmRzID0gW107XG4gICAgcGF0aFRvTGluZVNlZ21lbnRzKHBhdGgsIGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgbGluZVNlZ21lbnRDb29yZHMucHVzaCh4MSwgeTEsIHgyLCB5Mik7XG4gICAgfSk7XG4gICAgbGluZVNlZ21lbnRDb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KGxpbmVTZWdtZW50Q29vcmRzKTtcblxuICAgIHdpdGhXZWJHTENvbnRleHQoZ2xPckNhbnZhcywgZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIGdsID0gcmVmLmdsO1xuICAgICAgdmFyIGlzV2ViR0wyID0gcmVmLmlzV2ViR0wyO1xuICAgICAgdmFyIGdldEV4dGVuc2lvbiA9IHJlZi5nZXRFeHRlbnNpb247XG4gICAgICB2YXIgd2l0aFByb2dyYW0gPSByZWYud2l0aFByb2dyYW07XG4gICAgICB2YXIgd2l0aFRleHR1cmUgPSByZWYud2l0aFRleHR1cmU7XG4gICAgICB2YXIgd2l0aFRleHR1cmVGcmFtZWJ1ZmZlciA9IHJlZi53aXRoVGV4dHVyZUZyYW1lYnVmZmVyO1xuICAgICAgdmFyIGhhbmRsZUNvbnRleHRMb3NzID0gcmVmLmhhbmRsZUNvbnRleHRMb3NzO1xuXG4gICAgICB3aXRoVGV4dHVyZSgncmF3RGlzdGFuY2VzJywgZnVuY3Rpb24gKGludGVybWVkaWF0ZVRleHR1cmUsIGludGVybWVkaWF0ZVRleHR1cmVVbml0KSB7XG4gICAgICAgIGlmIChzZGZXaWR0aCAhPT0gaW50ZXJtZWRpYXRlVGV4dHVyZS5fbGFzdFdpZHRoIHx8IHNkZkhlaWdodCAhPT0gaW50ZXJtZWRpYXRlVGV4dHVyZS5fbGFzdEhlaWdodCkge1xuICAgICAgICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgICAgICBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLFxuICAgICAgICAgICAgaW50ZXJtZWRpYXRlVGV4dHVyZS5fbGFzdFdpZHRoID0gc2RmV2lkdGgsXG4gICAgICAgICAgICBpbnRlcm1lZGlhdGVUZXh0dXJlLl9sYXN0SGVpZ2h0ID0gc2RmSGVpZ2h0LFxuICAgICAgICAgICAgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVbnNpZ25lZCBkaXN0YW5jZSBwYXNzXG4gICAgICAgIHdpdGhQcm9ncmFtKCdtYWluJywgbWFpblZlcnRleCwgbWFpbkZyYWdtZW50LCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgdmFyIHNldEF0dHJpYnV0ZSA9IHJlZi5zZXRBdHRyaWJ1dGU7XG4gICAgICAgICAgdmFyIHNldFVuaWZvcm0gPSByZWYuc2V0VW5pZm9ybTtcblxuICAgICAgICAgIC8vIEluaXQgZXh0ZW5zaW9uc1xuICAgICAgICAgIHZhciBpbnN0YW5jaW5nRXh0ZW5zaW9uID0gIWlzV2ViR0wyICYmIGdldEV4dGVuc2lvbignQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpO1xuICAgICAgICAgIHZhciBibGVuZE1pbk1heEV4dGVuc2lvbiA9ICFpc1dlYkdMMiAmJiBnZXRFeHRlbnNpb24oJ0VYVF9ibGVuZF9taW5tYXgnKTtcblxuICAgICAgICAgIC8vIEluaXQvdXBkYXRlIGF0dHJpYnV0ZXNcbiAgICAgICAgICBzZXRBdHRyaWJ1dGUoJ2FVVicsIDIsIGdsLlNUQVRJQ19EUkFXLCAwLCB2aWV3cG9ydFVWcyk7XG4gICAgICAgICAgc2V0QXR0cmlidXRlKCdhTGluZVNlZ21lbnQnLCA0LCBnbC5EWU5BTUlDX0RSQVcsIDEsIGxpbmVTZWdtZW50Q29vcmRzKTtcblxuICAgICAgICAgIC8vIEluaXQvdXBkYXRlIHVuaWZvcm1zXG4gICAgICAgICAgc2V0VW5pZm9ybS5hcHBseSh2b2lkIDAsIFsgJzRmJywgJ3VHbHlwaEJvdW5kcycgXS5jb25jYXQoIHZpZXdCb3ggKSk7XG4gICAgICAgICAgc2V0VW5pZm9ybSgnMWYnLCAndU1heERpc3RhbmNlJywgbWF4RGlzdGFuY2UpO1xuICAgICAgICAgIHNldFVuaWZvcm0oJzFmJywgJ3VFeHBvbmVudCcsIHNkZkV4cG9uZW50KTtcblxuICAgICAgICAgIC8vIFJlbmRlciBpbml0aWFsIHVuc2lnbmVkIGRpc3RhbmNlIC8gd2luZGluZyBudW1iZXIgaW5mbyB0byBhIHRleHR1cmVcbiAgICAgICAgICB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyKGludGVybWVkaWF0ZVRleHR1cmUsIGludGVybWVkaWF0ZVRleHR1cmVVbml0LCBmdW5jdGlvbiAoZnJhbWVidWZmZXIpIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCBzZGZXaWR0aCwgc2RmSGVpZ2h0KTtcbiAgICAgICAgICAgIGdsLnNjaXNzb3IoMCwgMCwgc2RmV2lkdGgsIHNkZkhlaWdodCk7XG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xuICAgICAgICAgICAgLy8gUmVkK0dyZWVuIGNoYW5uZWxzIGFyZSBpbmNyZW1lbnRlZCAoRlVOQ19BREQpIGZvciBzZWdtZW50LXJheSBjcm9zc2luZ3MgdG8gZ2l2ZSBhIFwid2luZGluZyBudW1iZXJcIi5cbiAgICAgICAgICAgIC8vIEFscGhhIGhvbGRzIHRoZSBjbG9zZXN0IChNQVgpIHVuc2lnbmVkIGRpc3RhbmNlLlxuICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKGdsLkZVTkNfQURELCBpc1dlYkdMMiA/IGdsLk1BWCA6IGJsZW5kTWluTWF4RXh0ZW5zaW9uLk1BWF9FWFQpO1xuICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgICAgICBpZiAoaXNXZWJHTDIpIHtcbiAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5c0luc3RhbmNlZChnbC5UUklBTkdMRVMsIDAsIDMsIGxpbmVTZWdtZW50Q29vcmRzLmxlbmd0aCAvIDQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2luZ0V4dGVuc2lvbi5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoZ2wuVFJJQU5HTEVTLCAwLCAzLCBsaW5lU2VnbWVudENvb3Jkcy5sZW5ndGggLyA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlYnVnXG4gICAgICAgICAgICAvLyBjb25zdCBkZWJ1ZyA9IG5ldyBVaW50OEFycmF5KHNkZldpZHRoICogc2RmSGVpZ2h0ICogNClcbiAgICAgICAgICAgIC8vIGdsLnJlYWRQaXhlbHMoMCwgMCwgc2RmV2lkdGgsIHNkZkhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZGVidWcpXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnaW50ZXJtZWRpYXRlIHRleHR1cmUgZGF0YTogJywgZGVidWcpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFVzZSB0aGUgZGF0YSBzdG9yZWQgaW4gdGhlIHRleHR1cmUgdG8gYXBwbHkgaW5zaWRlL291dHNpZGUgYW5kIHdyaXRlIHRvIHRoZSBvdXRwdXQgZnJhbWVidWZmZXIgcmVjdCtjaGFubmVsLlxuICAgICAgICB3aXRoUHJvZ3JhbSgncG9zdCcsIHZpZXdwb3J0UXVhZFZlcnRleCwgcG9zdEZyYWdtZW50LCBmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgIHByb2dyYW0uc2V0QXR0cmlidXRlKCdhVVYnLCAyLCBnbC5TVEFUSUNfRFJBVywgMCwgdmlld3BvcnRVVnMpO1xuICAgICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybSgnMWknLCAndGV4JywgaW50ZXJtZWRpYXRlVGV4dHVyZVVuaXQpO1xuICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgIGdsLmNvbG9yTWFzayhjaGFubmVsID09PSAwLCBjaGFubmVsID09PSAxLCBjaGFubmVsID09PSAyLCBjaGFubmVsID09PSAzKTtcbiAgICAgICAgICBnbC52aWV3cG9ydCh4LCB5LCBzZGZXaWR0aCwgc2RmSGVpZ2h0KTtcbiAgICAgICAgICBnbC5zY2lzc29yKHgsIHksIHNkZldpZHRoLCBzZGZIZWlnaHQpO1xuICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCAzKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gSGFuZGxlIGNvbnRleHQgbG9zcyBvY2N1cnJpbmcgZHVyaW5nIGFueSBvZiB0aGUgYWJvdmUgY2FsbHNcbiAgICAgIGlmIChnbC5pc0NvbnRleHRMb3N0KCkpIHtcbiAgICAgICAgaGFuZGxlQ29udGV4dExvc3MoKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3ZWJnbCBjb250ZXh0IGxvc3QnKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTdXBwb3J0ZWQgKGdsT3JDYW52YXMpIHtcbiAgICB2YXIga2V5ID0gKCFnbE9yQ2FudmFzIHx8IGdsT3JDYW52YXMgPT09IGltcGxpY2l0Q29udGV4dCkgPyBOVUxMX09CSkVDVCA6IChnbE9yQ2FudmFzLmNhbnZhcyB8fCBnbE9yQ2FudmFzKTtcbiAgICB2YXIgc3VwcG9ydGVkID0gc3VwcG9ydEJ5Q2FudmFzLmdldChrZXkpO1xuICAgIGlmIChzdXBwb3J0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaXNUZXN0aW5nU3VwcG9ydCA9IHRydWU7XG4gICAgICB2YXIgZmFpbFJlYXNvbiA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBTaW5jZSB3ZSBjYW4ndCBkZXRlY3QgYWxsIGZhaWx1cmUgbW9kZXMgdXAgZnJvbnQsIGxldCdzIGp1c3QgZG8gYSB0cmlhbCBydW4gb2YgYVxuICAgICAgICAvLyBzaW1wbGUgcGF0aCBhbmQgY29tcGFyZSB3aGF0IHdlIGdldCBiYWNrIHRvIHRoZSBjb3JyZWN0IGV4cGVjdGVkIHJlc3VsdC4gVGhpcyB3aWxsXG4gICAgICAgIC8vIGFsc28gc2VydmUgdG8gcHJpbWUgdGhlIHNoYWRlciBjb21waWxhdGlvbi5cbiAgICAgICAgdmFyIGV4cGVjdGVkUmVzdWx0ID0gW1xuICAgICAgICAgIDk3LCAxMDYsIDk3LCA2MSxcbiAgICAgICAgICA5OSwgMTM3LCAxMTgsIDgwLFxuICAgICAgICAgIDgwLCAxMTgsIDEzNywgOTksXG4gICAgICAgICAgNjEsIDk3LCAxMDYsIDk3XG4gICAgICAgIF07XG4gICAgICAgIHZhciB0ZXN0UmVzdWx0ID0gZ2VuZXJhdGUkMShcbiAgICAgICAgICA0LFxuICAgICAgICAgIDQsXG4gICAgICAgICAgJ004LDhMMTYsOEwyNCwyNEwxNiwyNFonLFxuICAgICAgICAgIFswLCAwLCAzMiwgMzJdLFxuICAgICAgICAgIDI0LFxuICAgICAgICAgIDEsXG4gICAgICAgICAgZ2xPckNhbnZhc1xuICAgICAgICApO1xuICAgICAgICBzdXBwb3J0ZWQgPSB0ZXN0UmVzdWx0ICYmIGV4cGVjdGVkUmVzdWx0Lmxlbmd0aCA9PT0gdGVzdFJlc3VsdC5sZW5ndGggJiZcbiAgICAgICAgICB0ZXN0UmVzdWx0LmV2ZXJ5KGZ1bmN0aW9uICh2YWwsIGkpIHsgcmV0dXJuIHZhbCA9PT0gZXhwZWN0ZWRSZXN1bHRbaV07IH0pO1xuICAgICAgICBpZiAoIXN1cHBvcnRlZCkge1xuICAgICAgICAgIGZhaWxSZWFzb24gPSAnYmFkIHRyaWFsIHJ1biByZXN1bHRzJztcbiAgICAgICAgICBjb25zb2xlLmluZm8oZXhwZWN0ZWRSZXN1bHQsIHRlc3RSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gVE9ETyBpZiBpdCB0aHJldyBkdWUgdG8gd2ViZ2wgY29udGV4dCBsb3NzLCBzaG91bGQgd2UgbWF5YmUgbGVhdmUgaXNTdXBwb3J0ZWQgYXMgbnVsbCBhbmQgdHJ5IGFnYWluIGxhdGVyP1xuICAgICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgZmFpbFJlYXNvbiA9IGVyci5tZXNzYWdlO1xuICAgICAgfVxuICAgICAgaWYgKGZhaWxSZWFzb24pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXZWJHTCBTREYgZ2VuZXJhdGlvbiBub3Qgc3VwcG9ydGVkOicsIGZhaWxSZWFzb24pO1xuICAgICAgfVxuICAgICAgaXNUZXN0aW5nU3VwcG9ydCA9IGZhbHNlO1xuICAgICAgc3VwcG9ydEJ5Q2FudmFzLnNldChrZXksIHN1cHBvcnRlZCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBwb3J0ZWRcbiAgfVxuXG4gIHZhciB3ZWJnbCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2VuZXJhdGU6IGdlbmVyYXRlJDEsXG4gICAgZ2VuZXJhdGVJbnRvQ2FudmFzOiBnZW5lcmF0ZUludG9DYW52YXMkMSxcbiAgICBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlcjogZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIsXG4gICAgaXNTdXBwb3J0ZWQ6IGlzU3VwcG9ydGVkXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBTREYgdGV4dHVyZSBpbWFnZSBmb3IgYSAyRCBwYXRoLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2RmV2lkdGggLSB3aWR0aCBvZiB0aGUgU0RGIG91dHB1dCBpbWFnZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZGZIZWlnaHQgLSBoZWlnaHQgb2YgdGhlIFNERiBvdXRwdXQgaW1hZ2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIGFuIFNWRy1saWtlIHBhdGggc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGdseXBoOyBzaG91bGQgb25seSBjb250YWluIGNvbW1hbmRzOiBNL0wvUS9DL1ouXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IHZpZXdCb3ggLSBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gaW4gZm9udCB1bml0cyBhbGlnbmluZyB3aXRoIHRoZSB0ZXh0dXJlJ3MgZWRnZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhEaXN0YW5jZSAtIHRoZSBtYXhpbXVtIGRpc3RhbmNlIGZyb20gdGhlIGdseXBoIHBhdGggaW4gZm9udCB1bml0cyB0aGF0IHdpbGwgYmUgZW5jb2RlZDsgZGVmYXVsdHNcbiAgICogICAgICAgIHRvIGhhbGYgdGhlIG1heGltdW0gdmlld0JveCBkaW1lbnNpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2RmRXhwb25lbnRdIC0gc3BlY2lmaWVzIGFuIGV4cG9uZW50IGZvciBlbmNvZGluZyB0aGUgU0RGJ3MgZGlzdGFuY2UgdmFsdWVzOyBoaWdoZXIgZXhwb25lbnRzXG4gICAqICAgICAgICB3aWxsIGdpdmUgZ3JlYXRlciBwcmVjaXNpb24gbmVhcmVyIHRoZSBnbHlwaCdzIHBhdGguXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gICAqL1xuICBmdW5jdGlvbiBnZW5lcmF0ZShcbiAgICBzZGZXaWR0aCxcbiAgICBzZGZIZWlnaHQsXG4gICAgcGF0aCxcbiAgICB2aWV3Qm94LFxuICAgIG1heERpc3RhbmNlLFxuICAgIHNkZkV4cG9uZW50XG4gICkge1xuICAgIGlmICggbWF4RGlzdGFuY2UgPT09IHZvaWQgMCApIG1heERpc3RhbmNlID0gTWF0aC5tYXgodmlld0JveFsyXSAtIHZpZXdCb3hbMF0sIHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAvIDI7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnZW5lcmF0ZSQxLmFwcGx5KHdlYmdsLCBhcmd1bWVudHMpXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBjb25zb2xlLmluZm8oJ1dlYkdMIFNERiBnZW5lcmF0aW9uIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIEpTJywgZSk7XG4gICAgICByZXR1cm4gZ2VuZXJhdGUkMi5hcHBseShqYXZhc2NyaXB0LCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIFNERiB0ZXh0dXJlIGltYWdlIGZvciBhIDJEIHBhdGgsIGluc2VydGluZyB0aGUgcmVzdWx0IGludG8gYSBXZWJHTCBgY2FudmFzYCBhdCBhIGdpdmVuIHgveSBwb3NpdGlvblxuICAgKiBhbmQgY29sb3IgY2hhbm5lbC4gVGhpcyBpcyBnZW5lcmFsbHkgbXVjaCBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBnZW5lcmF0ZWAgYmVjYXVzZSBpdCBkb2VzIG5vdCByZXF1aXJlIHJlYWRpbmcgcGl4ZWxzXG4gICAqIGJhY2sgZnJvbSB0aGUgR1BVLT5DUFUgLS0gdGhlIGBjYW52YXNgIGNhbiBiZSB1c2VkIGRpcmVjdGx5IGFzIGEgV2ViR0wgdGV4dHVyZSBpbWFnZSwgc28gaXQgYWxsIHN0YXlzIG9uIHRoZSBHUFUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZGZXaWR0aCAtIHdpZHRoIG9mIHRoZSBTREYgb3V0cHV0IGltYWdlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNkZkhlaWdodCAtIGhlaWdodCBvZiB0aGUgU0RGIG91dHB1dCBpbWFnZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gYW4gU1ZHLWxpa2UgcGF0aCBzdHJpbmcgZGVzY3JpYmluZyB0aGUgZ2x5cGg7IHNob3VsZCBvbmx5IGNvbnRhaW4gY29tbWFuZHM6IE0vTC9RL0MvWi5cbiAgICogQHBhcmFtIHtudW1iZXJbXX0gdmlld0JveCAtIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBpbiBmb250IHVuaXRzIGFsaWduaW5nIHdpdGggdGhlIHRleHR1cmUncyBlZGdlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heERpc3RhbmNlIC0gdGhlIG1heGltdW0gZGlzdGFuY2UgZnJvbSB0aGUgZ2x5cGggcGF0aCBpbiBmb250IHVuaXRzIHRoYXQgd2lsbCBiZSBlbmNvZGVkOyBkZWZhdWx0c1xuICAgKiAgICAgICAgdG8gaGFsZiB0aGUgbWF4aW11bSB2aWV3Qm94IGRpbWVuc2lvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZGZFeHBvbmVudF0gLSBzcGVjaWZpZXMgYW4gZXhwb25lbnQgZm9yIGVuY29kaW5nIHRoZSBTREYncyBkaXN0YW5jZSB2YWx1ZXM7IGhpZ2hlciBleHBvbmVudHNcbiAgICogICAgICAgIHdpbGwgZ2l2ZSBncmVhdGVyIHByZWNpc2lvbiBuZWFyZXIgdGhlIGdseXBoJ3MgcGF0aC5cbiAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudHxPZmZzY3JlZW5DYW52YXN9IGNhbnZhcyAtIGEgV2ViR0wtZW5hYmxlZCBjYW52YXMgaW50byB3aGljaCB0aGUgU0RGIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAqICAgICAgICBPbmx5IHRoZSByZWxldmFudCByZWN0L2NoYW5uZWwgd2lsbCBiZSBtb2RpZmllZCwgdGhlIHJlc3Qgd2lsbCBiZSBwcmVzZXJ2ZWQuIFRvIGF2b2lkIHVucHJlZGljdGFibGUgcmVzdWx0c1xuICAgKiAgICAgICAgZHVlIHRvIHNoYXJlZCBHTCBjb250ZXh0IHN0YXRlLCB0aGlzIGNhbnZhcyBzaG91bGQgYmUgZGVkaWNhdGVkIHRvIHVzZSBieSB0aGlzIGxpYnJhcnkgYWxvbmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHggcG9zaXRpb24gYXQgd2hpY2ggdG8gcmVuZGVyIHRoZSBTREYuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgcG9zaXRpb24gYXQgd2hpY2ggdG8gcmVuZGVyIHRoZSBTREYuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFubmVsIC0gdGhlIGNvbG9yIGNoYW5uZWwgaW5kZXggKDAtNCkgaW50byB3aGljaCB0aGUgU0RGIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gICAqL1xuICBmdW5jdGlvbiBnZW5lcmF0ZUludG9DYW52YXMoXG4gICAgc2RmV2lkdGgsXG4gICAgc2RmSGVpZ2h0LFxuICAgIHBhdGgsXG4gICAgdmlld0JveCxcbiAgICBtYXhEaXN0YW5jZSxcbiAgICBzZGZFeHBvbmVudCxcbiAgICBjYW52YXMsXG4gICAgeCxcbiAgICB5LFxuICAgIGNoYW5uZWxcbiAgKSB7XG4gICAgaWYgKCBtYXhEaXN0YW5jZSA9PT0gdm9pZCAwICkgbWF4RGlzdGFuY2UgPSBNYXRoLm1heCh2aWV3Qm94WzJdIC0gdmlld0JveFswXSwgdmlld0JveFszXSAtIHZpZXdCb3hbMV0pIC8gMjtcbiAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG4gICAgaWYgKCB4ID09PSB2b2lkIDAgKSB4ID0gMDtcbiAgICBpZiAoIHkgPT09IHZvaWQgMCApIHkgPSAwO1xuICAgIGlmICggY2hhbm5lbCA9PT0gdm9pZCAwICkgY2hhbm5lbCA9IDA7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGdlbmVyYXRlSW50b0NhbnZhcyQxLmFwcGx5KHdlYmdsLCBhcmd1bWVudHMpXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBjb25zb2xlLmluZm8oJ1dlYkdMIFNERiBnZW5lcmF0aW9uIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIEpTJywgZSk7XG4gICAgICByZXR1cm4gZ2VuZXJhdGVJbnRvQ2FudmFzJDIuYXBwbHkoamF2YXNjcmlwdCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuXG4gIGV4cG9ydHMuZm9yRWFjaFBhdGhDb21tYW5kID0gZm9yRWFjaFBhdGhDb21tYW5kO1xuICBleHBvcnRzLmdlbmVyYXRlID0gZ2VuZXJhdGU7XG4gIGV4cG9ydHMuZ2VuZXJhdGVJbnRvQ2FudmFzID0gZ2VuZXJhdGVJbnRvQ2FudmFzO1xuICBleHBvcnRzLmphdmFzY3JpcHQgPSBqYXZhc2NyaXB0O1xuICBleHBvcnRzLnBhdGhUb0xpbmVTZWdtZW50cyA9IHBhdGhUb0xpbmVTZWdtZW50cztcbiAgZXhwb3J0cy53ZWJnbCA9IHdlYmdsO1xuICBleHBvcnRzLndlYmdsVXRpbHMgPSB3ZWJnbFV0aWxzO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oe30pKTtcbnJldHVybiBleHBvcnRzXG59XG5cbmV4cG9ydCB7IFNERkdlbmVyYXRvciBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs\n"));

/***/ })

}]);